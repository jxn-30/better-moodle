// ==UserScript==
// @name            🎓️ UzL: better-moodle
// @namespace       https://uni-luebeck.de
// @version         2.0.1
// @author          Jan (jxn_30), Yorik (YorikHansen)
// @description     Improves UzL-Moodle by cool features and design improvements.
// @description:de  Verbessert das UzL-Moodle durch coole Features und Designverbesserungen.
// @icon            https://icons.better-moodle.dev/uzl.png
// @homepage        https://github.com/jxn-30/better-moodle/tree/main
// @homepageURL     https://github.com/jxn-30/better-moodle/tree/main
// @downloadURL     https://github.com/jxn-30/better-moodle/releases/latest/download/better-moodle-uzl.user.js
// @updateURL       https://github.com/jxn-30/better-moodle/releases/latest/download/better-moodle-uzl.meta.js
// @match           https://moodle.uni-luebeck.de/*
// @require         https://unpkg.com/darkreader@4.9.109/darkreader.js#sha512=271eff21e666eb6df13559f05dff04018ce6e66bc698c89dda95a6caa69a8aef9bc1a38a906ed9c09144bcdab8f3ffd4d0f537518f341bb885c10bb3c304aafc
// @require         https://github.com/jxn-30/better-moodle/releases/download/2.0.1/better-moodle-uzl-polyfills.js
// @connect         better-moodle.dev
// @connect         studentenwerk.sh
// @connect         nina.api.proxy.bund.dev
// @connect         api.open-meteo.com
// @connect         api.openweathermap.org
// @connect         weather.visualcrossing.com
// @connect         wttr.in
// @grant           GM.xmlHttpRequest
// @grant           GM_addStyle
// @grant           GM_addValueChangeListener
// @grant           GM_deleteValue
// @grant           GM_getValue
// @grant           GM_info
// @grant           GM_listValues
// @grant           GM_notification
// @grant           GM_setValue
// @grant           unsafeWindow
// @run-at          document-body
// ==/UserScript==

/*! Copyright © *****************************************************************************
 *                                                                                          *
 *   This is Better-Moodle; Version 2.0.1; Built for UzL (https://moodle.uni-luebeck.de).   *
 *   Copyright (c) 2023-2025 Jan (@jxn-30), Yorik (@YorikHansen) and contributors.          *
 *   All rights reserved.                                                                   *
 *   Licensed under the MIT License (MIT).                                                  *
 *   Source-Code: https://github.com/jxn-30/better-moodle                                   *
 *                                                                                          *
 ********************************************************************************************/

/* global global, globalThis, ActiveXObject, Iterator, M, requirejs, DarkReader */
/* eslint no-redeclare: ["error", { "builtinGlobals": false }] */

(async function () {
  'use strict';

  const d = new Set();
  const importCSS = async e => {
    d.has(e) ||
      (d.add(e),
      (t => {
        typeof GM_addStyle == 'function' ?
          GM_addStyle(t)
        : document.head.appendChild(document.createElement('style')).append(t);
      })(e));
  };

  importCSS(` @property --navbar-height {
  syntax: "<length>";
  inherits: true;
  initial-value: 60px;
}
#page-login-index {
  overflow: hidden;
}
#page-login-index #page-wrapper {
  overflow: auto;
}

.custom-control.custom-switch .custom-control-label {
  cursor: pointer;
}

#usernavigation {
  max-width: calc(100% - 1rem);
}

.form-label-addon [data-toggle=popover] i.icon.fa {
  margin-left: 0.25rem;
  margin-right: 0.25rem;
}

.toast-wrapper {
  z-index: 1053;
}

.drawer-toggles .drawer-toggler .btn .icon.fa-fw {
  width: 16px;
}

body:not(.limitedwidth) .secondary-navigation .navigation .nav-tabs {
  max-width: unset;
  justify-content: center;
}

.drawer.drawer-right .drawerheader {
  flex-flow: row-reverse;
}

select[disabled],
.custom-switch:has(input[disabled]),
.custom-switch:has(input[disabled]) .custom-control-label {
  cursor: not-allowed;
}

body.dir-ltr .better-moodle__no-external-link-icon::after, body.dir-rtl .better-moodle__no-external-link-icon::before {
  display: none !important;
}

.better-moodle__awaits-dropdown::after {
  margin-left: 4px;
  width: 9px;
  font-size: 9px;
  display: var(--fa-display, inline-block);
  font-style: normal;
  font-feature-settings: normal;
  font-variant: normal;
  line-height: 1;
  text-rendering: auto;
  font-family: var(--fa-style-family, "Font Awesome 6 Free");
  font-weight: var(--fa-style, 900);
  display: inline-block;
  content: "\\f252" !important;
}
@media (prefers-reduced-motion: no-preference) {
  .better-moodle__awaits-dropdown::after {
    animation: better-moodle__fade 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }
}
@keyframes better-moodle__fade {
  0% {
    opacity: 0.5;
  }
  50% {
    opacity: 0.2;
  }
  100% {
    opacity: 0.5;
  }
}
.better-moodle__awaits-dropdown .icon {
  opacity: 0.5;
}

#usernavigation > :not(.better-moodle__navbar-item) {
  order: 0;
}
#usernavigation > :not(.better-moodle__navbar-item).usermenu-container, #usernavigation > :not(.better-moodle__navbar-item).editmode-switch-form, #usernavigation > :not(.better-moodle__navbar-item).divider:has(+ .editmode-switch-form) {
  order: 1000;
}

@media (prefers-reduced-motion: no-preference) {
  .better-moodle__shining {
    position: relative;
    background-image: linear-gradient(-75deg, transparent 0%, rgba(255, 255, 255, 0.75) 15%, transparent 30%, transparent 100%);
    background-size: 200%;
    background-repeat: no-repeat;
  }
  .better-moodle__shining {
    animation: better-moodle__shining 5s ease-in-out;
  }
}
@keyframes better-moodle__shining {
  0% {
    background-position: 200% 0;
  }
  20% {
    background-position: 0 0;
  }
  100% {
    background-position: 0 0;
  }
}
.better-moodle__sparkling::before {
  display: inline-block;
  content: " ";
  position: absolute;
  width: 10ch;
  height: 16.3636363636ch;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1100 1800'%3e %3cpath fill='gold' d='M 550 0 C 550 720 660 900 1100 900 C 660 900 550 1080 550 1800 C 550 1080 440 900 0 900 C 440 900 550 720 550 0'/%3e %3c/svg%3e");
  background-size: 100%;
  background-repeat: no-repeat;
  transform: translate(-50%, -50%);
  transform-origin: top left;
  top: 0;
  left: 0;
}
.better-moodle__sparkling::before {
  animation: better-moodle__sparkling 1s ease-in-out infinite alternate, better-moodle__sparkling_positions 6s step-start infinite;
}
@keyframes better-moodle__sparkling {
  0% {
    scale: 0;
  }
  10% {
    scale: 0;
  }
  100% {
    scale: 10%;
  }
}
@keyframes better-moodle__sparkling_positions {
  0% {
    top: 4%;
    left: 14%;
  }
  33% {
    top: 85%;
    left: 51%;
  }
  66% {
    top: 32%;
    left: 87%;
  }
}#better-moodle_settings__open-settings-btn.loading {
  opacity: 0.5;
}
#better-moodle_settings__open-settings-btn .tooltip:has(.better-moodle_settings__new-setting-badge) {
  z-index: 1035;
  cursor: pointer;
}

.modal-content:has(#better-moodle_settings__settings-form) .modal-header {
  align-items: center;
}
.modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 ~ :not(div:has(input)) {
  padding: 1rem;
  margin: -0.8rem -0.8rem -0.8rem 0;
}
.modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 ~ :not(button.close) {
  font-size: small;
}
.modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 ~ div:has(> input[type=search]) {
  padding: 0;
  margin-bottom: 0;
  position: relative;
}
.modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 ~ div:has(> input[type=search]) i.fa-search {
  width: 1em;
  position: absolute;
  top: 0;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  margin-left: 0.5em;
  color: grey;
  pointer-events: none;
}
.modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 ~ div:has(> input[type=search]) > input[type=search] {
  padding-left: 1.6em;
}
.modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 ~ div:has(> input[type=search]) > input[type=search]:not(:focus) {
  background-color: transparent;
}
@media (max-width: 991.98px) {
  .modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 {
    flex-basis: 100%;
    flex-shrink: 1;
  }
  .modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 ~ div:has(input[type=search]):has(> input[type=search]:focus) {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
  }
  .modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 ~ div:has(input[type=search]):has(> input[type=search]:not(:focus)) {
    max-width: 2em;
  }
  .modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 ~ div:has(input[type=search]):has(> input[type=search]:not(:focus))::before {
    margin-left: 0;
    width: calc(100% + 2px);
  }
  .modal-content:has(#better-moodle_settings__settings-form) .modal-header h5 ~ div:has(input[type=search]) > input[type=search]:not(:focus) {
    padding-right: 0;
    padding-left: 2em;
  }
}
.modal-content:has(#better-moodle_settings__settings-form) #better-moodle_settings__support-wrapper {
  top: 0.5rem;
  right: 0.5rem;
}
@media (max-width: 991.98px) {
  .modal-content:has(#better-moodle_settings__settings-form) #better-moodle_settings__support-wrapper {
    position: unset !important;
  }
  .modal-content:has(#better-moodle_settings__settings-form) #better-moodle_settings__support-wrapper > div > span {
    padding: 0.25rem 0.5rem;
    text-align: center;
  }
}
@media (min-width: 992px) {
  .modal-content:has(#better-moodle_settings__settings-form) #better-moodle_settings__support-wrapper > div > span {
    margin: 0 0.5rem;
  }
}
.modal-content:has(#better-moodle_settings__settings-form) .fitem:has(input[disabled], select[disabled]) .col-form-label label {
  color: var(--gray);
}
.better-moodle_settings__hide-disabled-settings .modal-content:has(#better-moodle_settings__settings-form) .fitem:has(input[disabled], select[disabled]) {
  display: none;
}
.modal-content:has(#better-moodle_settings__settings-form) .fitem .better-moodle_settings__new-setting-badge {
  margin-right: 1ch;
}
.modal-content:has(#better-moodle_settings__settings-form) fieldset .ftoggler h3 .better-moodle_settings__new-setting-badge {
  margin-left: 1ch;
}
.modal-content:has(#better-moodle_settings__settings-form) fieldset:not(:has(.fcontainer .better-moodle_settings__new-setting-badge)) .ftoggler h3 .better-moodle_settings__new-setting-badge {
  display: none;
}
.modal-content:has(#better-moodle_settings__settings-form) .better-moodle_settings__hide-new-setting-badges .better-moodle_settings__new-setting-badge {
  display: none !important;
}
.better-moodle_settings__hide-fun-settings .modal-content:has(#better-moodle_settings__settings-form) .fitem[data-tags*=fun] {
  display: none;
}
.modal-content:has(#better-moodle_settings__settings-form) #better-moodle_settings__settings-footer-btns > :where(button, a) > span {
  font-size: 0;
}
@media (min-width: 992px) and (prefers-reduced-motion: no-preference) {
  .modal-content:has(#better-moodle_settings__settings-form) #better-moodle_settings__settings-footer-btns > :where(button, a) > span {
    font-size: 0;
    transition: font-size 0.5s;
  }
  .modal-content:has(#better-moodle_settings__settings-form) #better-moodle_settings__settings-footer-btns > :where(button, a):hover > span {
    font-size: unset;
  }
}
@media (hover: none) and (max-width: 991.98px) {
  .modal-content:has(#better-moodle_settings__settings-form) #better-moodle_settings__settings-footer-btns > :where(button, a) {
    width: 100%;
  }
}
@media (hover: none) {
  .modal-content:has(#better-moodle_settings__settings-form) #better-moodle_settings__settings-footer-btns > :where(button, a) > span {
    font-size: unset;
  }
}.better-moodle_settings-SliderSetting__slider-setting datalist[style*="--label-count"] {
  display: grid;
  grid-template-columns: repeat(var(--label-count), minmax(0, 1fr));
  text-align: center;
  margin: 0 calc(50% - 0.5 * (1 + 1 / (var(--label-count) - 1)) * (100% - 1em));
}
.better-moodle_settings-SliderSetting__slider-setting datalist[style*="--label-count"] > option {
  overflow: hidden;
  text-overflow: ellipsis;
}
.better-moodle_settings-SliderSetting__slider-setting datalist[style*="--label-count"] > option:first-child {
  text-align: left;
  padding-left: calc(50% - 4px);
}
.better-moodle_settings-SliderSetting__slider-setting datalist[style*="--label-count"] > option:last-child {
  text-align: right;
  padding-right: calc(50% - 4px);
}
.better-moodle_settings-SliderSetting__slider-setting datalist[style*="--label-count"] > option::after {
  content: "";
  position: absolute;
  border: 1px solid grey;
  height: 10px;
  left: 50%;
  transform: translateX(-50%) translateY(-50%);
  top: 0;
}
.better-moodle_settings-SliderSetting__slider-setting input[type=range] + output {
  position: absolute;
  text-align: center;
  white-space: nowrap;
  padding: 2px;
  background-color: var(--primary);
  color: white;
  border-radius: 4px;
  font-weight: bold;
  z-index: 1;
  left: calc(1% * var(--percentage));
  transform: translateX(calc(-1% * var(--percentage)));
}
.better-moodle_settings-SliderSetting__slider-setting input:disabled[type=range] + output {
  background-color: color-mix(in srgb, var(--primary) 50%, transparent);
}.better-moodle_modal__modal-background-image {
  position: absolute;
  width: 90%;
  height: 90%;
  opacity: 0.1;
  top: 5%;
  left: 5%;
  object-fit: contain;
  pointer-events: none;
}
@media (prefers-contrast: more) {
  .better-moodle_modal__modal-background-image {
    display: none;
  }
}

.better-moodle_modal__modal-trigger {
  cursor: pointer;
}#better-moodle_bookmarks__dropdown .dropdown-menu {
  max-width: 400px;
  right: 0;
  left: auto;
}
#better-moodle_bookmarks__dropdown .dropdown-menu:has(.dropdown-item:first-child:nth-last-child(3))::before {
  display: block;
  text-align: center;
  content: var(--empty-text);
  font-size: small;
  padding: 0.25rem 1.5rem;
}
#better-moodle_bookmarks__dropdown .dropdown-menu .dropdown-item {
  min-width: 100%;
  width: fit-content;
}
@media (max-width: 575.98px) {
  #better-moodle_bookmarks__dropdown {
    position: inherit;
  }
  #better-moodle_bookmarks__dropdown .dropdown-menu {
    max-width: 100%;
  }
  #better-moodle_bookmarks__dropdown .dropdown-menu .dropdown-item {
    overflow: auto;
  }
}

.better-moodle_bookmarks__form .fcontainer {
  display: grid;
  grid-template-columns: 1fr 2fr auto;
  grid-column-gap: 1ch;
  grid-row-gap: 1ch;
}
@media (max-width: 575.98px) {
  .better-moodle_bookmarks__form .fcontainer {
    grid-template-columns: 1fr 2fr;
  }
  .better-moodle_bookmarks__form .fcontainer .btn-group {
    grid-column-start: 1;
    grid-column-end: 3;
  }
}
.better-moodle_bookmarks__form .fcontainer .btn-group[data-index="0"] [data-action=up], .better-moodle_bookmarks__form .fcontainer .btn-group:not(:has(~ .btn-group[data-index])) [data-action=down] {
  pointer-events: none;
  opacity: 0.5;
}
.better-moodle_bookmarks__form.better-moodle_bookmarks__edit-form .fcontainer {
  grid-template-columns: 1fr 2fr;
}/*! Sass Fairy v1 | (c) roydukkey | https://sass-fairy.com/license *//*! Sass Fairy v1 | (c) roydukkey | https://sass-fairy.com/license */
.better-moodle_marquee__marquee {
  --max-width: 0px;
  --text-width: 0;
  --text-speed: 100;
  --parent-left: 0px;
  overflow: hidden;
  position: absolute;
  max-width: calc(var(--max-width));
  width: calc(var(--max-width));
  height: 100%;
  left: calc(var(--parent-left) - var(--max-width));
  --rolling-duration: calc(var(--text-width) * var(--text-speed) * 1ms);
}
.better-moodle_marquee__marquee:not(:has(> span[data-rolling])) {
  justify-content: end;
}
.better-moodle_marquee__marquee:not(:has(> span[data-rolling])) > span > *:last-child::after {
  display: none;
}
.better-moodle_marquee__marquee > span {
  display: inline-block;
  white-space: nowrap;
  will-change: transform;
}
.better-moodle_marquee__marquee > span > *::after {
  content: "           ";
  white-space: pre;
  background-image: url("https://www.fsmain.uni-luebeck.de/fileadmin/gremientemplate/fsmain/ico/favicon.ico");
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
}
.better-moodle_marquee__marquee > span[data-rolling] {
  animation: better-moodle_marquee__marquee var(--rolling-duration) linear infinite;
}
.better-moodle_marquee__marquee > span[data-rolling] + span {
  display: inline-block;
}
.better-moodle_marquee__marquee > span[data-rolling] + span {
  animation: better-moodle_marquee__marquee var(--rolling-duration) linear infinite;
}
.better-moodle_marquee__marquee > span + span {
  display: none;
}
@media (prefers-reduced-motion: reduce) {
  .better-moodle_marquee__marquee > span {
    animation: none;
  }
  .better-moodle_marquee__marquee > span[data-rolling]:hover {
    animation-name: better-moodle_marquee__marquee;
  }
}
@keyframes better-moodle_marquee__marquee {
  0% {
    transform: translateX(0);
  }
  100% {
    transform: translateX(-100%);
  }
}
@media (min-width: 768px) {
  .better-moodle_marquee__marquee {
    max-width: calc(var(--max-width));
    width: calc(var(--max-width));
    left: calc(var(--parent-left) - var(--max-width) + 200px);
  }
  .better-moodle_marquee__marquee-min-width-placeholder:has(+ .better-moodle_marquee__marquee) {
    min-width: 200px;
  }
}
@media (max-width: 767.98px) {
  .better-moodle_marquee__marquee {
    width: 100%;
    max-width: 100%;
    left: 0;
    top: 100%;
    padding-top: 2px;
    height: auto;
    background-color: rgba(255, 255, 255, 0.75);
  }
  .better-moodle_marquee__marquee:not(:has(> span[data-rolling])) {
    justify-content: center !important;
  }
  html[data-darkreader-scheme=dark] .better-moodle_marquee__marquee {
    background-color: rgba(0, 0, 0, 0.75);
  }
}.better-moodle_nina__unseen::before {
  content: "";
  position: absolute;
  left: -8px;
  top: 0;
  bottom: 0;
  border-left: var(--primary) 3px solid;
}

@media (prefers-reduced-motion: no-preference) {
  .better-moodle_nina__spin {
    animation: better-moodle_nina__spin 0.5s linear infinite;
  }
}
@keyframes better-moodle_nina__spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(180deg);
  }
}[data-block=better-moodle-semesterzeiten] {
  --progress-percent: 0;
}
[data-block=better-moodle-semesterzeiten] .card-text.content {
  margin-top: 0 !important;
}
[data-block=better-moodle-semesterzeiten] .card-text.content .better-moodle_semesterzeiten__today-span {
  position: absolute;
  top: 0;
  transform: translateX(-50%) translateY(calc(-1lh + 3px));
  font-size: 0.703125rem;
  margin-left: calc(var(--progress-percent) * (100% - (16px + 0.5rem)) + 16px + 0.5rem);
}
[data-block=better-moodle-semesterzeiten] .card-text.content .better-moodle_semesterzeiten__table-toggle {
  border: 0;
  max-width: 16px;
  margin-right: 0.5rem;
}
[data-block=better-moodle-semesterzeiten] .card-text.content .better-moodle_semesterzeiten__progress-overlay-bar {
  width: calc(var(--progress-percent) * 100%);
  position: absolute;
  height: 100%;
  pointer-events: none;
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.3) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.3) 50%, rgba(255, 255, 255, 0.3) 75%, transparent 75%, transparent);
  border-right: 1px solid currentColor;
}
[data-block=better-moodle-semesterzeiten] .card-text.content .progress-bar[data-toggle=tooltip]:hover {
  filter: brightness(1.5);
}
[data-block=better-moodle-semesterzeiten] .card-text.content .pagination .page-item.disabled {
  cursor: not-allowed;
}/*! Sass Fairy v1 | (c) roydukkey | https://sass-fairy.com/license */
.better-moodle_speiseplan__food-icon {
  display: var(--fa-display, inline-block);
  font-style: normal;
  font-feature-settings: normal;
  font-variant: normal;
  line-height: 1;
  text-rendering: auto;
  font-family: var(--fa-style-family, "Font Awesome 6 Free");
  font-weight: var(--fa-style, 900);
}

.better-moodle_speiseplan__table .dish[data-location]::before {
  content: attr(data-location);
  font-weight: bold;
  font-size: smaller;
  padding: 4px;
  border-radius: 6px;
  margin-right: 0.5em;
}
.better-moodle_speiseplan__table .dish[data-location=Mensa]::before {
  background-color: #6e894a;
  color: white;
}
.better-moodle_speiseplan__table .dish[data-location=Canteen]::before {
  background-color: #6e894a;
  color: white;
}
.better-moodle_speiseplan__table .dish[data-location=Cafeteria]::before {
  background-color: #4b6669;
  color: white;
}
.better-moodle_speiseplan__table .dish .dish-additives {
  font-size: smaller;
}
.better-moodle_speiseplan__table .co2-score[data-stars] {
  text-align: center;
}
.better-moodle_speiseplan__table .co2-score[data-stars]::before {
  display: var(--fa-display, inline-block);
  font-style: normal;
  font-feature-settings: normal;
  font-variant: normal;
  line-height: 1;
  text-rendering: auto;
  font-family: var(--fa-style-family, "Font Awesome 6 Free");
  font-weight: var(--fa-style, 900);
  background-image: linear-gradient(90deg, red 0%, gold 50%, green 100%);
  color: transparent;
  background-clip: text;
  display: block;
}
.better-moodle_speiseplan__table .co2-score[data-stars][data-stars="1"]::before {
  content: "\\f005\\f006\\f006";
}
.better-moodle_speiseplan__table .co2-score[data-stars][data-stars="2"]::before {
  content: "\\f005\\f005\\f006";
}
.better-moodle_speiseplan__table .co2-score[data-stars][data-stars="3"]::before {
  content: "\\f005\\f005\\f005";
}
.better-moodle_speiseplan__table .dish-types {
  text-align: center;
}
.better-moodle_speiseplan__table .dish-types img {
  max-width: 40px;
  max-height: 40px;
}
html[data-darkreader-scheme=dark] .better-moodle_speiseplan__table .dish-types img {
  --stroke-color: color-mix(
      in srgb,
      currentColor 20%,
      transparent
  );
  filter: drop-shadow(0.5px 0 0 var(--stroke-color)) drop-shadow(-0.5px 0 var(--stroke-color)) drop-shadow(0 -0.5px 0 var(--stroke-color)) drop-shadow(0.5px 0.5px 0 var(--stroke-color)) drop-shadow(0.5px -0.5px 0 var(--stroke-color)) drop-shadow(-0.5px 0.5px 0 var(--stroke-color)) drop-shadow(-0.5px -0.5px 0 var(--stroke-color));
}
html[data-darkreader-scheme=dark] .better-moodle_speiseplan__table .dish-types img[src*=sh_teller] {
  filter: brightness(1.5);
}
html[data-darkreader-scheme=dark] .better-moodle_speiseplan__table .dish-types img[src*=iconprop_bio] {
  filter: brightness(0.9);
}
html[data-darkreader-scheme=dark] .better-moodle_speiseplan__table .dish-types img[src*=streetfood] {
  filter: brightness(1);
}
html[data-darkreader-scheme=dark] .better-moodle_speiseplan__table .dish-types img[src*=kuechen-klassiker] {
  filter: invert(1) saturate(1500%) hue-rotate(230deg) saturate(30%) hue-rotate(300deg);
  mix-blend-mode: screen;
}.better-moodle_courses-images-zoom__zoom-enabled #region-main img:not(.activityicon):not(.icon) {
  cursor: zoom-in;
}

#better-moodle_courses-images-zoom__overlay {
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 2000;
  background: rgba(0, 0, 0, 0.75);
  cursor: zoom-out;
  transition: opacity 0.2s ease-in-out;
  will-change: opacity;
  display: flex;
  align-items: center;
  justify-content: center;
}
#better-moodle_courses-images-zoom__overlay > img {
  cursor: zoom-out;
  transform: scale(0);
  transition: transform 0.2s ease-in-out;
  will-change: transform;
  width: unset !important;
  height: unset !important;
}.better-moodle_courses-navbarDropdown__desktop + .dropdown-menu {
  max-width: 500px;
}
.better-moodle_courses-navbarDropdown__desktop + .dropdown-menu a {
  overflow: hidden;
  text-overflow: ellipsis;
}#better-moodle_dashboard-layout__courses_sidebar-filter-menu .list-group-item {
  padding: 0.25rem 1.5rem;
}
#better-moodle_dashboard-layout__courses_sidebar-filter-menu .list-group-item:hover {
  background-color: var(--primary);
  color: white;
}
#better-moodle_dashboard-layout__courses_sidebar-filter-menu .list-group-item.active::before {
  display: var(--fa-display, inline-block);
  font-style: normal;
  font-feature-settings: normal;
  font-variant: normal;
  line-height: 1;
  text-rendering: auto;
  font-family: var(--fa-style-family, "Font Awesome 6 Free");
  font-weight: var(--fa-style, 900);
  content: "\\f00c";
  margin-right: 0.5em;
}#better-moodle_general-googlyEyes__eyes {
  display: flex;
  width: 100%;
  height: 100%;
  justify-content: center;
  align-items: center;
}
#better-moodle_general-googlyEyes__eyes .better-moodle_general-googlyEyes__eye {
  position: relative;
  background-color: white;
  border: 2px solid black;
  border-radius: 43%;
  display: flex;
  width: 40%;
  height: 65%;
  min-width: 40%;
  min-height: 65%;
  max-width: 40%;
  max-height: 65%;
  align-items: center;
  justify-content: center;
}
#better-moodle_general-googlyEyes__eyes .better-moodle_general-googlyEyes__eye:not(:last-child) {
  margin-right: 5%;
}
#better-moodle_general-googlyEyes__eyes .better-moodle_general-googlyEyes__eye .better-moodle_general-googlyEyes__pupil {
  background-color: black;
  border: calc(max(1%, 4px) / 2) solid black;
  border-radius: 50%;
  display: block;
  width: max(1%, 4px);
  height: max(1%, 4px);
  min-width: max(1%, 4px);
  min-height: max(1%, 4px);
  max-width: max(1%, 4px);
  max-height: max(1%, 4px);
}
#better-moodle_general-googlyEyes__eyes .better-moodle_general-googlyEyes__eye::before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  opacity: 0;
  transition: opacity 0.5s linear;
  background: linear-gradient(0deg, rgb(0, 0, 0) 0%, rgb(0, 0, 0) 35%, rgb(255, 255, 255) 49%, rgb(255, 255, 255) 51%, rgb(0, 0, 0) 65%, rgb(0, 0, 0) 100%);
}
body:has(input[type=password]:focus) #better-moodle_general-googlyEyes__eyes .better-moodle_general-googlyEyes__eye::before {
  opacity: 1;
}body:not(.limitedwidth).better-moodle_general-leftSecondaryNav__pulled .secondary-navigation .navigation .nav-tabs {
  justify-content: flex-start;
}img.better-moodle_general-prideLogo__pride-logo {
  filter: brightness(0.8) contrast(1.5);
  object-position: -99999px -99999px;
  mask: var(--pride-logo-mask-image) no-repeat content-box center/contain alpha;
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-rainbow {
  background-image: linear-gradient(180deg, #fe0000 0% 25%, #fd8c00 24% 37%, #ffd000 37% 50%, #119f0b 49% 62%, #457cdf 62% 75%, #c22edc 74% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-agender {
  background-image: linear-gradient(180deg, #000000 0% 23%, #a3aaaf 22% 33%, #f3f3f3 33% 44%, #9ee261 44% 55%, #f3f3f3 54% 65%, #a3aaaf 65% 76%, #000000 76% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-aro {
  background-image: linear-gradient(180deg, #008800 0% 27%, #6dc049 27% 42%, #f3f3f3 42% 57%, #868686 57% 72%, #000000 72% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-ace {
  background-image: linear-gradient(180deg, #000000 0% 31%, #75005f 30% 49%, #f3f3f3 49% 68%, #868686 68% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-aroace {
  background-image: linear-gradient(180deg, #ce6600 0% 27%, #dbb600 27% 42%, #f3f3f3 42% 57%, #3592ca 57% 72%, #000529 72% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-bi {
  background-image: linear-gradient(180deg, #d60270 0% 37%, #9b4f96 37% 62%, #0038a8 62% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-genderfluid {
  background-image: linear-gradient(180deg, #f04e83 0% 27%, #f3f3f3 27% 42%, #ca00c7 42% 57%, #000000 57% 72%, #0007a8 72% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-lesbian {
  background-image: linear-gradient(180deg, #c00000 0% 27%, #f07724 27% 42%, #f3f3f3 42% 57%, #bb3586 57% 72%, #860035 72% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-enby {
  background-image: linear-gradient(180deg, #ece22c 0% 31%, #f3f3f3 30% 49%, #7035b6 49% 68%, #000000 68% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-pan {
  background-image: linear-gradient(180deg, #f3006d 0% 37%, #f0c500 37% 62%, #0097f0 62% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-gay {
  background-image: linear-gradient(180deg, #006642 0% 27%, #6dc79b 27% 42%, #f3f3f3 42% 57%, #5086c2 57% 72%, #0f004b 72% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-trans {
  background-image: linear-gradient(180deg, #00b9ee 0% 27%, #ee86d8 27% 42%, #f3f3f3 42% 57%, #ee86d8 57% 72%, #00b9ee 72% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-180deg.better-moodle_general-prideLogo__flag-intersex {
  background-image: radial-gradient(circle at 50%, #f3c500 12%, #680088 12% 22%, #f3c500 22%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-rainbow {
  background-image: linear-gradient(135deg, #fe0000 0% 32%, #fd8c00 31% 41%, #ffd000 40% 50%, #119f0b 50% 60%, #457cdf 59% 69%, #c22edc 68% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-agender {
  background-image: linear-gradient(135deg, #000000 0% 30%, #a3aaaf 30% 38%, #f3f3f3 38% 46%, #9ee261 46% 54%, #f3f3f3 54% 62%, #a3aaaf 62% 70%, #000000 70% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-aro {
  background-image: linear-gradient(135deg, #008800 0% 34%, #6dc049 33% 45%, #f3f3f3 44% 56%, #868686 55% 67%, #000000 66% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-ace {
  background-image: linear-gradient(135deg, #000000 0% 36%, #75005f 36% 50%, #f3f3f3 50% 64%, #868686 64% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-aroace {
  background-image: linear-gradient(135deg, #ce6600 0% 34%, #dbb600 33% 45%, #f3f3f3 44% 56%, #3592ca 55% 67%, #000529 66% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-bi {
  background-image: linear-gradient(135deg, #d60270 0% 41%, #9b4f96 40% 59%, #0038a8 59% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-genderfluid {
  background-image: linear-gradient(135deg, #f04e83 0% 34%, #f3f3f3 33% 45%, #ca00c7 44% 56%, #000000 55% 67%, #0007a8 66% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-lesbian {
  background-image: linear-gradient(135deg, #c00000 0% 34%, #f07724 33% 45%, #f3f3f3 44% 56%, #bb3586 55% 67%, #860035 66% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-enby {
  background-image: linear-gradient(135deg, #ece22c 0% 36%, #f3f3f3 36% 50%, #7035b6 50% 64%, #000000 64% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-pan {
  background-image: linear-gradient(135deg, #f3006d 0% 41%, #f0c500 40% 59%, #0097f0 59% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-gay {
  background-image: linear-gradient(135deg, #006642 0% 34%, #6dc79b 33% 45%, #f3f3f3 44% 56%, #5086c2 55% 67%, #0f004b 66% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-trans {
  background-image: linear-gradient(135deg, #00b9ee 0% 34%, #ee86d8 33% 45%, #f3f3f3 44% 56%, #ee86d8 55% 67%, #00b9ee 66% 100%);
}
img.better-moodle_general-prideLogo__pride-logo.better-moodle_general-prideLogo__rotation-135deg.better-moodle_general-prideLogo__flag-intersex {
  background-image: radial-gradient(circle at 50%, #f3c500 12%, #680088 12% 22%, #f3c500 22%);
}
html[data-darkreader-scheme=dark] img.better-moodle_general-prideLogo__pride-logo {
  filter: saturate(2) !important;
}.better-moodle_navbarMarquee-eventAdvertisements__event-advertisement {
  cursor: pointer;
} `);

  const keys = Object.keys;
  function isBoolean(val) {
    return 'boolean' === typeof val;
  }
  function isElement(val) {
    return val && 'number' === typeof val.nodeType;
  }
  function isString(val) {
    return 'string' === typeof val;
  }
  function isNumber(val) {
    return 'number' === typeof val;
  }
  function isObject(val) {
    return 'object' === typeof val ? null !== val : isFunction(val);
  }
  function isFunction(val) {
    return 'function' === typeof val;
  }
  function isComponentClass(Component) {
    return !!(Component && Component.isComponent);
  }
  function isArrayLike(obj) {
    return isObject(obj) && 'number' === typeof obj.length && 'number' !== typeof obj.nodeType;
  }
  function forEach(value, fn) {
    if (!value) return;
    for (const key of keys(value)) fn(value[key], key);
  }
  function isRef(maybeRef) {
    return isObject(maybeRef) && 'current' in maybeRef;
  }
  const isUnitlessNumber = {
    animationIterationCount: 0,
    borderImageOutset: 0,
    borderImageSlice: 0,
    borderImageWidth: 0,
    boxFlex: 0,
    boxFlexGroup: 0,
    boxOrdinalGroup: 0,
    columnCount: 0,
    columns: 0,
    flex: 0,
    flexGrow: 0,
    flexPositive: 0,
    flexShrink: 0,
    flexNegative: 0,
    flexOrder: 0,
    gridArea: 0,
    gridRow: 0,
    gridRowEnd: 0,
    gridRowSpan: 0,
    gridRowStart: 0,
    gridColumn: 0,
    gridColumnEnd: 0,
    gridColumnSpan: 0,
    gridColumnStart: 0,
    fontWeight: 0,
    lineClamp: 0,
    lineHeight: 0,
    opacity: 0,
    order: 0,
    orphans: 0,
    tabSize: 0,
    widows: 0,
    zIndex: 0,
    zoom: 0,
    fillOpacity: 0,
    floodOpacity: 0,
    stopOpacity: 0,
    strokeDasharray: 0,
    strokeDashoffset: 0,
    strokeMiterlimit: 0,
    strokeOpacity: 0,
    strokeWidth: 0,
  };
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }
  const prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  keys(isUnitlessNumber).forEach(prop => {
    prefixes.forEach(prefix => {
      isUnitlessNumber[prefixKey(prefix, prop)] = 0;
    });
  });
  const jsxDomType = Symbol.for('jsx-dom:type');
  var JsxDomType = (function (JsxDomType2) {
    JsxDomType2.ShadowRoot = 'ShadowRoot';
    return JsxDomType2;
  })(JsxDomType || {});
  function isShadowRoot(el) {
    return null != el && el[jsxDomType] === JsxDomType.ShadowRoot;
  }
  function isVisibleChild(value) {
    return !isBoolean(value) && null != value;
  }
  function className(value) {
    if (Array.isArray(value)) return value.map(className).filter(Boolean).join(' ');
    else if (isObject(value)) {
      if (Symbol.iterator in value) return className(Array.from(value));
      return keys(value)
        .filter(k => value[k])
        .join(' ');
    } else if (isVisibleChild(value)) return '' + value;
    else return '';
  }
  const svg = {
    animate: 0,
    circle: 0,
    clipPath: 0,
    defs: 0,
    desc: 0,
    ellipse: 0,
    feBlend: 0,
    feColorMatrix: 0,
    feComponentTransfer: 0,
    feComposite: 0,
    feConvolveMatrix: 0,
    feDiffuseLighting: 0,
    feDisplacementMap: 0,
    feDistantLight: 0,
    feFlood: 0,
    feFuncA: 0,
    feFuncB: 0,
    feFuncG: 0,
    feFuncR: 0,
    feGaussianBlur: 0,
    feImage: 0,
    feMerge: 0,
    feMergeNode: 0,
    feMorphology: 0,
    feOffset: 0,
    fePointLight: 0,
    feSpecularLighting: 0,
    feSpotLight: 0,
    feTile: 0,
    feTurbulence: 0,
    filter: 0,
    foreignObject: 0,
    g: 0,
    image: 0,
    line: 0,
    linearGradient: 0,
    marker: 0,
    mask: 0,
    metadata: 0,
    path: 0,
    pattern: 0,
    polygon: 0,
    polyline: 0,
    radialGradient: 0,
    rect: 0,
    stop: 0,
    svg: 0,
    switch: 0,
    symbol: 0,
    text: 0,
    textPath: 0,
    tspan: 0,
    use: 0,
    view: 0,
  };
  const nonPresentationSVGAttributes =
    /^(a(ll|t|u)|base[FP]|c(al|lipPathU|on)|di|ed|ex|filter[RU]|g(lyphR|r)|ke|l(en|im)|ma(rker[HUW]|s)|n|pat|pr|point[^e]|re[^n]|s[puy]|st[^or]|ta|textL|vi|xC|y|z)/;
  function Fragment(attr2) {
    const fragment = document.createDocumentFragment();
    appendChild(attr2.children, fragment);
    return fragment;
  }
  function initComponentClass(Class, attr2, children) {
    const instance = new Class((attr2 = { ...attr2, children }));
    const node = instance.render();
    if ('ref' in attr2) attachRef(attr2.ref, instance);
    return node;
  }
  function jsx(tag, _ref) {
    let { children, ...attr2 } = _ref;
    if (!attr2.namespaceURI && 0 === svg[tag]) attr2 = { ...attr2, namespaceURI: 'http://www.w3.org/2000/svg' };
    let node;
    if (isString(tag)) {
      node = attr2.namespaceURI ? document.createElementNS(attr2.namespaceURI, tag) : document.createElement(tag);
      attributes(attr2, node);
      appendChild(children, node);
      if (node instanceof window.HTMLSelectElement && null != attr2.value) {
        if (true === attr2.multiple && Array.isArray(attr2.value)) {
          const values = attr2.value.map(value => String(value));
          node.querySelectorAll('option').forEach(option => (option.selected = values.includes(option.value)));
        } else node.value = attr2.value;
      }
      attachRef(attr2.ref, node);
    } else if (isFunction(tag)) {
      if (isObject(tag.defaultProps)) attr2 = { ...tag.defaultProps, ...attr2 };
      node = isComponentClass(tag) ? initComponentClass(tag, attr2, children) : tag({ ...attr2, children });
    } else throw new TypeError(`Invalid JSX element type: ${tag}`);
    return node;
  }
  function createElement(tag, attr2) {
    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key2 = 2; _key2 < _len; _key2++) {
      children[_key2 - 2] = arguments[_key2];
    }
    if (isString(attr2) || Array.isArray(attr2)) {
      children.unshift(attr2);
      attr2 = {};
    }
    if (null != (attr2 = attr2 || {}).children && !children.length) ({ children, ...attr2 } = attr2);
    return jsx(tag, { ...attr2, children }, attr2.key);
  }
  function attachRef(ref, node) {
    if (isRef(ref)) ref.current = node;
    else if (isFunction(ref)) ref(node);
  }
  function appendChild(child, node) {
    if (isArrayLike(child)) appendChildren(child, node);
    else if (isString(child) || isNumber(child)) appendChildToNode(document.createTextNode(child), node);
    else if (null === child) appendChildToNode(document.createComment(''), node);
    else if (isElement(child)) appendChildToNode(child, node);
    else if (isShadowRoot(child)) {
      const shadowRoot = node.attachShadow(child.attr);
      appendChild(child.children, shadowRoot);
      attachRef(child.ref, shadowRoot);
    }
  }
  function appendChildren(children, node) {
    for (const child of [...children]) appendChild(child, node);
    return node;
  }
  function appendChildToNode(child, node) {
    if (node instanceof window.HTMLTemplateElement) node.content.appendChild(child);
    else node.appendChild(child);
  }
  function normalizeAttribute(s, separator) {
    return s.replace(/[A-Z]/g, match => separator + match.toLowerCase());
  }
  function style$8(node, value) {
    if (null == value || false === value);
    else if (Array.isArray(value)) value.forEach(v => style$8(node, v));
    else if (isString(value)) node.setAttribute('style', value);
    else if (isObject(value)) {
      forEach(value, (val, key) => {
        if (0 === key.indexOf('-')) node.style.setProperty(key, val);
        else if (isNumber(val) && 0 !== isUnitlessNumber[key]) node.style[key] = val + 'px';
        else node.style[key] = val;
      });
    }
  }
  function attribute(key, value, node) {
    switch (key) {
      case 'xlinkActuate':
      case 'xlinkArcrole':
      case 'xlinkHref':
      case 'xlinkRole':
      case 'xlinkShow':
      case 'xlinkTitle':
      case 'xlinkType':
        attrNS(node, 'http://www.w3.org/1999/xlink', normalizeAttribute(key, ':'), value);
        return;
      case 'xmlnsXlink':
        attr(node, normalizeAttribute(key, ':'), value);
        return;
      case 'xmlBase':
      case 'xmlLang':
      case 'xmlSpace':
        attrNS(node, 'http://www.w3.org/XML/1998/namespace', normalizeAttribute(key, ':'), value);
        return;
    }
    switch (key) {
      case 'htmlFor':
        attr(node, 'for', value);
        return;
      case 'dataset':
        forEach(value, (dataValue, dataKey) => {
          if (null != dataValue) node.dataset[dataKey] = dataValue;
        });
        return;
      case 'innerHTML':
      case 'innerText':
      case 'textContent':
        if (isVisibleChild(value)) node[key] = value;
        return;
      case 'dangerouslySetInnerHTML':
        if (isObject(value)) node.innerHTML = value.__html;
        return;
      case 'value':
        if (null == value || node instanceof window.HTMLSelectElement) return;
        else if (node instanceof window.HTMLTextAreaElement) {
          node.value = value;
          return;
        }
        break;
      case 'spellCheck':
        node.spellcheck = value;
        return;
      case 'class':
      case 'className':
        if (isFunction(value)) value(node);
        else attr(node, 'class', className(value));
        return;
      case 'ref':
      case 'namespaceURI':
        return;
      case 'style':
        style$8(node, value);
        return;
      case 'on':
      case 'onCapture':
        forEach(value, (eventHandler, eventName) => {
          node.addEventListener(eventName, eventHandler, 'onCapture' === key);
        });
        return;
    }
    if (isFunction(value)) {
      if ('o' === key[0] && 'n' === key[1]) {
        let attribute2 = key.toLowerCase();
        const useCapture = attribute2.endsWith('capture');
        if ('ondoubleclick' === attribute2) attribute2 = 'ondblclick';
        else if (useCapture && 'ondoubleclickcapture' === attribute2) attribute2 = 'ondblclickcapture';
        if (!useCapture && null === node[attribute2]) node[attribute2] = value;
        else if (useCapture) node.addEventListener(attribute2.substring(2, attribute2.length - 7), value, true);
        else {
          let eventName;
          if (attribute2 in window) eventName = attribute2.substring(2);
          else eventName = attribute2[2] + key.slice(3);
          node.addEventListener(eventName, value);
        }
      }
    } else if (isObject(value)) node[key] = value;
    else if (true === value) attr(node, key, '');
    else if (false !== value && null != value) {
      if (node instanceof SVGElement && !nonPresentationSVGAttributes.test(key)) {
        attr(node, normalizeAttribute(key, '-'), value);
      } else attr(node, key, value);
    }
  }
  function attr(node, key, value) {
    node.setAttribute(key, value);
  }
  function attrNS(node, namespace, key, value) {
    node.setAttributeNS(namespace, key, value);
  }
  function attributes(attr2, node) {
    for (const key of keys(attr2)) attribute(key, attr2[key], node);
    return node;
  }
  const globalStyle = {
    noExternalLinkIcon: 'better-moodle__no-external-link-icon',
    awaitsDropdown: 'better-moodle__awaits-dropdown',
    navbarItem: 'better-moodle__navbar-item',
    shining: 'better-moodle__shining',
    sparkling: 'better-moodle__sparkling',
  };
  const require2 = (modules, callback) => readyCallback(() => requirejs(modules, callback));
  const requirePromise = modules => new Promise(resolve => require2(modules, (...res) => resolve(res)));
  const ready = () => new Promise(resolve => readyCallback(() => resolve()));
  const readyCallback = callback => {
    if ('loading' !== document.readyState) callback();
    else document.addEventListener('DOMContentLoaded', callback, { once: true });
  };
  let loadingSpinner;
  const getLoadingSpinner = () =>
    loadingSpinner ?
      Promise.resolve(loadingSpinner.cloneNode(true))
    : requirePromise(['core/templates'])
        .then(([templates]) => templates.renderForPromise('core/loading', {}))
        .then(({ html }) => htmlToElements(html).item(0))
        .then(spinner => {
          loadingSpinner = spinner;
          return spinner.cloneNode(true);
        });
  const putTemplate = async (element, template, action, preprocess) => {
    const el = 'string' === typeof element ? document.querySelector(element) : element;
    if (!el) throw new Error(`Element ${element} not found`);
    const templateElements = Array.from(htmlToElements(template.html));
    if (preprocess) preprocess(templateElements);
    el[action](...templateElements);
    const [templates, filterEvents] = await requirePromise(['core/templates', 'core_filters/events']);
    templates.runTemplateJS(template.js);
    filterEvents.notifyFilterContentUpdated(templateElements);
    return templateElements;
  };
  const getDocumentFragmentHtml = fragment => {
    const div = document.createElement('div');
    div.append(fragment.cloneNode(true));
    return div.innerHTML;
  };
  const getHtml = element =>
    element instanceof DocumentFragment ? getDocumentFragmentHtml(element) : element.outerHTML;
  const PREFIX = str => `better-moodle-${str}`;
  const domID = id =>
    PREFIX(id)
      .replace(/ /gu, '_')
      .replace(/["']/gu, '')
      .replace(/[^\w-]/gu, '-');
  const githubPath = path => `https://github.com/jxn-30/better-moodle${path}`;
  const rawGithubPath = path => `https://raw.githubusercontent.com/jxn-30/better-moodle/main/${path}`;
  const mdID = (md, idPrefix = '') =>
    domID(
      (idPrefix ? `${idPrefix}__` : '') +
        Array.from(htmlToElements(mdToHtml(md, 1, idPrefix)))
          .map(el => el.textContent)
          .join('')
    );
  const mdToHtml = (md, headingStart = 1, idPrefix = '', pWrap = true) => {
    let html = '';
    const referenceLinks = new Map();
    const inlineEscape = str =>
      new Option(str).innerHTML
        .replace(/!\[([^\]]*)]\(([^(]+)\)/g, '<img alt="$1" src="$2">')
        .replace(/\[([^\]]+)]\(([^(]+?)\)/g, '<a href="$2">$1</a>')
        .replace(/\[([^\]]+)]\[([^[]+?)]/g, '<a data-link="$2">$1</a>')
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        .replace(/(\*\*|__)(?=\S)([^\r]*?\S[*_]*)\1/g, '<strong>$2</strong>')
        .replace(/([*_])(?=\S)([^\r]*?\S)\1/g, '<em>$2</em>');
    md.trim()
      .replace(/\r/g, '')
      .replace(/\t/g, '    ')
      .replace(/^\[(.+?)]:\s*(.+)$/gm, (_, id, url) => {
        referenceLinks.set(id, url);
        return '';
      })
      .split(/\n\n+/)
      .forEach(mdParagraph => {
        if (/^[-*]\s/m.test(mdParagraph)) {
          html += `<ul><li>${mdParagraph
            .split(/^[-*]\s+/gm)
            .map(l => l.trim())
            .filter(Boolean)
            .map(inlineEscape)
            .join('</li><li>')}</li></ul>`;
        } else if (/^\d+\.?\s/m.test(mdParagraph)) {
          html += `<ol><li>${mdParagraph
            .split(/^\d+\.?\s+/gm)
            .map(l => l.trim())
            .filter(Boolean)
            .map(inlineEscape)
            .join('</li><li>')}</li></ol>`;
        } else if (/^\s{4}/m.test(mdParagraph)) html += `<pre>${mdParagraph.split(/^\s{4}/gm).join('')}</pre>`;
        else if (/^>\s/m.test(mdParagraph)) {
          html += `<blockquote>${mdParagraph.split(/^>\s/gm).map(inlineEscape).join('')}</blockquote>`;
        } else if (/^#{1,6}\s/m.test(mdParagraph)) {
          const level = mdParagraph.indexOf(' ') + headingStart - 1;
          const content = mdParagraph.replace(/^#+/m, '').trim();
          html += `<h${level} id="${mdID(content, idPrefix)}">${inlineEscape(content)}</h${level}>`;
        } else if (mdParagraph.startsWith('<')) html += mdParagraph;
        else if (/^---+|^\*\*\*+/m.test(mdParagraph)) html += '<hr>';
        else if (pWrap) html += `<p>${inlineEscape(mdParagraph)}</p>`;
        else html += inlineEscape(mdParagraph);
      });
    referenceLinks.forEach((url, id) => (html = html.replaceAll(`data-link="${id}"`, `href="${url}"`)));
    return html;
  };
  const htmlToElements = html => new DOMParser().parseFromString(html, 'text/html').body.children;
  const debounce = (fn, delay = 100) => {
    let timeout2;
    return (...args) => {
      if (timeout2) clearTimeout(timeout2);
      timeout2 = setTimeout(() => fn.apply(void 0, args), delay);
    };
  };
  const animate = (delay, callback, runImmediate = false) => {
    if (runImmediate) callback();
    let last = 0;
    const intervalCallback = now => {
      currentId = requestAnimationFrame(intervalCallback);
      const elapsed = now - last;
      if (elapsed >= delay) {
        last = now - (elapsed % delay);
        callback();
      }
    };
    let currentId = requestAnimationFrame(intervalCallback);
    return () => cancelAnimationFrame(currentId);
  };
  const isLoggedIn = () => ready().then(() => (M.cfg.userId ?? 0) > 1);
  const isDashboard = /^\/my\/(index\.php)?$/.test(window.location.pathname);
  const isNewInstallation = 0 === GM_listValues().length;
  const mdlJSComplete = action => {
    const { promise, resolve } = Promise.withResolvers();
    const check = () => {
      if (M.util?.complete_js.flat().includes(action)) return resolve();
      setTimeout(check, 100);
    };
    check();
    return promise;
  };
  const STORAGE_V2_LANGUAGE_KEY = (() => 'settings.general.language')();
  const getAndDelete = (key, defaultValue) => {
    const value = GM_getValue(key, defaultValue);
    GM_deleteValue(key);
    return value;
  };
  (() => {
    const oldStorageVersion = GM_getValue('storageVersion', 0);
    if (2.1 === oldStorageVersion || isNewInstallation) return;
    if (oldStorageVersion < 2.1) {
      const oldSeenSettings = getAndDelete('better-moodle-seen-settings', []);
      if (oldSeenSettings.length) GM_setValue('seenSettings', oldSeenSettings);
      const oldLanguage = getAndDelete('better-moodle-settings.general.language');
      if (oldLanguage) GM_setValue(STORAGE_V2_LANGUAGE_KEY, oldLanguage);
      const oldKeys = [
        'better-moodle-dashboard-sidebar-right-open',
        'better-moodle-ever-opened-settings',
        'better-moodle-myCourses.filterSyncChange',
        'better-moodle-settings.dashboard.~layoutPlaceholder',
        'better-moodle-settings.darkmode.preview',
        ...GM_listValues().filter(key => key.startsWith('better-moodle-weather-display-')),
        'better-moodle-settings.weatherDisplay.pirateWeatherAPIKey',
        'better-moodle-nina.activeWarnings',
        'better-moodle-nina.lastUpdate',
        'better-moodle-settings.nina.enabled',
        'better-moodle-settings.nina.megaAlarm',
        'better-moodle-settings.nina.test',
      ];
      oldKeys.push('better-moodle-settings.courses.collapseAll');
      oldKeys.forEach(key => GM_deleteValue(key));
    }
    GM_setValue('storageVersion', 2.1);
  })();
  function parseRawHeaders(h) {
    const s = h.trim();
    if (!s) return new Headers();
    const array = s.split('\r\n').map(value => {
      let s2 = value.split(':');
      return [s2[0].trim(), s2[1].trim()];
    });
    return new Headers(array);
  }
  function parseGMResponse(req, res) {
    const headers = parseRawHeaders(res.responseHeaders);
    const body =
      'string' === typeof res.response ?
        new Blob([res.response], { type: headers.get('Content-Type') || 'text/plain' })
      : res.response;
    return new ResImpl(body, {
      statusCode: res.status,
      statusText: res.statusText,
      headers,
      finalUrl: res.finalUrl,
      redirected: res.finalUrl === req.url,
    });
  }
  class ResImpl {
    constructor(body, init) {
      this.rawBody = body;
      this.init = init;
      this.body = body.stream();
      const { headers, statusCode, statusText, finalUrl, redirected } = init;
      this.headers = headers;
      this.status = statusCode;
      this.statusText = statusText;
      this.url = finalUrl;
      this.type = 'basic';
      this.redirected = redirected;
      this._bodyUsed = false;
    }
    get bodyUsed() {
      return this._bodyUsed;
    }
    get ok() {
      return this.status < 300;
    }
    arrayBuffer() {
      if (this.bodyUsed) throw new TypeError("Failed to execute 'arrayBuffer' on 'Response': body stream already read");
      this._bodyUsed = true;
      return this.rawBody.arrayBuffer();
    }
    blob() {
      if (this.bodyUsed) throw new TypeError("Failed to execute 'blob' on 'Response': body stream already read");
      this._bodyUsed = true;
      return Promise.resolve(this.rawBody.slice(0, this.rawBody.size, this.rawBody.type));
    }
    clone() {
      if (this.bodyUsed) throw new TypeError("Failed to execute 'clone' on 'Response': body stream already read");
      return new ResImpl(this.rawBody, this.init);
    }
    formData() {
      if (this.bodyUsed) throw new TypeError("Failed to execute 'formData' on 'Response': body stream already read");
      this._bodyUsed = true;
      return this.rawBody.text().then(decode);
    }
    async json() {
      if (this.bodyUsed) throw new TypeError("Failed to execute 'json' on 'Response': body stream already read");
      this._bodyUsed = true;
      return JSON.parse(await this.rawBody.text());
    }
    text() {
      if (this.bodyUsed) throw new TypeError("Failed to execute 'text' on 'Response': body stream already read");
      this._bodyUsed = true;
      return this.rawBody.text();
    }
    async bytes() {
      if (this.bodyUsed) throw new TypeError("Failed to execute 'bytes' on 'Response': body stream already read");
      this._bodyUsed = true;
      return new Uint8Array(await this.rawBody.arrayBuffer());
    }
  }
  function decode(body) {
    const form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function (bytes) {
        if (bytes) {
          const split = bytes.split('=');
          const name = split.shift()?.replace(/\+/g, ' ');
          const value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form;
  }
  async function GM_fetch(input, init) {
    const request2 = new Request(input, init);
    let data;
    if (init?.body) data = await request2.text();
    return await XHR(request2, init, data);
  }
  function XHR(request2, init, data) {
    return new Promise((resolve, reject) => {
      if (request2.signal && request2.signal.aborted) return reject(new DOMException('Aborted', 'AbortError'));
      GM.xmlHttpRequest({
        url: request2.url,
        method: gmXHRMethod(request2.method.toUpperCase()),
        headers: Object.fromEntries(new Headers(init?.headers).entries()),
        data,
        responseType: 'blob',
        onload(res) {
          try {
            resolve(parseGMResponse(request2, res));
          } catch (e) {
            reject(e);
          }
        },
        onabort() {
          reject(new DOMException('Aborted', 'AbortError'));
        },
        ontimeout() {
          reject(new TypeError('Network request failed, timeout'));
        },
        onerror(err) {
          reject(new TypeError('Failed to fetch: ' + err.finalUrl));
        },
      });
    });
  }
  const httpMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'TRACE', 'OPTIONS', 'CONNECT'];
  function includes(array, element) {
    return array.includes(element);
  }
  function gmXHRMethod(method) {
    if (includes(httpMethods, method)) return method;
    throw new Error(`unsupported http method ${method}`);
  }
  var define_USERSCRIPT_CONNECTS_default = [
    'better-moodle.dev',
    'studentenwerk.sh',
    'nina.api.proxy.bund.dev',
    'api.open-meteo.com',
    'api.openweathermap.org',
    'weather.visualcrossing.com',
    'wttr.in',
  ];
  const request = async (url, init) => {
    const urlUrl = new URL(url, window.location.toString());
    const request2 =
      define_USERSCRIPT_CONNECTS_default.some(connect => urlUrl.hostname.includes(connect)) ?
        () => GM_fetch(url, init)
      : () => fetch(url, init);
    return await navigator.locks.request(PREFIX(`request-${url}`), request2);
  };
  const unlockedCachedRequest = (url, cacheDuration, method, preprocess, init) => {
    const cache = GM_getValue('_network_cache') ?? { urls: {}, processed: {} };
    const cacheKey = preprocess ? `${preprocess.length}:${preprocess.toString().length}:${url}` : url;
    const cacheKeyLastUpdate = cache.processed[cacheKey]?.lastUpdate ?? 0;
    const cacheUrlLastUpdate = cache.urls[url]?.lastUpdate ?? 0;
    if (preprocess && cacheKeyLastUpdate + cacheDuration > Date.now()) {
      return Promise.resolve({ cached: true, lastUpdate: cacheKeyLastUpdate, value: cache.processed[cacheKey].value });
    }
    if (cacheUrlLastUpdate + cacheDuration > Date.now()) {
      if (preprocess) {
        const result = preprocess(cache.urls[url].value);
        cache.processed[cacheKey] = {
          lastUpdate: cache.urls[url].lastUpdate,
          expires: cache.urls[url].lastUpdate + cacheDuration,
          value: result,
        };
        GM_setValue('_network_cache', cache);
        return Promise.resolve({ cached: true, lastUpdate: cacheUrlLastUpdate, value: result });
      } else return Promise.resolve({ cached: true, lastUpdate: cacheUrlLastUpdate, value: cache.urls[url].value });
    }
    return request(url, init)
      .then(res => res[method]())
      .then(result => {
        const value = preprocess?.(result) ?? result;
        const lastUpdate = Date.now();
        if (cacheDuration) {
          const expires = lastUpdate + cacheDuration;
          cache.urls[url] = { lastUpdate, expires, value: result };
          if (preprocess) cache.processed[cacheKey] = { lastUpdate, expires, value };
          GM_setValue('_network_cache', cache);
        }
        return { cached: false, lastUpdate, value };
      });
  };
  const cachedRequest = async (url, cacheDuration, method, preprocess, init) =>
    await navigator.locks.request(PREFIX(`cached_request-${url}`), () =>
      unlockedCachedRequest(url, cacheDuration, method, preprocess, init)
    );
  const getDocument = (path, cacheDuration = 0) =>
    cachedRequest(path, cacheDuration, 'text').then(res => ({
      ...res,
      value: new DOMParser().parseFromString(res.value, 'text/html'),
    }));
  const icsUrl = category => `https://ics.better-moodle.dev/${category}/uzl`;
  const networkCache = GM_getValue('_network_cache', { urls: {}, processed: {} });
  Object.entries(networkCache.urls).forEach(([url, { expires }]) => {
    if (expires < Date.now()) delete networkCache.urls[url];
  });
  Object.entries(networkCache.processed).forEach(([url, { expires }]) => {
    if (expires < Date.now()) delete networkCache.processed[url];
  });
  GM_setValue('_network_cache', networkCache);
  class CanBeReady {
    #instanceIsReady = false;
    #instanceReadyCallbacks = [];
    callWhenReady(callback) {
      if (this.#instanceIsReady) return Promise.resolve(callback.call(this));
      else return new Promise(resolve => this.#instanceReadyCallbacks.push(() => resolve(callback.call(this))));
    }
    get instanceIsReady() {
      return this.#instanceIsReady;
    }
    instanceReady() {
      if (this.#instanceIsReady) return;
      this.#instanceIsReady = true;
      this.#instanceReadyCallbacks.forEach(callback => callback());
    }
    awaitReady() {
      return this.callWhenReady(() => this);
    }
  }
  class SimpleReady extends CanBeReady {
    ready() {
      this.instanceReady();
    }
  }
  const dateToString = (date = new Date(), year = true, weekday = false, lang = BETTER_MOODLE_LANG) =>
    date.toLocaleDateString(lang, {
      weekday: weekday ? 'long' : void 0,
      year: year ? 'numeric' : void 0,
      month: '2-digit',
      day: '2-digit',
    });
  const timeToString = (date, seconds2 = true, lang = BETTER_MOODLE_LANG) =>
    date.toLocaleTimeString(lang, { hour: '2-digit', minute: '2-digit', second: seconds2 ? '2-digit' : void 0 });
  const datetimeToString = (date, year = true, weekday = true, seconds2 = false, lang = BETTER_MOODLE_LANG) =>
    date.toLocaleString(lang, {
      weekday: weekday ? 'long' : void 0,
      year: year ? 'numeric' : void 0,
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: seconds2 ? '2-digit' : void 0,
    });
  const numToString = (num, options = {}, lang = BETTER_MOODLE_LANG) => num.toLocaleString(lang, options);
  const unit = (num, unit2, format = 'short', lang = BETTER_MOODLE_LANG) =>
    num.toLocaleString(lang, { style: 'unit', unit: unit2, unitDisplay: format });
  const currency = (num, currency2 = 'EUR', format = 'symbol', lang = BETTER_MOODLE_LANG) =>
    num.toLocaleString(lang, { style: 'currency', currency: currency2, currencyDisplay: format });
  const percent = (num, digits = 2, lang = BETTER_MOODLE_LANG) =>
    num.toLocaleString(lang, { style: 'percent', maximumFractionDigits: digits });
  const capitalize = (str, lang = BETTER_MOODLE_LANG) => str.replace(/(?<=^|\s)\S/g, $1 => $1.toLocaleUpperCase(lang));
  const initFormatters = locale => {
    const LL2 = () => LLMap.get(locale);
    const numberTranslations = () => LL2().numbers;
    return {
      capitalize: str => capitalize(str.toString(), locale),
      removeTrailingS: str => str.toString().replace(/s$/, ''),
      spell: num => {
        const numI18n = numberTranslations();
        const key = num.toString();
        return key in numI18n ? numI18n[key]() : key;
      },
      plus1: num => num + 1,
      mod12Or12: num => num % 12 || 12,
    };
  };
  const removeEmptyValues = object =>
    Object.fromEntries(
      Object.entries(object)
        .map(([key, value]) => 'i' !== key && value && '0' != value && [key, value])
        .filter(Boolean)
    );
  const trimAllValues = part =>
    Object.fromEntries(
      Object.keys(part).map(key => {
        const val = part[key];
        return [
          key,
          Array.isArray(val) ? val.map(v => (null === v || void 0 === v ? void 0 : v.trim()))
          : val === !!val ? val
          : null === val || void 0 === val ? void 0
          : val.trim(),
        ];
      })
    );
  const parseArgumentPart = text => {
    const [keyPart = '', ...formatterKeys] = text.split('|');
    const [keyWithoutType = '', type] = keyPart.split(':');
    const [key, isOptional] = keyWithoutType.split('?');
    return { k: key, i: type, n: '' === isOptional, f: formatterKeys };
  };
  const isBasicPluralPart = part => !!(part.o || part.r);
  const parsePluralPart = (content, lastAccessor) => {
    let [key, values] = content.split(':');
    if (!values) {
      values = key;
      key = lastAccessor;
    }
    const entries = values.split('|');
    const [zero, one, two, few, many, rest] = entries;
    const nrOfEntries = entries.filter(entry => void 0 !== entry).length;
    if (1 === nrOfEntries) return { k: key, r: zero };
    if (2 === nrOfEntries) return { k: key, o: zero, r: one };
    if (3 === nrOfEntries) return { k: key, z: zero, o: one, r: two };
    return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };
  };
  const REGEX_SWITCH_CASE = /^\{.*\}$/;
  const parseCases = text =>
    Object.fromEntries(
      removeOuterBrackets(text)
        .split(',')
        .map(part => part.split(':'))
        .reduce((accumulator, entry) => {
          if (2 === entry.length) return [...accumulator, entry.map(entry2 => entry2.trim())];
          accumulator[accumulator.length - 1][1] += ',' + entry[0];
          return accumulator;
        }, [])
    );
  const REGEX_BRACKETS_SPLIT = /(\{(?:[^{}]+|\{(?:[^{}]+)*\})*\})/g;
  const removeOuterBrackets = text => text.substring(1, text.length - 1);
  const parseRawText = (rawText, optimize = true, firstKey = '', lastKey = '') =>
    rawText
      .split(REGEX_BRACKETS_SPLIT)
      .map(part => {
        if (!part.match(REGEX_BRACKETS_SPLIT)) return part;
        const content = removeOuterBrackets(part);
        if (content.startsWith('{')) return parsePluralPart(removeOuterBrackets(content), lastKey);
        const parsedPart = parseArgumentPart(content);
        lastKey = parsedPart.k || lastKey;
        !firstKey && (firstKey = lastKey);
        return parsedPart;
      })
      .map(part => {
        if ('string' === typeof part) return part;
        if (!part.k) part.k = firstKey || '0';
        const trimmed = trimAllValues(part);
        return optimize ? removeEmptyValues(trimmed) : trimmed;
      });
  const applyFormatters = (formatters, formatterKeys, initialValue) =>
    formatterKeys.reduce((value, formatterKey) => {
      var _a, _b;
      return (
          null !==
            (_b =
              formatterKey.match(REGEX_SWITCH_CASE) ?
                (cases => {
                  var _a2;
                  return null !== (_a2 = cases[value]) && void 0 !== _a2 ? _a2 : cases['*'];
                })(parseCases(formatterKey))
              : null === (_a = formatters[formatterKey]) || void 0 === _a ? void 0
              : _a.call(formatters, value)) && void 0 !== _b
        ) ?
          _b
        : value;
    }, initialValue);
  const getPlural = (pluralRules, { z, o, t, f, m, r }, value) => {
    switch (z && 0 == value ? 'zero' : pluralRules.select(value)) {
      case 'zero':
        return z;
      case 'one':
        return o;
      case 'two':
        return t;
      case 'few':
        return null !== f && void 0 !== f ? f : r;
      case 'many':
        return null !== m && void 0 !== m ? m : r;
      default:
        return r;
    }
  };
  const REGEX_PLURAL_VALUE_INJECTION = /\?\?/g;
  const applyArguments = (textParts, pluralRules, formatters, args) =>
    textParts
      .map(part => {
        if ('string' === typeof part) return part;
        const { k: key = '0', f: formatterKeys = [] } = part;
        const value = args[key];
        if (isBasicPluralPart(part)) {
          return (
            ('boolean' === typeof value ?
              value ? part.o
              : part.r
            : getPlural(pluralRules, part, value)) || ''
          ).replace(REGEX_PLURAL_VALUE_INJECTION, value);
        }
        const formattedValue = formatterKeys.length ? applyFormatters(formatters, formatterKeys, value) : value;
        return ('' + (null !== formattedValue && void 0 !== formattedValue ? formattedValue : '')).trim();
      })
      .join('');
  const translate = (textParts, pluralRules, formatters, args) => {
    const firstArg = args[0];
    const isObject2 = firstArg && 'object' === typeof firstArg && firstArg.constructor === Object;
    const transformedArgs = 1 === args.length && isObject2 ? firstArg : args;
    return applyArguments(textParts, pluralRules, formatters, transformedArgs);
  };
  const getPartsFromString = (cache, text) => cache[text] || (cache[text] = parseRawText(text));
  const getTranslateInstance = (locale, formatters) => {
    const cache = {};
    const pluralRules = new Intl.PluralRules(locale);
    return (text, ...args) => translate(getPartsFromString(cache, text), pluralRules, formatters, args);
  };
  function i18nObject$1(locale, translations, formatters = {}) {
    return createProxy(translations, getTranslateInstance(locale, formatters));
  }
  const wrap = (proxyObject = {}, translateFn) =>
    'string' === typeof proxyObject ?
      translateFn.bind(null, proxyObject)
    : Object.assign(
        Object.defineProperty(() => '', 'name', { writable: true }),
        proxyObject
      );
  const createProxy = (proxyObject, translateFn) =>
    new Proxy(wrap(proxyObject, translateFn), {
      get: (target, key) => {
        if (key === Symbol.iterator) {
          return [][Symbol.iterator].bind(Object.values(target).map(entry => wrap(entry, translateFn)));
        }
        return createProxy(target[key], translateFn);
      },
    });
  const locales = ['de', 'en-gb'];
  const loadedLocales = {};
  const loadedFormatters = {};
  const i18nObject = locale => i18nObject$1(locale, loadedLocales[locale], loadedFormatters[locale]);
  const cardsPerRow = {
    de: {
      settings: {
        amount: {
          name: 'Kacheln pro Zeile ("Meine Kurse"-Seite)',
          description:
            'Zahl der Kacheln pro Zeile auf der "Meine Kurse"-Seite, wenn die Ansicht auf "Kacheln" gestellt ist. (Ist bis zu einer Fenster-/Bildschirmbreite bis 840px aktiv)',
        },
      },
    },
    en: {
      settings: {
        amount: {
          name: 'Tiles per row ("My Courses" page)',
          description:
            'Number of tiles per row on the "My Courses" page when the view is set to "Tiles". (Is active up to a window/screen width of 840px)',
        },
      },
    },
  };
  const cauNavbar = { de: void 0, en: void 0 };
  const grades = {
    de: {
      grades: 'Bewertungen',
      settings: {
        enabled: {
          name: 'Link zu Bewertungen in der Sidebar',
          description: 'Zeigt einen Link zu den Bewertungen des Kurses in der linken Seitenleiste an.',
        },
        newTab: {
          name: 'Bewertungen in neuem Tab öffnen',
          description: 'Öffnet die Bewertungen standardmäßig einem neuen Tab.',
        },
      },
    },
    en: {
      grades: 'Grades',
      settings: {
        enabled: {
          name: 'Link to grades in the sidebar',
          description: "Displays a link to the course's grades in the left sidebar.",
        },
        newTab: { name: 'Open grades in new tab', description: 'Opens the grades in a new tab by default.' },
      },
    },
  };
  const hideSelfEnrolHint = {
    de: {
      settings: {
        hide: {
          name: 'Hinweis zur Selbsteinschreibung ohne Einschreibeschlüssel ausblenden',
          description:
            'Moodle zeigt einen Hinweis an, wenn bei einem Kurs die Selbsteinschreibung ohne Einschreibeschlüssel aktiviert ist. Manche empfinden diesen Hinweis als störend, deshalb kann er mit dieser Einstellung ausgeblendet werden.',
        },
      },
    },
    en: {
      settings: {
        hide: {
          name: 'Hide hint for self-enrolment without enrolment key',
          description:
            'Moodle displays a hint when self-enrolment without an enrolment key is enabled for a course. Some people find this hint annoying, so it can be hidden with this setting.',
        },
      },
    },
  };
  const images = {
    de: {
      settings: {
        maxWidth: {
          name: 'Bildüberlauf verhindern',
          description:
            'Verhindert, dass Bilder in den Kursen mehr als die komplette Breite einnehmen und damit ein horizontales Scrollen der Seite verursachen.',
        },
        zoom: {
          name: 'Bilder zoomen',
          description:
            'Zoomt ein Bild heran, wenn es angeklickt wird. So lassen sich kleine Bilder einfach per Knopfdruck vergrößert anzeigen.',
        },
      },
    },
    en: {
      settings: {
        maxWidth: {
          name: 'Prevent image overflow',
          description:
            'Prevents images in courses from taking up more than the full width, causing the page to scroll horizontally.',
        },
        zoom: {
          name: 'Zoom images',
          description:
            'Zooms in on an image when it is clicked. This allows small images to be enlarged at the touch of a button.',
        },
      },
    },
  };
  const navbarDropdown = {
    de: {
      settings: {
        enabled: {
          name: 'Dropdown in der Navigationsleiste',
          description:
            'Funktioniert den "Meine Kurse"-Link in eine Dropdown um, um einen schnellen Direktzugriff auf alle eigenen Kurse zu ermöglichen.',
        },
        filter: {
          name: 'Filter der Kurs-Dropdown',
          description:
            'Welche Kurse sollen in der Dropdown angezeigt werden? Es stehen die Filter der "Meine Kurse"-Seite zur Verfügung.',
          options: { _sync: '[Mit Auswahl auf "Meine Kurse"-Seite synchronisieren]' },
        },
        favouriteCoursesAtTop: {
          name: 'Favoriten oben in der Kurs-Dropdown',
          description:
            'Favorisierte Kurse werden immer oben in der Kurs-Dropdown angezeigt, anstelle an der normalen Stelle bei alphabetischer Sortierung.',
        },
      },
    },
    en: {
      settings: {
        enabled: {
          name: 'Dropdown in the navigation bar',
          description:
            'Converts the "My courses" link into a dropdown to allow quick direct access to all your courses.',
        },
        filter: {
          name: 'Filter the course dropdown',
          description:
            'Which courses should be displayed in the dropdown? The filters on the "My courses" page are available.',
          options: { _sync: '[sync with filter on "my courses" page]' },
        },
        favouriteCoursesAtTop: {
          name: 'Show favourite courses at top',
          description:
            'Favourite courses are always displayed at the top of the course dropdown instead of in the normal position when sorted alphabetically.',
        },
      },
    },
  };
  const noDownload = {
    de: {
      settings: {
        enabled: {
          name: 'Download verhindern',
          description:
            'Versucht den automatischen Download von Dateien so oft wie möglich zu verhindern (klappt nicht immer).',
        },
      },
    },
    en: {
      settings: {
        enabled: {
          name: 'Prevent download',
          description: "Tries to prevent the automatic download of files as often as possible (doesn't always work).",
        },
      },
    },
  };
  const quickRoleChange = {
    de: {
      settings: {
        enabled: {
          name: 'Schneller Rollenwechsel',
          description:
            'Ermöglicht es (mit den passenden Berechtigungen), die Betrachtung eines Kurses mit einer anderen Rolle direkt über das Profil-Dropdown zu ändern.',
        },
      },
    },
    en: {
      settings: {
        enabled: {
          name: 'Quick role change',
          description:
            'Allows (with the appropriate permissions) to change the view of a course with a different role directly via the profile dropdown.',
        },
      },
    },
  };
  const sectionCourseIndex = {
    de: {
      settings: {
        enabled: {
          name: 'Abschnitte auf der Kurs-Hauptseite öffnen',
          description:
            'Manipuliert die Links zu den Abschnitten in der linken Seitenleiste, sodass innerhalb der Kurs-Hauptseite gescrollt wird, statt die Abschnitts-Seite zu öffnen.',
        },
      },
    },
    en: {
      settings: {
        enabled: {
          name: 'Open sections on main course page',
          description:
            'Manipulates the links to the sections in the left sidebar so that it scrolls within the main course page instead of opening the section page.',
        },
      },
    },
  };
  const de$n = {
    name: 'Kurse & Meine Kurse',
    description: 'Hier findest du diverse Einstellungen, die die Moodle-Kurse und die "Meine Kurse"-Seite betrifft.',
    features: {
      navbarDropdown: navbarDropdown.de,
      cardsPerRow: cardsPerRow.de,
      grades: grades.de,
      courseIndexDrawerControls: cauNavbar.de,
      images: images.de,
      quickRoleChange: quickRoleChange.de,
      noDownload: noDownload.de,
      hideSelfEnrolHint: hideSelfEnrolHint.de,
      sectionCourseIndex: sectionCourseIndex.de,
    },
  };
  const en$m = {
    name: 'Courses & My Courses',
    description: 'You can find diverse settings regarding the moodle courses and the "My courses" page.',
    features: {
      navbarDropdown: navbarDropdown.en,
      cardsPerRow: cardsPerRow.en,
      grades: grades.en,
      courseIndexDrawerControls: cauNavbar.en,
      images: images.en,
      quickRoleChange: quickRoleChange.en,
      noDownload: noDownload.en,
      hideSelfEnrolHint: hideSelfEnrolHint.en,
      sectionCourseIndex: sectionCourseIndex.en,
    },
  };
  const layout = {
    de: {
      settings: {
        coursesSidebar: {
          name: 'Linke Seitenleiste: Kursliste',
          description:
            'Aktiviert eine linke Seitenleiste im Dashboard, in der eine filterbare Liste der eigenen Kurse angezeigt wird.',
        },
        favouriteCoursesAtTop: {
          name: 'Favoriten oben in der Kursliste',
          description:
            'Favorisierte Kurse werden immer oben in der Kursliste angezeigt, anstelle an der normalen Stelle bei alphabetischer Sortierung.',
        },
        timelineSidebar: {
          name: 'Rechte Seitenleiste: Zeitleiste und aktuelle Termine',
          description:
            'Aktiviert eine rechte Seitenleiste im Dashboard. Die Zeitleiste und aktuelle Termine werden nun in dieser statt in der Mitte angezeigt.',
        },
      },
      myCourses: {
        title: 'Meine Kurse',
        sync: 'Mit Auswahl auf "Meine Kurse"-Seite synchronisieren',
        empty: 'Keine Kurse im aktuellen Filter vorhanden.',
      },
    },
    en: {
      settings: {
        coursesSidebar: {
          name: 'Left sidebar',
          description: 'Enables a left sidebar in dashboard, showing a filterable list of your courses.',
        },
        favouriteCoursesAtTop: {
          name: 'Show favourite courses at top',
          description:
            'Favourite courses are always displayed at the top of the course list instead of in the normal position when sorted alphabetically.',
        },
        timelineSidebar: {
          name: 'Right sidebar: Timeline and upcoming events',
          description:
            'Enables a right sidebar in dashboard. Timeline and upcoming events are moved into this sidebar.',
        },
      },
      myCourses: {
        title: 'My Courses',
        sync: 'Sync with current filter on "My courses"-Page',
        empty: 'There are no courses matching the currently selected filter.',
      },
    },
  };
  const de$k = {
    name: 'Dashboard',
    description:
      'Mit diesen Einstellungen kannst du dir das Aussehen des Dashboards ein kleines bisschen individualisieren.',
    features: { layout: layout.de },
  };
  const en$j = {
    name: 'Dashboard',
    description: 'These settings allow you to customise the dashboard a little.',
    features: { layout: layout.en },
  };
  const externalLinks = {
    de: {
      settings: {
        enabled: {
          name: 'Externe Links',
          description: 'Sorgt dafür, dass externe Links immer automatisch in einem neuen Tab geöffnet werden.',
        },
      },
    },
    en: {
      settings: {
        enabled: {
          name: 'External links',
          description: 'Ensures that external links are always automatically opened in a new tab.',
        },
      },
    },
  };
  const fullWidth = {
    de: {
      settings: {
        enabled: {
          name: 'Volle Breite',
          description: 'Entfernt den seltsamen weißen Rand und sorgt dafür, dass die Seiten die volle Breite nutzen.',
        },
      },
    },
    en: {
      settings: {
        enabled: {
          name: 'Full Width',
          description: 'Removes the weird white border and makes pages use the full width.',
        },
      },
    },
  };
  const googlyEyes = {
    de: { settings: { enabled: { name: 'xEyes für Better-Moodle', description: '👀' } } },
    en: { settings: { enabled: { name: 'xEyes for Better-Moodle', description: '👀' } } },
  };
  const leftSecondaryNav = {
    de: {
      settings: {
        enabled: {
          name: 'Sekundäre Navigation nach links',
          description:
            'Sorgt dafür, dass die sekundäre Navigation (z. B. unter dem Kurs-Namen) nach links geschoben statt zentriert ist.',
        },
      },
    },
    en: {
      settings: {
        enabled: {
          name: 'Pull secondary navigation to the left',
          description:
            'Pulls the secondary navigation (e.g. below the course name) to the left instead of it being centered',
        },
      },
    },
  };
  const prideLogo$1 = {
    de: {
      settings: {
        flag: {
          name: 'Pride-Logo 🏳️‍🌈',
          description: 'Lässt das Logo im Moodle in einem neuen Farbglanz erscheinen.',
          options: {
            off: 'Aus',
            Rainbow: 'Regenbogen',
            Agender: 'Agender',
            Aro: 'Aromantisch',
            Ace: 'Asexuell',
            Aroace: 'Asexuell-Aromantisch',
            Bi: 'Bisexuell',
            Genderfluid: 'Genderfluid',
            Intersex: 'Intersex',
            Lesbian: 'Lesbisch',
            Enby: 'Nicht-binär',
            Pan: 'Pansexuell',
            Gay: 'Schwul',
            Trans: 'Transgender',
          },
        },
        rotation: {
          name: 'Rotation des Pride-Logos',
          description: 'Wähle hier, in welche Richtung das Pride-Logo rotiert sein soll.',
          options: { '180Deg': '180°: Von Oben nach Unten', '135Deg': '135°: Von Nord-Nord-West nach Süd-Süd-Ost' },
        },
      },
    },
    en: {
      settings: {
        flag: {
          name: 'Pride-Logo 🏳️‍🌈',
          description: 'Makes the logo in Moodle appear in a new colour gloss.',
          options: {
            off: 'Off :(',
            Rainbow: 'Rainbow',
            Agender: 'Agender',
            Aro: 'Aromantic',
            Ace: 'Asexual',
            Aroace: 'Asexual-Aromantic',
            Bi: 'Bisexual',
            Genderfluid: 'Genderfluid',
            Intersex: 'Intersex',
            Lesbian: 'Lesbian (WLW/NBLW)',
            Enby: 'Non-binary',
            Pan: 'Pansexual',
            Gay: 'Gay (MLM/NBLM)',
            Trans: 'Transgender',
          },
        },
        rotation: {
          name: 'Rotation of the Pride-Logo',
          description: 'Select here in which direction the Pride logo should be rotated',
          options: {
            '180Deg': '180°: From top to bottom',
            '135Deg': '135°: From North-North-West to South-South-East',
          },
        },
      },
    },
  };
  const truncatedTexts = {
    de: {
      settings: {
        enabled: {
          name: 'Abgeschnittene Texte',
          description:
            'Fügt ein Title-Attribut bei potentiell abgeschnittenen Texten hinzu, damit man per Maus-Hover den vollen Text lesen kann.',
        },
      },
    },
    en: {
      settings: {
        enabled: {
          name: 'Truncated texts',
          description:
            'Adds a title attribute to potentially truncated texts so that you can read the full text via mouse hover.',
        },
      },
    },
  };
  const de$d = {
    name: 'Allgemeine Einstellungen',
    description:
      'Diese allgemeinen Einstellungen steuern das Verhalten von Better-Moodle und einige grundlegende Features.',
    settings: {
      'updateNotification': {
        name: 'Benachrichtigung bei Better-Moodle Updates',
        description:
          'Zeigt einen kleinen roten Punkt bei den Zahnrädern in der Navigationsleiste an, wenn es ein Update für Better-Moodle gibt.',
      },
      'language': {
        name: 'Better-Moodle Sprache',
        description: 'Wähle die Sprache von Better-Moodle aus.',
        options: { auto: '🌐 Auto (Moodle Sprache)' },
      },
      'hideDisabledSettings': {
        name: 'Deaktivierte Einstellungen ausblenden',
        description:
          'Blendet Einstellungen aus, die gerade deaktiviert sind (z. B. weil sie von einer anderen Einstellung abhängig sind).',
      },
      'hideFunSettings': {
        name: 'Spaß-Einstellungen ausblenden',
        description: 'Blendet Einstellungen aus, die nur für mehr Spaß im Moodle da sind.',
      },
      'newSettings.highlight': {
        name: 'Neue Einstellungen markieren',
        description: 'Hebt neue Einstellungen mit einem kleinen Badge hervor, wenn sie noch nicht angeschaut wurden.',
      },
      'newSettings.tooltip': {
        name: 'Hinweis zu neuen Einstellungen in der Navigationsleiste',
        description:
          'Zeigt ein schickes Tooltip beim Einstellungen-Knopf in der Navigationsleiste an, wenn es ungesehene Einstellungen gibt.',
      },
    },
    features: {
      fullWidth: fullWidth.de,
      externalLinks: externalLinks.de,
      truncatedTexts: truncatedTexts.de,
      googlyEyes: googlyEyes.de,
      leftSecondaryNav: leftSecondaryNav.de,
      prideLogo: prideLogo$1.de,
      cauNavbar: cauNavbar.de,
    },
  };
  const en$c = {
    name: 'General Settings',
    description: 'These general settings control the behaviour of Better-Moodle and some more general Features.',
    settings: {
      'updateNotification': {
        name: 'Notification for Better-Moodle updates',
        description:
          'Displays a small red dot by the cogs in the navigation bar when there is an update for Better-Moodle.',
      },
      'language': {
        name: 'Better-Moodle Language',
        description: 'Choose the language of Better-Moodle.',
        options: { auto: '🌐 Auto (Moodle language)' },
      },
      'hideDisabledSettings': {
        name: 'Hide disabled settings',
        description: 'Hides settings that are currently disabled (e.g. because they depend on another setting).',
      },
      'hideFunSettings': {
        name: 'Hide fun settings',
        description: 'Hides settings that are just for more fun in Moodle.',
      },
      'newSettings.highlight': {
        name: 'Highlight new settings',
        description: 'Highlights new settings with a small badge if they have not yet been viewed.',
      },
      'newSettings.tooltip': {
        name: 'Note on new settings in the navigation bar',
        description:
          'Shows a fancy tooltip next to the settings button in the navigation bar if there are unseen settings.',
      },
    },
    features: {
      fullWidth: fullWidth.en,
      externalLinks: externalLinks.en,
      truncatedTexts: truncatedTexts.en,
      googlyEyes: googlyEyes.en,
      leftSecondaryNav: leftSecondaryNav.en,
      prideLogo: prideLogo$1.en,
      cauNavbar: cauNavbar.en,
    },
  };
  const markdownSupport = {
    de: {
      settings: {
        markdownSupport: {
          name: 'Markdown in Mitteilungen',
          description: 'Erlaubt die Verwendung von Markdown in Mitteilungen.',
        },
      },
    },
    en: {
      settings: {
        markdownSupport: { name: 'Markdown in messages', description: 'Allows the use of Markdown in messages.' },
      },
    },
  };
  const sendHotkey = {
    de: {
      settings: {
        sendHotkey: {
          name: 'Mitteilungen per Tastenkombination absenden',
          description: 'Ermöglicht das Absenden von Mitteilungen per Tastenkombination (z. B. Strg + Enter).',
          options: {
            '': '[Deaktiviert] Kein Absenden per Tastenkombination',
            'shiftEnter': 'Umschalt + Enter',
            'ctrlEnter': 'Strg + Enter',
          },
        },
      },
    },
    en: {
      settings: {
        sendHotkey: {
          name: 'Send messages by hotkey',
          description: 'Allows messages to be sent using a key combination (e.g. Ctrl + Enter).',
          options: {
            '': '[Disabled] Do not send by hotkey',
            'shiftEnter': 'Shift + Enter',
            'ctrlEnter': 'Ctrl + Enter',
          },
        },
      },
    },
  };
  const de$9 = { name: 'Mitteilungen', features: { markdownSupport: markdownSupport.de, sendHotkey: sendHotkey.de } };
  const en$8 = { name: 'Messages', features: { markdownSupport: markdownSupport.en, sendHotkey: sendHotkey.en } };
  const christmasCountdown = {
    de: {
      settings: {
        enabled: {
          name: 'Countdown bis Heiligabend 🎄',
          description:
            'Zeigt einen Countdown bis Heiligabend in der Navigationsleiste an.\nHierbei handelt es sich um eine kleine Hommage an den Mathe-Vorkurs.',
        },
      },
      remaining: 'Noch **{days}** Tag{{e}} bis Heiligabend.',
      christmas: '🎄 Heute ist Heiligabend. Frohe Weihnachten! 🎄',
    },
    en: {
      settings: {
        enabled: {
          name: 'Countdown to Christmas Eve 🎄',
          description:
            'Displays a countdown to Christmas Eve in the navigation bar.\nThis is a small homage to the math pre-course.',
        },
      },
      remaining: "It's **{days}** day{{s}} until Christmas Eve.",
      christmas: '🎄 Today is Christmas Eve. Merry Christmas! 🎄',
    },
  };
  const clock = {
    de: {
      settings: {
        enabled: { name: 'Uhr', description: 'Eine ganz normale Digitaluhr' },
        seconds: { name: 'Sekunden anzeigen', description: 'Sollen die Sekunden in der Digitaluhr angezeigt werden?' },
        fuzzy: {
          name: 'Umgangssprachliche Uhr',
          description: 'Eine umgangssprachliche Uhr, wie sie auch von KDE Plasma bekannt ist.',
          labels: {
            'off': 'Aus',
            '5min': '5 Minuten',
            '15min': '15 Minuten',
            'food': 'Essen',
            'day': 'Tageszeit',
            'week': 'Wochenabschnitt',
          },
        },
      },
      fuzzy: {
        minutes: {
          0: '{hour:number|spell|capitalize|removeTrailingS} Uhr',
          5: 'Fünf nach {hour:number|spell|capitalize}',
          10: 'Zehn nach {hour:number|spell|capitalize}',
          15: 'Viertel nach {hour:number|spell|capitalize}',
          20: 'Zwanzig nach {hour:number|spell|capitalize}',
          25: 'Fünf vor halb {hour:number|plus1|mod12Or12|spell|capitalize}',
          30: 'Halb {hour:number|plus1|mod12Or12|spell|capitalize}',
          35: 'Fünf nach halb {hour:number|plus1|mod12Or12|spell|capitalize}',
          40: 'Zwanzig vor {hour:number|plus1|mod12Or12|spell|capitalize}',
          45: 'Dreiviertel {hour:number|plus1|mod12Or12|spell|capitalize}',
          50: 'Zehn vor {hour:number|plus1|mod12Or12|spell|capitalize}',
          55: 'Fünf vor {hour:number|plus1|mod12Or12|spell|capitalize}',
          60: '{hour:number|plus1|mod12Or12|spell|capitalize|removeTrailingS} Uhr',
        },
        food: {
          0: 'Schlafenszeit',
          1: 'Frühstück',
          2: 'Zweites Frühstück',
          3: 'Kaffeepause',
          4: 'Mittagspause',
          5: 'Nachmittagstee',
          6: 'Abendessen',
          7: 'Mitternachtssnack',
        },
        day: {
          0: 'Nacht',
          1: 'Früher Morgen',
          2: 'Morgen',
          3: 'Vormittag',
          4: 'Mittag',
          5: 'Nachmittag',
          6: 'Abend',
          7: 'Später Abend',
        },
        week: { 0: 'Wochenanfang', 1: 'Mitte der Woche', 2: 'Ende der Woche', 3: 'Wochenende!' },
      },
    },
    en: {
      settings: {
        enabled: { name: 'Clock', description: 'A completely normal digital clock' },
        seconds: { name: 'Show seconds', description: 'Should the seconds be displayed in the digital clock?' },
        fuzzy: {
          name: 'Fuzzy Clock',
          description: 'A fuzzy clock, known from KDE Plasma.',
          labels: {
            'off': 'Off',
            '5min': '5 Minutes',
            '15min': '15 Minutes',
            'food': 'Food',
            'day': 'Daytime',
            'week': 'Weektime',
          },
        },
      },
      fuzzy: {
        minutes: {
          0: '{hour:number|spell|capitalize|removeTrailingS} o’clock',
          5: 'Five past {hour:number|spell|capitalize}',
          10: 'Ten past {hour:number|spell|capitalize}',
          15: 'Quarter past {hour:number|spell|capitalize}',
          20: 'Twenty past {hour:number|spell|capitalize}',
          25: 'Twenty-five past {hour:number|spell|capitalize}',
          30: 'Half past {hour:number|spell|capitalize}',
          35: 'Twenty-five to {hour:number|plus1|mod12Or12|spell|capitalize}',
          40: 'Twenty to {hour:number|plus1|mod12Or12|spell|capitalize}',
          45: 'Quarter to {hour:number|plus1|mod12Or12|spell|capitalize}',
          50: 'Ten to {hour:number|plus1|mod12Or12|spell|capitalize}',
          55: 'Five to {hour:number|plus1|mod12Or12|spell|capitalize}',
          60: '{hour:number|plus1|mod12Or12|spell|capitalize|removeTrailingS} o’clock',
        },
        food: {
          0: 'Sleep',
          1: 'Breakfast',
          2: 'Second Breakfast',
          3: 'Elevenses',
          4: 'Lunch',
          5: 'Afternoon tea',
          6: 'Dinner',
          7: 'Supper',
        },
        day: {
          0: 'Night',
          1: 'Early morning',
          2: 'Morning',
          3: 'Almost noon',
          4: 'Noon',
          5: 'Afternoon',
          6: 'Evening',
          7: 'Late Evening',
        },
        week: { 0: 'Start of week', 1: 'Middle of week', 2: 'End of week', 3: 'Weekend!' },
      },
    },
  };
  const eventAdvertisements = {
    de: {
      settings: {
        enabled: {
          name: 'Event-Ankündigungen',
          description:
            'Zeigt ab und zu (selten) Ankündigungen zu coolen Events deiner studentischen Gremien in der Navigationsleiste an.',
        },
        noticeTime: {
          name: 'Event-Ankündigungen anzeigen ab Tage vorher',
          description:
            'Stelle hier ein, wie viele Tage vor einer Veranstaltung diese in der Navigationsleiste zu sehen sein soll.',
        },
      },
      start: 'Beginn',
      end: 'Ende',
      location: 'Ort',
      rrule: 'Regelmäßigkeit',
    },
    en: {
      settings: {
        enabled: {
          name: 'Event announcements',
          description:
            'Occasionally (rarely) displays announcements about cool events from your student committees ("Studentische Gremien") in the navigation bar.',
        },
        noticeTime: {
          name: 'Show event announcements from days before',
          description: 'Set here how many days before an event it should be displayed in the navigation bar',
        },
      },
      start: 'Start',
      end: 'End',
      location: 'Location',
      rrule: 'Regularity',
    },
  };
  const de$5 = {
    name: 'Laufband (Navigationsleiste)',
    description: 'Die Navigationsleiste eignet sich prima, um dort nützliche Informationen anzuzeigen.',
    settings: { speed: { name: 'Geschwindigkeit', description: 'Passe hier die Geschwindigkeit des Laufbands an.' } },
    features: {
      clock: clock.de,
      christmasCountdown: christmasCountdown.de,
      eventAdvertisements: eventAdvertisements.de,
    },
  };
  const en$4 = {
    name: 'Marquee (Navigation bar)',
    description: 'The top navigation bar is perfect to show usefull information.',
    settings: { speed: { name: 'Speed', description: 'Adjust the speed of the Marquee here.' } },
    features: {
      clock: clock.en,
      christmasCountdown: christmasCountdown.en,
      eventAdvertisements: eventAdvertisements.en,
    },
  };
  const de$2 = {
    name: 'Speiseplan der Mensa',
    description: 'Der Speiseplan deiner Lieblingsmensa direkt in Moodle.',
    close: 'Schließen',
    table: { dish: 'Gericht', co2score: 'CO₂ Score', types: 'Art(en)', price: 'Preis' },
    source: 'Original Speiseplan',
    errorWhileFetching:
      '\nHoppala, leider hat da was beim Auslesen des Speiseplans nicht geklappt :(. Manchmal hilft es, ihn einfach nochmals neu zu öffnen.\n\n<details>\n<summary><em>Fehlermeldung für wens interessiert</em></summary>\n<pre>{error}</pre>\n</details>'.trim(),
    settings: {
      enabled: {
        name: 'Speiseplan in der Navigationsleiste',
        description:
          'Erlaubt es dir, den Speiseplan deiner Lieblingsmensa direkt von der Moodle-Navigationsleiste aus zu öffnen.',
      },
      language: {
        name: 'Sprache des Speiseplans',
        description: 'Hier kannst du bei Bedarf eine Sprache des Speiseplans erzwingen.',
        options: { auto: '🌐 Auto (Better-Moodle Sprache)' },
      },
      canteen: {
        name: 'Mensa / Cafeteria',
        description: 'Von welcher Mensa / Cafeteria möchtest du den Speiseplan sehen?',
      },
    },
  };
  const en$1 = {
    name: 'Menu of the canteen',
    description: 'The menu of your favourite canteen within Moodle.',
    close: 'Close',
    table: { dish: 'Dish', co2score: 'CO₂ Score', types: 'Type(s)', price: 'Price' },
    source: 'Original menu',
    errorWhileFetching:
      "\nWhoopsie, unfortunately something didn't work when reading out the menu :(. Sometimes it helps to simply open it again.\n\n<details>\n<summary><em>The error, for whoever might be interested</em></summary>\n<pre>{error}</pre>\n</details>".trim(),
    settings: {
      enabled: {
        name: 'Menu in the navigation bar',
        description: 'Allows you to open the menu of your favourite canteen directly from the moodle navigation bar.',
      },
      language: {
        name: 'Language of the menu',
        description: 'Here you can force a menu language if required',
        options: { auto: '🌐 Auto (Better-Moodle language)' },
      },
      canteen: {
        name: 'Mensa / Cafeteria',
        description: 'Which canteen / cafeteria would you like to see the menu from?',
      },
    },
  };
  const i18n = {
    de: {
      0: 'Ich bin verwirrt, mir ist das Wetter nicht bekannt :(',
      1: 'Klarer Himmel',
      2: 'Wenige Wolken',
      3: 'Vereinzelte Wolken',
      4: 'Zerstreute Wolken',
      5: 'Bedeckter Himmel',
      6: 'Nebel',
      7: 'Nebel',
      8: 'Gefrierender Nebel',
      9: 'Staub',
      10: 'Sand',
      11: 'Dunst',
      12: 'Rauch',
      13: 'Vulkanasche',
      14: 'Wind',
      15: 'Windböen',
      16: 'Tornado',
      17: 'Leichter Schnee',
      18: 'Schnee',
      19: 'Starker Schnee',
      20: 'Leichter Regen',
      21: 'Regen',
      22: 'Starker Regen',
      23: 'Leichter Nieselregen',
      24: 'Nieselregen',
      25: 'Starker Nieselregen',
      26: 'Leichter Schneeregen',
      27: 'Schneeregen',
      28: 'Leichtes Gewitter',
      29: 'Gewitter',
      30: 'Starkes Gewitter',
      31: 'Leichter gefrierender Regen',
      32: 'Gefrierender Regen',
      33: 'Leichter gefrierender Nieselregen',
      34: 'Gefrierender Nieselregen',
      35: 'Starker gefrierender Nieselregen',
      36: 'Leichte Regenschauer',
      37: 'Regenschauer',
      38: 'Starke Regenschauer',
      39: 'Leichte Schneeregen-Schauer',
      40: 'Schneeregen-Schauer',
      41: 'Leichte Nieselregen-Schauer',
      42: 'Nieselregen-Schauer',
      43: 'Starke Nieselregen-Schauer',
      44: 'Leichte Schneeschauer',
      45: 'Schneeschauer',
      46: 'Starke Schneeschauer',
      47: 'Leichte Hagelschauer',
      48: 'Hagelschauer',
      49: 'Leichtes Gewitter mit Nieselregen',
      50: 'Gewitter mit Nieselregen',
      51: 'Starkes Gewitter mit Nieselregen',
      52: 'Leichtes Gewitter mit Regen',
      53: 'Gewitter mit Regen',
      54: 'Starkes Gewitter mit Regen',
      55: 'Leichtes Gewitter mit Schnee',
      56: 'Gewitter mit Schnee',
      57: 'Gewitter mit Hagel',
      58: 'Starkes Gewitter mit Hagel',
      59: 'Gewitter mit Hagelschauern',
      60: 'Schneesturm',
      61: 'Extremer Regen',
      62: 'Vereinzelt Regen in der Nähe',
      63: 'Vereinzelt Schnee in der Nähe',
      64: 'Vereinzelt Schneeregen in der Nähe',
      65: 'Vereinzelt gefrierender Nieselregen in der Nähe',
      66: 'Gewitter in der Nähe',
    },
    en: {
      0: 'I am confused, the weather is unknown :(',
      1: 'Clear sky',
      2: 'Few clouds',
      3: 'Scattered clouds',
      4: 'Broken clouds',
      5: 'Overcast clouds',
      6: 'Mist',
      7: 'Fog',
      8: 'Freezing fog',
      9: 'Dust',
      10: 'Sand',
      11: 'Haze',
      12: 'Smoke',
      13: 'Volcanic ash',
      14: 'Wind',
      15: 'Squalls',
      16: 'Tornado',
      17: 'Light snow',
      18: 'Snow',
      19: 'Heavy snow',
      20: 'Light rain',
      21: 'Rain',
      22: 'Heavy rain',
      23: 'Light drizzle',
      24: 'Drizzle',
      25: 'Heavy drizzle',
      26: 'Light sleet',
      27: 'Sleet',
      28: 'Light thunderstorm',
      29: 'Thunderstorm',
      30: 'Heavy thunderstorm',
      31: 'Light freezing rain',
      32: 'Freezing rain',
      33: 'Light freezing drizzle',
      34: 'Freezing drizzle',
      35: 'Heavy freezing drizzle',
      36: 'Light rain showers',
      37: 'Rain showers',
      38: 'Heavy rain showers',
      39: 'Light sleet showers',
      40: 'Sleet showers',
      41: 'Light drizzle showers',
      42: 'Drizzle showers',
      43: 'Heavy drizzle showers',
      44: 'Light snow showers',
      45: 'Snow showers',
      46: 'Heavy snow showers',
      47: 'Light hail shower',
      48: 'Hail shower',
      49: 'Light thunderstorm with drizzle',
      50: 'Thunderstorm with drizzle',
      51: 'Heavy thunderstorm with drizzle',
      52: 'Light thunderstorm with rain',
      53: 'Thunderstorm with rain',
      54: 'Heavy thunderstorm with rain',
      55: 'Light thunderstorm with snow',
      56: 'Thunderstorm with snow',
      57: 'Thunderstorm with hail',
      58: 'Heavy thunderstorm with hail',
      59: 'Thunderstorm with rain showers',
      60: 'Blizzard',
      61: 'Extreme rain',
      62: 'Patchy rain nearby',
      63: 'Patchy snow nearby',
      64: 'Patchy sleet nearby',
      65: 'Patchy freezing drizzle nearby',
      66: 'Thundery outbreaks nearby',
    },
  };
  const conditionsByEmoji = new Map([
    ['❓', new Set([0])],
    ['☀️', new Set([1])],
    ['🌤️', new Set([2])],
    ['⛅', new Set([3])],
    ['🌥️', new Set([4])],
    ['☁️', new Set([5])],
    ['🌫️', new Set([6, 7, 8, 11, 12])],
    ['🌪️', new Set([9, 10, 16])],
    ['🌋', new Set([13])],
    ['🌬️', new Set([14, 15])],
    ['🌨️', new Set([17, 18, 26, 27, 44, 45, 46, 39, 40, 55, 56, 57, 58, 63])],
    ['❄️', new Set([19, 60])],
    ['🌦️', new Set([20, 23, 36, 41, 62, 49, 52])],
    ['🌧️', new Set([21, 22, 24, 25, 37, 38, 42, 43, 31, 32, 33, 34, 35, 64, 65, 50, 51, 53, 54, 59, 47, 48])],
    ['🌩️', new Set([28, 49, 52, 55])],
    ['⛈️', new Set([29, 30, 50, 51, 53, 54, 56, 57, 58, 59, 66])],
    ['🌊', new Set([61])],
  ]);
  const getWeatherEmoji = condition =>
    conditionsByEmoji.entries().find(([, codes]) => codes.has(condition))?.[0] ?? '❓️';
  const wttrInCodeToCondition = {
    113: 1,
    116: 2,
    119: 4,
    122: 5,
    143: 6,
    176: 62,
    179: 63,
    182: 64,
    185: 65,
    200: 66,
    227: 19,
    230: 60,
    248: 7,
    260: 8,
    263: 41,
    266: 23,
    281: 34,
    284: 35,
    293: 36,
    296: 20,
    299: 37,
    302: 21,
    305: 38,
    308: 22,
    311: 31,
    314: 32,
    317: 26,
    320: 27,
    323: 44,
    326: 17,
    329: 45,
    332: 18,
    335: 46,
    338: 19,
    350: 27,
    353: 36,
    356: 37,
    359: 61,
    362: 39,
    365: 40,
    368: 44,
    371: 45,
    374: 47,
    377: 48,
    386: 52,
    389: 53,
    392: 55,
    395: 56,
  };
  const openMeteoCodeToCondition = {
    0: 1,
    1: 2,
    2: 4,
    3: 5,
    45: 7,
    48: 8,
    51: 23,
    53: 24,
    55: 25,
    56: 33,
    57: 34,
    61: 20,
    63: 21,
    65: 22,
    66: 31,
    67: 32,
    71: 17,
    73: 18,
    75: 19,
    77: 34,
    80: 36,
    81: 37,
    82: 38,
    85: 45,
    86: 46,
    95: 29,
    96: 57,
    99: 58,
  };
  const visualCrossingCodeToCondition = {
    'snow': 18,
    'snow-showers-day': 45,
    'snow-showers-night': 45,
    'thunder-rain': 53,
    'thunder-showers-day': 59,
    'thunder-showers-night': 59,
    'rain': 21,
    'rain-showers-day': 37,
    'rain-showers-night': 37,
    'fog': 7,
    'wind': 14,
    'cloudy': 5,
    'partly-cloudy-day': 3,
    'partly-cloudy-night': 3,
    'clear-day': 1,
    'clear-night': 1,
  };
  const openWeatherMapCodeToCondition = {
    200: 52,
    201: 53,
    202: 54,
    210: 28,
    211: 29,
    212: 30,
    221: 29,
    230: 49,
    231: 50,
    232: 51,
    300: 23,
    301: 24,
    302: 25,
    310: 23,
    311: 24,
    312: 25,
    313: 41,
    314: 42,
    321: 43,
    500: 20,
    501: 21,
    502: 22,
    503: 22,
    504: 61,
    511: 32,
    520: 36,
    521: 37,
    522: 38,
    531: 37,
    600: 17,
    601: 18,
    602: 19,
    611: 27,
    612: 39,
    613: 40,
    615: 26,
    616: 27,
    620: 44,
    621: 45,
    622: 46,
    701: 6,
    711: 12,
    721: 11,
    731: 9,
    741: 7,
    751: 10,
    761: 9,
    762: 13,
    771: 15,
    781: 16,
    800: 1,
    801: 2,
    802: 3,
    803: 4,
    804: 5,
  };
  const codeToCondition = (provider2, code) => {
    switch (provider2) {
      case 'wttrIn':
        return wttrInCodeToCondition[code] ?? 0;
      case 'openMeteo':
        return openMeteoCodeToCondition[code] ?? 0;
      case 'visualCrossing':
        return visualCrossingCodeToCondition[code] ?? 0;
      case 'openWeatherMap':
        return openWeatherMapCodeToCondition[code] ?? 0;
    }
    return 0;
  };
  const de$1 = {
    name: 'Wetter',
    description: '',
    apiKeyRequired: 'API-Key benötigt',
    apiKeyWarning:
      'Bitte hinterlege in den Einstellungen von Better-Moodle einen gültigen API-Key für {provider}. Ein API-Key für den kostenlosen Free-Plan reicht aus.',
    providers: {
      wttrIn: 'wttr.in',
      openMeteo: 'Open-Meteo',
      visualCrossing: 'Visual Crossing',
      openWeatherMap: 'OpenWeatherMap',
    },
    fetchError:
      'Es kam zu einem Fehler beim Aktualisieren der Wetter-Daten. Bitte überprüfe (falls nötig) deinen API-Key oder versuche einen anderen Anbieter.',
    settings: {
      'enabled': { name: 'Wetter anzeigen', description: 'Zeige das Wetter in Moodle an.' },
      'provider': { name: 'Anbieter', description: 'Wähle den Anbieter für die Wetterdaten aus.' },
      'api.openWeatherMap': {
        name: 'API-Key für OpenWeatherMap',
        description: 'Trage hier deinen API-Key für OpenWeatherMap ein (der Free-Plan ist ausreichend).',
      },
      'api.visualCrossing': {
        name: 'API-Key für Visual Crossing',
        description: 'Trage hier deinen API-Key für Visual Crossing ein (der Free-Plan ist ausreichend).',
      },
      'units': {
        name: 'Einheiten',
        description: 'Wähle die Einheiten für die Wetterdaten aus.',
        options: {
          metric: 'Metrisch (°C, km/h, km, mm)',
          scientific: 'SI Einheiten (K, m/s, m, m)',
          imperial: 'Imperial (°F, mph, mi, in)',
        },
      },
      'tempInNav': {
        name: 'Temperatur in der Navigationsleiste anzeigen',
        description: 'Zeige die aktuelle Temperatur in der Navigationsleiste an.',
      },
      'feelLikeTempInNav': {
        name: 'Gefühlte Temperatur nutzen',
        description: 'Ermöglicht das Umschalten zwischen der tatsächlichen Temperatur und der gefühlten  Temperatur.',
      },
    },
    conditions: i18n.de,
    modal: {
      title: 'Wetter-Moodle für {city:string}',
      source: 'Quelle',
      raw: 'Rohdaten',
      condition: 'Aktuelles Wetter',
      temperature: 'Temperatur',
      temperatureFeelsLike: 'gefühlt',
      wind: 'Wind',
      windDirection: 'Richtung',
      visibility: 'Sichtweite',
      humidity: 'Luftfeuchtigkeit',
      pressure: 'Luftdruck',
      cloudCover: 'Bewölkung',
      precipitation: 'Niederschlagsmenge',
    },
  };
  const en = {
    name: 'Weather',
    description: '',
    apiKeyRequired: 'API-Key required',
    apiKeyWarning:
      'Please enter a valid API key for {provider} in the Better-Moodle settings. An API key for the free plan is sufficient.',
    providers: {
      wttrIn: 'wttr.in',
      openMeteo: 'Open-Meteo',
      visualCrossing: 'Visual Crossing',
      openWeatherMap: 'OpenWeatherMap',
    },
    fetchError:
      'There was an error updating the weather data. Please check your API key (if necessary) or try another provider.',
    settings: {
      'enabled': { name: 'Show weather', description: 'Show the weather in Moodle.' },
      'provider': { name: 'Provider', description: 'Choose the provider for the weather data.' },
      'api.openWeatherMap': {
        name: 'API-Key for OpenWeatherMap',
        description: 'Put your API key for OpenWeatherMap here (the free plan is sufficient).',
      },
      'api.visualCrossing': {
        name: 'API-Key for Visual Crossing',
        description: 'Put your API key for Visual Crossing here (the free plan is sufficient).',
      },
      'units': {
        name: 'Units',
        description: 'Select the units for the weather data.',
        options: {
          metric: 'Metric (°C, km/h, km, mm)',
          scientific: 'SI Units (K, m/s, m, m)',
          imperial: 'Imperial (°F, mph, mi, in)',
        },
      },
      'tempInNav': {
        name: 'Show temperature in the navigation bar',
        description: 'Show the current temperature in the navigation bar.',
      },
      'feelLikeTempInNav': {
        name: "Use 'feels like' temperature",
        description: "Allows you to switch between the actual temperature and the 'feels like' temperature.",
      },
    },
    conditions: i18n.en,
    modal: {
      title: 'Weather-Moodle for {city:string}',
      source: 'Source',
      raw: 'Raw data',
      condition: 'Current weather',
      temperature: 'Temperature',
      temperatureFeelsLike: 'felt',
      wind: 'Wind',
      windDirection: 'Direction',
      visibility: 'Visibility',
      humidity: 'Humidity',
      pressure: 'Pressure',
      cloudCover: 'Cloud cover',
      precipitation: 'Precipitation',
    },
  };
  const localeTranslations = {
    'de': {
      settings: {
        newBadge: 'Neu!',
        modal: {
          title: 'Einstellungen',
          moodleSettings: 'Zu den Moodle Einstellungen',
          installedVersion: 'installierte Version',
          latestVersion: 'aktuellste Version',
          import: 'Einstellungen importieren',
          export: 'Einstellungen exportieren',
          search: 'Suche...',
        },
        changelog: 'Changelog',
        requireReload:
          'Die Änderungen dieser Einstellung (*{name: string}*) werden erst nach einem Neuladen der Seite übernommen.  \nDas Speichern der Einstellungen führt daher automatisch zu einem Neuladen der Seite.',
        saved:
          'Alle Einstellungen wurden erfolgreich gespeichert und angewendet. Viel Spaß mit deinem individualisierten Better-Moodle! 😊',
        sync: 'Die Einstellung "{name: string}" wurde in einem anderen Tab geändert und von dort übernommen.',
        syncRequireReload:
          'Du hast eine Einstellung (*{name: string}*) in einem anderen Tab geändert, die ein Neuladen der Seite erfordert.  \nBitte lade die Seite neu, um diese Änderungen zu übernehmen.',
        tags: { fun: 'Spaßeinstellung' },
      },
      update: {
        btn: 'Update installieren',
        title: 'Better-Moodle aktualisieren',
        close: 'Ohne Neuladen schließen',
        reload: 'Moodle neuladen',
        body: '\nUiiii, ein Update für Better-Moodle ist bereit zur Installation 👀\n\nFalls noch nicht geschehen, befolge bitte die Anweisungen deines Userscript-Managers, um das Update zu installieren. Ggf. wurde ein neuer Tab im Hintergrund geöffnet. Um das Update abzuschließen, lade bitte Moodle nach der Installation einmal neu.\n\nUm zu erfahren, was sich seit deinem letzten Update getan hat, hier der relevante Auszug aus dem Changelog:\n'.trim(),
      },
      support: { title: 'Hilfe zu Better-Moodle', close: 'Vielen Dank für die Hilfe! 😊' },
      language: { flag: '🇩🇪', name: 'Deutsch' },
      browserCheck: {
        title: 'Better-Moodle: Browser nicht unterstützt',
        browser: 'Browser',
        minVersion: 'Älteste noch unterstützte Version',
        dismiss: { version: 'Für diese Browser-Version ausblenden', session: 'Für diese Sitzung ausblenden' },
        body: '\nHallo!\n\nLeider scheinst du einen Browser zu nutzen, der nicht offiziell von Better-Moodle unterstützt wird.\nDaher kann es sein, dass manche Features nicht korrekt funktionieren.\n\nUm möglichst modernen Code schreiben zu können und aus Sicherheitsgründen, empfiehlt Better-Moodle die Verwendung eines aktuellen Browsers.\nFür weitere Informationen kann [https://better-moodle.dev](https://better-moodle.dev) konsultiert werden.\n\nDie offiziell unterstützten Browser (Das Better-Moodle Core-Team empfiehlt Firefox):\n'.trim(),
      },
      features: {
        bookmarks: {
          name: 'Lesezeichen',
          description:
            'Wer nutzt schon den Lesezeichenmanager des Browsers? Der hier in Better-Moodle eingebaute ist einfach viel cooler!',
          settings: {
            enabled: {
              name: 'Lesezeichenmanager aktivieren',
              description: 'Aktiviert einen Lesezeichenmanager, um Lesezeichen direkt im Moodle zu haben.',
            },
          },
          bookmarks: 'Lesezeichen',
          add: 'Lesezeichen hinzufügen',
          edit: 'Lesezeichen bearbeiten',
          empty: 'Es sind noch keine Lesezeichen angelegt.',
          savedNotification: 'Deine Lesezeichen wurden erfolgreich gespeichert! 😊',
          modal: { title: 'Bezeichnung', url: 'Adresse' },
        },
        courses: de$n,
        darkmode: {
          name: 'Darkmode',
          description:
            'Der in Better-Moodle integrierte Darkmode wird durch [Dark Reader](https://darkreader.org/) generiert. 😊',
          settings: {
            mode: {
              name: 'Modus',
              description: 'Wähle den Modus des Darkmodes (an, aus, automatisch)',
              options: { on: 'An', off: 'Aus', auto: 'Automatisch (Systemeinstellung befolgen)' },
            },
            brightness: { name: 'Helligkeit', description: 'Stelle die Helligkeit des Darkmodes ein.' },
            contrast: { name: 'Kontrast', description: 'Stelle den Kontrast des Darkmodes ein.' },
            grayscale: {
              name: 'Graustufen',
              description: 'Stelle ein, wie wenige Farben du im Moodle haben möchtest.',
            },
            sepia: { name: 'Sepia', description: 'Stelle einen Sepia-Wert für den Darkmodes ein.' },
          },
        },
        dashboard: de$k,
        general: de$d,
        linkIcons: {
          name: 'Links kennzeichnen',
          description:
            'Manchmal ist es nicht ganz einfach zu erkennen, was sich hinter einem Link versteckt. Diese Einstellungen helfen dir, besondere Links besser zu erkennen.',
          settings: {
            external: {
              name: 'Externe Links',
              description: 'Zeigt ein kleines Icon an, wenn ein Link extern ist, also aus Moodle heraus führt.',
            },
            mail: {
              name: 'Emails',
              description: 'Zeigt ein kleines Icon an, wenn ein Link deinen Email-Client öffnen kann.',
            },
            phone: {
              name: 'Telefonnummern',
              description: 'Zeigt ein kleines Icon an, wenn ein Link zu einer Telefonnummer führt.',
            },
          },
        },
        messages: de$9,
        navbarMarquee: de$5,
        nina: {
          name: 'Amtliche Warnmeldungen (NINA)',
          description:
            'Erhalte deine amtlichen Warnmeldungen aus den Bereichen Bevölkerungsschutz, Wetter und Hochwasser nicht nur auf [warnungen.bund.de](https://warnung.bund.de/meldungen) sondern auch im Moodle.',
          settings: {
            civilWarnings: {
              name: 'Benachrichtigungen für Bevölerungsschutz-Warnungen',
              description:
                'Hier kann eingestellt werden, ab welcher Warnstufe eine Benachrichtigung angezeigt werden soll.',
              labels: {
                off: 'Nie',
                extreme: 'Extreme Gefahr',
                severe: 'Gefahr',
                moderate: 'Gefahreninformation',
                minor: 'Immer',
              },
            },
            policeWarnings: {
              name: 'Benachrichtigungen für Polizeiwarnungen',
              description:
                'Hier kann eingestellt werden, ab welcher Warnstufe eine Benachrichtigung angezeigt werden soll.',
              labels: {
                off: 'Nie',
                extreme: 'Extreme Gefahr',
                severe: 'Gefahr',
                moderate: 'Gefahreninformation',
                minor: 'Immer',
              },
            },
            weatherWarnings: {
              name: 'Benachrichtigungen für Wetterwarnungen',
              description:
                'Hier kann eingestellt werden, ab welcher Warnstufe des Deutschen Wetterdienstes eine Benachrichtigung angezeigt werden soll.',
              labels: {
                off: 'Nie',
                extreme: 'Extremes Unwetter',
                severe: 'Unwetter',
                moderate: 'Markantes Wetter',
                minor: 'Immer',
              },
            },
            floodWarnings: {
              name: 'Hochwasserwarnungen',
              description:
                'Benachrichtigungen zu Hochwasserereignissen an Binnengewässern (Flüsse, Kanäle, Binnenseen).',
              labels: { off: 'Nie', all: 'Immer' },
            },
            inAppNotifications: {
              name: 'Benachrichtigung im Moodle',
              description:
                'Erhalte ein kleines Popup im Moodle, über das du weitere Details zur Warnung aufrufen kannst.',
            },
            desktopNotifications: {
              name: 'Benachrichtigung auf dem Gerät',
              description:
                'Erhalte eine Benachrichtigung auf deinem Gerät, über die du weitere Details zur Warnung aufrufen kannst.',
            },
            notifyUpdates: {
              name: 'Über Aktualisierungen benachrichtigen',
              description:
                'Sendet eine Benachrichtigung, wenn die Behörde eine Aktualisierung der Warnung veröffentlicht. Das kann manchmal leider ganz schön häufig sein.',
            },
            notifyClearSignal: {
              name: 'Über Entwarnungen benachrichtigen',
              description: 'Sendet eine Benachrichtigung, wenn die Behörde eine Entwarnung veröffentlicht.',
            },
          },
          modal: {
            activeWarnings: 'Aktive Warnungen',
            bbkLink: 'Meldung auf der Seite des BBK',
            categories: 'Kategorien',
            close: 'Schließen',
            description: 'Beschreibung',
            instruction: 'Handlungsempfehlung',
            noActiveWarnings: 'Keine aktiven Warnungen',
            notFound: {
              title: 'MELDUNG NICHT MEHR VORHANDEN',
              description:
                'Die von Ihnen abgerufene Warnmeldung ist nicht mehr vorhanden. Es liegt ggf. eine Entwarnung für diese Meldung vor.',
            },
            providedBy: 'Herausgegeben von',
            reload: 'Aktualisieren',
            sentAt: 'Meldung vom',
            showMore: 'Mehr anzeigen',
            via: 'via',
          },
          category: {
            geo: 'Geophysikalisch (einschl. Erdrutsch)',
            met: 'Meteorologisch (einschl. Hochwasser)',
            safety: 'Allgemeine Notfälle und öffentliche Sicherheit',
            security: 'Strafverfolgung, Militär, Heimatschutz und lokale/private Sicherheit',
            rescue: 'Rettung und Bergung',
            fire: 'Brandbekämpfung und Rettung',
            health: 'Medizinische und öffentliche Gesundheit',
            env: 'Verschmutzung und andere Umweltprobleme',
            transport: 'Öffentlicher und privater Transport',
            infra: 'Versorgungs-, Telekommunikations- und andere Nicht-Verkehrsinfrastruktur',
            cbrne: 'Chemisch, biologisch, radiologisch, nuklear und explosiv',
            other: 'Andere Ereignisse',
          },
          msgType: {
            ack: 'Bestätigung',
            alert: 'Warnung',
            cancel: 'Entwarnung',
            error: 'Fehler',
            update: 'Aktualisierung',
          },
          severity: {
            civilProtection: {
              unknown: 'Unbekannt',
              minor: 'Keine Gefahr',
              moderate: 'Gefahreninformation',
              severe: 'Gefahr',
              extreme: 'Extreme Gefahr',
            },
            flood: {
              unknown: 'Unbekannt',
              minor: 'Keine Gefahr',
              moderate: 'Hochwasser',
              severe: 'Großes Hochwasser',
              extreme: 'Sehr großes Hochwasser',
            },
            police: {
              unknown: 'Unbekannt',
              minor: 'Keine Gefahr',
              moderate: 'Gefahreninformation',
              severe: 'Gefahr',
              extreme: 'Extreme Gefahr',
            },
            weather: {
              unknown: 'Unbekannt',
              minor: 'Keine Gefahr',
              moderate: 'Markantes Wetter',
              severe: 'Unwetter',
              extreme: 'Extremes Unwetter',
            },
          },
          status: {
            name: 'Status',
            actual: 'Echte Warnung',
            exercise: 'Übung',
            system: 'System',
            test: 'Testwarnung',
            draft: 'Entwurf',
          },
          provider: {
            mow: 'MoWaS',
            kat: 'KATWARN',
            biw: 'BIWAPP',
            pol: 'Polizei',
            dwd: 'Deutscher Wetterdienst',
            lhp: 'Länderübergreifendes Hochwasserportal',
          },
        },
        semesterzeiten: {
          name: 'Semesterzeiten',
          description:
            'Mal wieder den Überblick verloren, welchen Monat wir gerade haben? Mit diesen Features und Einstellungen bekommst du direkt im Moodle Informationen darüber, wo im Semester wir uns gerade befinden.',
          publicHoliday: 'Feiertag',
          table: {
            name: 'Zeitraum',
            start: 'Beginn',
            end: 'Ende',
            progress: 'Fortschritt',
            show: 'Im Balken anzeigen?',
          },
          settings: {
            block: {
              name: 'Block im Dashboard',
              description: 'Fügt dem Dashboard einen Block hinzu, der die Semesterzeiten anzeigt.',
            },
          },
        },
        speiseplan: de$2,
        weather: de$1,
      },
      numbers: {
        1: 'eins',
        2: 'zwei',
        3: 'drei',
        4: 'vier',
        5: 'fünf',
        6: 'sechs',
        7: 'sieben',
        8: 'acht',
        9: 'neun',
        10: 'zehn',
        11: 'elf',
        12: 'zwölf',
      },
    },
    'en-gb': {
      settings: {
        newBadge: 'New!',
        modal: {
          title: 'Preferences',
          moodleSettings: 'Go to Moodle-Preferences',
          installedVersion: 'installed version',
          latestVersion: 'latest Version',
          import: 'import preferences',
          export: 'export preferences',
          search: 'Search...',
        },
        changelog: 'Changelog',
        requireReload:
          'The changes of this setting (*{name}*) will only take effect after reloading the page.  \nSaving the settings will therefore automatically reload the page.',
        saved: 'All settings have been successfully saved and applied. Have fun with your customised Better-Moodle! 😊',
        sync: 'The setting "{name}" has been changed in another tab and has been adopted from there.',
        syncRequireReload:
          'You have changed a setting (*{name}*) in another tab that require reloading the page.  \nPlease reload the page to apply these changes.',
        tags: { fun: 'Fun setting' },
      },
      update: {
        btn: 'Install update',
        title: 'Update Better-Moodle',
        close: 'Close without reload',
        reload: 'Reload moodle',
        body: "\nUh, an update for Better-Moodle is ready for installation 👀\n\nIf you haven't already done so, please follow the instructions of your userscript manager to install the update. A new tab may have been opened in the background. To complete the update, please reload Moodle once after the installation.\n\nTo find out what has changed since your last update, here is the relevant extract from the changelog:\n".trim(),
      },
      support: { title: 'Support for Better-Moodle', close: 'Thanks for the great support! 😊' },
      language: { flag: '🇬🇧', name: 'English' },
      browserCheck: {
        title: 'Better-Moodle: Unsupported Browser',
        browser: 'Browser',
        minVersion: 'Minimum supported version',
        dismiss: { version: 'Hide for this Browser-Version', session: 'Hide for this session' },
        body: '\nMoin!\n\n\nUnfortunately you seem to use a Browser that is not officially supported by Better-Moodle.\nSome features may not work correctly.\n\nTo allow the use of modern Code and to maintain maximum security, Better-Moodle suggests using an up-to-date browser.\nFor further information, please see [https://better-moodle.dev](https://better-moodle.dev).\n\nThese Browsers are officially supported (Better-Moodle Core-Developers recommend Firefox):\n'.trim(),
      },
      features: {
        bookmarks: {
          name: 'Bookmarks',
          description:
            'Who even uses the bookmarks feature of their browser? The one integrated in Better-Moodle is way cooler!',
          settings: {
            enabled: {
              name: 'Enable bookmarks manager',
              description: 'Enables a bookmarks manager to allow bookmarks within Moodle.',
            },
          },
          bookmarks: 'Bookmarks',
          add: 'Add bookmark',
          edit: 'Edit bookmarks',
          empty: 'No bookmarks created yet.',
          savedNotification: 'Your bookmarks were saved successfully! 😊',
          modal: { title: 'Title', url: 'Adress' },
        },
        courses: en$m,
        darkmode: {
          name: 'Darkmode',
          description: 'Darkmode in Better-Moodle is brought to you through [Dark Reader](https://darkreader.org/). 😊',
          settings: {
            mode: {
              name: 'Mode',
              description: 'Select a mode for Darkmode (on, off, auto)',
              options: { on: 'On', off: 'Off', auto: 'Auto (follow system setting)' },
            },
            brightness: { name: 'Brightness', description: 'Set the brightness of the dark mode.' },
            contrast: { name: 'Contrast', description: 'Set the contrast of the dark mode.' },
            grayscale: { name: 'Greyscale', description: 'Set how few colours you want to have in Moodle.' },
            sepia: { name: 'Sepia', description: 'Set the sepia value of the dark mode.' },
          },
        },
        dashboard: en$j,
        general: en$c,
        linkIcons: {
          name: 'Mark links',
          description:
            'Sometimes it is hard to identify what is hidden behind a link. These settings help you identify special links.',
          settings: {
            external: {
              name: 'Mark links: external links',
              description: 'Shows a small icon next to links that lead away from this Moodle instance.',
            },
            mail: {
              name: 'Mark links: Emails',
              description: 'Shows a small icon next to links that can open your Email-Client.',
            },
            phone: { name: 'Phone', description: 'Shows a small icon next to links that are phone numbers' },
          },
        },
        messages: en$8,
        navbarMarquee: en$4,
        nina: {
          name: 'Authoritative warning messages (NINA)',
          description:
            'Receive your authoritative warning messages from the areas of civil protection, weather and flooding not only on [warnungen.bund.de](https://warnung.bund.de/meldungen) but also in Moodle.',
          settings: {
            civilWarnings: {
              name: 'Civil protection warnings',
              description: 'Here you can set the warning level from which you want to receive a notification.',
              labels: {
                off: 'Never',
                extreme: 'Extreme danger',
                severe: 'Danger',
                moderate: 'Hazard information',
                minor: 'Always',
              },
            },
            policeWarnings: {
              name: 'Police warnings',
              description: 'Here you can set the warning level from which you want to receive a notification.',
              labels: {
                off: 'Never',
                extreme: 'Extreme danger',
                severe: 'Danger',
                moderate: 'Hazard information',
                minor: 'Always',
              },
            },
            weatherWarnings: {
              name: 'Weather warnings',
              description:
                'Here you can set the Deutscher Wetterdienst warning level from which you want to receive a notification.',
              labels: {
                off: 'Never',
                extreme: 'Extreme storm',
                severe: 'Storm',
                moderate: 'Severe weather',
                minor: 'Always',
              },
            },
            floodWarnings: {
              name: 'Flood warnings',
              description: 'Notifications about flooding events on inland waters (rivers, canals, inland lakes).',
              labels: { off: 'Never', all: 'Always' },
            },
            inAppNotifications: {
              name: 'Notification within Moodle',
              description:
                'Receive a small pop-up within Moodle, which you can use to call up further details about the warning.',
            },
            desktopNotifications: {
              name: 'Notification on the device',
              description:
                'Receive a notification on your device, which you can use to call up further details about the warning',
            },
            notifyUpdates: {
              name: 'Notify about updates',
              description:
                'Sends a notification whenever the authorities are updating the warning (which unfortunately sometimes may happen often).',
            },
            notifyClearSignal: {
              name: 'Notify about All-Clear signals',
              description:
                'Sends a notification whenever the authorities are giving an All-Clear signal about a warning.',
            },
          },
          modal: {
            activeWarnings: 'Active warnings',
            bbkLink:
              'More information on the website of the Federal Office for Civil Protection and Disaster Assistance',
            categories: 'Categories',
            close: 'Close',
            description: 'Description',
            instruction: 'Instruction',
            noActiveWarnings: 'No active warnings',
            notFound: {
              title: 'MESSAGE NO LONGER AVAILABLE',
              description:
                'The warning message you have called up no longer exists. There may be an all-clear for this message.',
            },
            providedBy: 'Provided by',
            reload: 'Reload',
            sentAt: 'Sent at',
            showMore: 'Show more',
            via: 'via',
          },
          category: {
            geo: 'Geophysical (inc. landslide)',
            met: 'Meteorological (inc. flood)',
            safety: 'General emergency and public safety',
            security: 'Law enforcement, military, homeland and local/private security',
            rescue: 'Rescue and recovery',
            fire: 'Fire suppression and rescue',
            health: 'Medical and public health',
            env: 'Pollution and other environmental threats',
            transport: 'Public and private transportation',
            infra: 'Utility, telecommunication, other non-transport infrastructure',
            cbrne: 'Chemical, Biological, Radiological, Nuclear or High-Yield Explosive threat or attack',
            other: 'Other events',
          },
          msgType: { ack: 'Acknowledgement', alert: 'Alert', cancel: 'Cancel', error: 'Error', update: 'Update' },
          severity: {
            civilProtection: {
              unknown: 'Unknown',
              minor: 'Minor',
              moderate: 'Moderate',
              severe: 'Severe',
              extreme: 'Extreme',
            },
            flood: {
              unknown: 'Unknown',
              minor: 'Minor flooding',
              moderate: 'Moderate flooding',
              severe: 'Severe flooding',
              extreme: 'Extreme flooding',
            },
            police: { unknown: 'Unknown', minor: 'Minor', moderate: 'Moderate', severe: 'Severe', extreme: 'Extreme' },
            weather: {
              unknown: 'Unknown',
              minor: 'Minor',
              moderate: 'Significant weather',
              severe: 'Storm',
              extreme: 'Extreme storm',
            },
          },
          status: {
            name: 'Status',
            actual: 'Actual',
            exercise: 'Exercise',
            system: 'System',
            test: 'Test',
            draft: 'Draft',
          },
          provider: {
            mow: 'MoWaS',
            kat: 'KATWARN',
            biw: 'BIWAPP',
            pol: 'Police',
            dwd: 'German Weather Service (DWD)',
            lhp: 'Cross-state flood portal (LHP)',
          },
        },
        semesterzeiten: {
          name: 'Semester times',
          description:
            'Lost track of what month it is again? With these features and settings, you can find out where we are in the semester directly in Moodle.',
          publicHoliday: 'Public holiday',
          table: { name: 'Period', start: 'Start', end: 'End', progress: 'Progress', show: 'Show in Progress bar?' },
          settings: {
            block: {
              name: 'Block in the Dashboard',
              description: 'Adds a block to the dashboard that shows the semester times.',
            },
          },
        },
        speiseplan: en$1,
        weather: en,
      },
      numbers: {
        1: 'one',
        2: 'two',
        3: 'three',
        4: 'four',
        5: 'five',
        6: 'six',
        7: 'seven',
        8: 'right',
        9: 'nine',
        10: 'ten',
        11: 'eleven',
        12: 'twelve',
      },
    },
  };
  const loadLocale = locale => {
    if (loadedLocales[locale]) return;
    loadedLocales[locale] = localeTranslations[locale];
    loadFormatters(locale);
  };
  const loadFormatters = locale => void (loadedFormatters[locale] = initFormatters(locale));
  (() => {
    locales.forEach(loadLocale);
  })();
  const HTML_LANG = document.documentElement.lang.toLowerCase();
  const MOODLE_LANG = { en: 'en-gb' }[HTML_LANG] ?? HTML_LANG;
  const BETTER_MOODLE_LANG = (() => {
    const savedLanguage = GM_getValue(STORAGE_V2_LANGUAGE_KEY, 'auto');
    if ('auto' === savedLanguage) return MOODLE_LANG;
    return savedLanguage;
  })();
  class LLMapClass extends Map {
    get(key) {
      if ('auto' === key) return this.get(BETTER_MOODLE_LANG);
      const object = super.get(key);
      if (object) return object;
      const newObject = i18nObject(key);
      this.set(key, newObject);
      return newObject;
    }
  }
  const LLMap = new LLMapClass();
  const LL$a = LLMap.get('auto');
  const LLFG = featureGroup => LL$a.features[featureGroup];
  const LLF = (featureGroup, feature) => LLFG(featureGroup).features[feature];
  const languages = new Map();
  for (const locale of locales) languages.set(locale, loadedLocales[locale].language);
  const isFeatureGroup = id => id in LL$a.features;
  const stringify$1 = num => num.toLocaleString(BETTER_MOODLE_LANG);
  const settingsStyle = {
    openSettingsBtn: 'better-moodle_settings__open-settings-btn',
    newSettingBadge: 'better-moodle_settings__new-setting-badge',
    settingsForm: 'better-moodle_settings__settings-form',
    supportWrapper: 'better-moodle_settings__support-wrapper',
    hideDisabledSettings: 'better-moodle_settings__hide-disabled-settings',
    hideNewSettingBadges: 'better-moodle_settings__hide-new-setting-badges',
    hideFunSettings: 'better-moodle_settings__hide-fun-settings',
    settingsFooterBtns: 'better-moodle_settings__settings-footer-btns',
  };
  const TempStorage$1 = new (class TempStorage {
    settingsRequireReload = false;
  })();
  const tags = { fun: '🎡' };
  const Tag = tag => createElement('span', { title: `${tags[tag]}: ${LL$a.settings.tags[tag]()}` }, tags[tag]);
  class Setting extends CanBeReady {
    #id;
    #default;
    #tags = new Set();
    #possibleIDs = new Set();
    #feature;
    #formControl;
    #unsavedValue;
    #conditionalDisabledStates = new Map();
    #requiresReload = false;
    #syncListener = null;
    migrator = null;
    constructor(id, defaultValue, createComponent, params) {
      super();
      this.#id = id;
      this.#default = this.#unsavedValue = defaultValue;
      this.callWhenReady(() => {
        this.#formControl = createComponent({ id: this.inputID, value: this.savedValue, ...params });
        this.#formControl.addEventListener('change', () => (this.#unsavedValue = this.#formControl.value));
        this.#possibleIDs.add(this.id);
        this.#migrateSettingStorage();
        this.#addUpdateOnSync();
      });
    }
    migrateStoredValue(oldValue2) {
      return this.migrator?.(oldValue2) ?? oldValue2;
    }
    #migrateSettingStorage(oldKey = `better-moodle-settings.${this.id}`) {
      const undefinedValue = crypto.randomUUID();
      const oldValue2 = GM_getValue(oldKey, undefinedValue);
      if (oldValue2 !== undefinedValue) {
        if (!GM_listValues().includes(this.settingKey)) {
          const migratedValue = this.migrateStoredValue(oldValue2) ?? oldValue2;
          GM_setValue(this.settingKey, migratedValue);
          this.#formControl.value = this.#unsavedValue = migratedValue;
          this.save();
        }
        GM_deleteValue(oldKey);
      }
    }
    #addUpdateOnSync() {
      if (this.#syncListener) return;
      this.#syncListener = GM_addValueChangeListener(this.settingKey, (_, __, ___, remote) => {
        if (!remote) return;
        this.undo();
        require2(['core/toast'], ({ add: add2 }) => {
          if (this.#requiresReload) {
            add2(mdToHtml(LL$a.settings.syncRequireReload({ name: this.title })), {
              type: 'info',
              autohide: false,
              closeButton: true,
            });
          } else add2(LL$a.settings.sync({ name: this.title }), { type: 'success', autohide: true });
        });
      });
    }
    addAlias(key, migrator) {
      this.#possibleIDs.add(key);
      if (migrator) this.migrator = migrator;
      this.callWhenReady(() => this.#migrateSettingStorage(`better-moodle-settings.${key}`));
      return this;
    }
    get feature() {
      return this.#feature;
    }
    set feature(feature) {
      if (this.#feature) throw new Error('Cannot reassign feature');
      this.#feature = feature;
      this.#unsavedValue = this.savedValue;
      this.instanceReady();
    }
    get formControl() {
      if (!this.#formControl) throw new Error('Form control not ready');
      return this.#formControl;
    }
    get id() {
      return `${this.#feature?.id ?? ''}.${this.#id}`;
    }
    get name() {
      return this.#id;
    }
    get savedValue() {
      return GM_getValue(this.settingKey, this.#default);
    }
    set savedValue(newVal) {
      GM_setValue(this.settingKey, newVal);
    }
    get value() {
      return this.#formControl?.value ?? this.savedValue;
    }
    get inputID() {
      return domID(this.settingKey);
    }
    get settingKey() {
      return `settings.${this.id}`;
    }
    get Translation() {
      return this.#feature?.Translation.settings[this.#id];
    }
    get title() {
      return this.Translation?.name() ?? this.#id;
    }
    get isNewSetting() {
      if (isNewInstallation) return false;
      const seenSettings2 = new Set(GM_getValue('seenSettings', []));
      if (0 === seenSettings2.size) return false;
      return 0 === seenSettings2.intersection(this.#possibleIDs).size;
    }
    get idMap() {
      return new Map(this.#possibleIDs.values().map(id => [id, this]));
    }
    get formGroup() {
      const descriptionBtn = createElement(
        'button',
        {
          className: 'btn btn-link p-0',
          dataset: {
            container: 'body',
            toggle: 'popover',
            placement: 'right',
            content: this.Translation?.description() ?? this.#id,
            trigger: 'focus',
          },
          tabIndex: 0,
        },
        createElement('i', { className: 'icon fa fa-question-circle text-info fa-fw' })
      );
      descriptionBtn.addEventListener('click', e => e.preventDefault());
      const tags2 = Array.from(this.#tags.values());
      return createElement(
        'div',
        { className: 'form-group row fitem', dataset: { tags: JSON.stringify(tags2), search: this.title } },
        createElement(
          'div',
          { className: 'col-md-5 col-form-label d-flex pb-0 pt-0' },
          createElement(
            'label',
            { className: 'd-inline word-break', htmlFor: this.inputID },
            this.isNewSetting ?
              createElement(
                'span',
                {
                  className: [
                    'badge badge-success text-uppercase d-inline',
                    globalStyle.shining,
                    globalStyle.sparkling,
                    settingsStyle.newSettingBadge,
                  ],
                  dataset: { setting: this.id },
                },
                LL$a.settings.newBadge()
              )
            : '',
            this.#tags.size ?
              createElement(
                Fragment,
                null,
                '[',
                tags2.map(tag => Tag(tag)),
                '] '
              )
            : '',
            this.title
          ),
          createElement(
            'div',
            { className: 'form-label-addon d-flex align-items-center align-self-start' },
            descriptionBtn
          )
        ),
        createElement(
          'div',
          {
            className: 'col-md-7 form-inline align-items-start felement overflow-hidden',
            dataset: { setting: this.id },
          },
          this.formControl
        )
      );
    }
    save() {
      this.savedValue = this.#unsavedValue;
    }
    reset() {
      this.savedValue = this.#default;
      if (this.#formControl) {
        this.#formControl.value = this.savedValue;
        this.#formControl.dispatchEvent(new Event('input'));
      }
    }
    undo() {
      this.#unsavedValue = this.savedValue;
      if (this.#formControl) {
        this.#formControl.value = this.savedValue;
        this.#formControl.dispatchEvent(new Event('input'));
      }
    }
    requireReload() {
      this.#requiresReload = true;
      this.onChange(() => {
        if (this.#unsavedValue === this.savedValue) return;
        require2(
          ['core/toast'],
          ({ add: add2 }) =>
            void add2(mdToHtml(LL$a.settings.requireReload({ name: this.title })), {
              type: 'info',
              autohide: false,
              closeButton: true,
            })
        );
        TempStorage$1.settingsRequireReload = true;
      });
      return this;
    }
    onChange(listener2) {
      this.callWhenReady(() => this.formControl.addEventListener('change', listener2));
      return this;
    }
    onInput(listener2) {
      this.callWhenReady(() => this.formControl.addEventListener('input', listener2));
      return this;
    }
    disabledIf(otherSetting, condition, comparisonValue) {
      const uuid = crypto.randomUUID();
      const check = () => {
        if (!this.#formControl) return;
        const currentValue = otherSetting.value;
        let isDisabled = false;
        switch (condition) {
          case '==':
            isDisabled = currentValue === comparisonValue;
            break;
          case '!=':
            isDisabled = currentValue !== comparisonValue;
        }
        this.#conditionalDisabledStates.set(uuid, isDisabled);
        this.#formControl.disabled = Array.from(this.#conditionalDisabledStates.values()).some(s => s);
      };
      otherSetting.onChange(check);
      this.callWhenReady(() => otherSetting.callWhenReady(check));
      return this;
    }
    addTag(tag) {
      this.#tags.add(tag);
      return this;
    }
  }
  const sliderStyle = { sliderSetting: 'better-moodle_settings-SliderSetting__slider-setting' };
  const GithubLink = ({ path, icon = true, externalIcon = false, className: className2, children, ...props }) =>
    createElement(
      'a',
      {
        href: githubPath(path),
        target: '_blank',
        className: [className2, { [globalStyle.noExternalLinkIcon]: !externalIcon }],
        ...props,
      },
      icon && createElement('i', { className: 'fa fa-github fa-fw' }),
      children
    );
  const NavbarItem = ({ order, children, className: className2, ...props }) => {
    const item = createElement('div', { className: [className2, globalStyle.navbarItem], ...props }, children);
    item.style.setProperty('order', order.toString());
    Object.defineProperty(item, 'put', {
      value: () => ready().then(() => document.getElementById('usernavigation')?.append(item)),
    });
    return item;
  };
  const Switch = ({ id, value }) => {
    const Input = createElement('input', { id, className: 'custom-control-input', type: 'checkbox', checked: value });
    const Switch2 = createElement(
      'div',
      { className: 'custom-control custom-switch' },
      Input,
      createElement('label', { className: 'custom-control-label', htmlFor: id })
    );
    Object.defineProperty(Switch2, 'value', {
      get() {
        return Input.checked;
      },
      set(newVal) {
        Input.checked = newVal;
      },
    });
    Object.defineProperty(Switch2, 'disabled', {
      get() {
        return Input.disabled;
      },
      set(newVal) {
        Input.disabled = newVal;
      },
    });
    return Switch2;
  };
  const TextInput = ({ id, value }) => createElement('input', { id, className: 'form-control', type: 'text', value });
  const Select = ({ id, value, options }) => {
    const Select2 = createElement('select', { id, className: 'custom-select col-12 col-md-auto' });
    const optionsPromise = options instanceof Promise ? options : Promise.resolve(options);
    const optionsToBeTranslated = new Set();
    const waitForOptions = new SimpleReady();
    const loadingOption = createElement('option', { selected: true, disabled: true }, 'Loading...');
    getLoadingSpinner().then(spinner => loadingOption.append(spinner));
    Select2.append(loadingOption);
    optionsPromise
      .then(options2 =>
        options2.forEach(option => {
          let optionValue;
          let title;
          if ('string' === typeof option) {
            optionValue = option;
            title = `settings.${id}.options.${option}`;
          } else {
            optionValue = option.key;
            title = option.title;
          }
          const el = createElement('option', { value: optionValue, selected: optionValue === value }, title);
          Select2.append(el);
          if ('string' === typeof option) optionsToBeTranslated.add(el);
        })
      )
      .then(() => loadingOption.remove())
      .then(() => waitForOptions.ready());
    const translate2 = translations =>
      optionsToBeTranslated.forEach(option => {
        option.textContent = translations.options[option.value]() ?? option.textContent;
      });
    Object.defineProperty(Select2, 'applyTranslations', {
      value: translations => waitForOptions.awaitReady().then(() => translate2(translations)),
    });
    Object.defineProperty(Select2, 'optionsLoaded', { get: () => waitForOptions.instanceIsReady });
    return Select2;
  };
  const Slider = ({ id, value, min, max, step = 1, labels = (max - min + 1) / step }) => {
    const datalistId = `${id}-datalist`;
    const Input = createElement('input', {
      id,
      className: 'form-control-range custom-range',
      type: 'range',
      min,
      max,
      step,
      list: datalistId,
      value,
    });
    const Output = createElement('output', { htmlFor: id }, value);
    const setOutput = () => {
      const value2 = Number(Input.value);
      const percentageValue = ((value2 - min) / (max - min)) * 100;
      Output.textContent = valueToLabel.get(value2) ?? stringify$1(value2);
      Output.style.setProperty('--percentage', percentageValue.toString());
    };
    const datalist = createElement('datalist', { id: datalistId });
    const steps = (max - min + 1) / step;
    for (let currentStep = min; currentStep <= max; currentStep += (max - min + 1) / steps) {
      datalist.append(createElement('option', { value: currentStep }, currentStep));
    }
    const fixLabels = Array.isArray(labels);
    const labelCount = Array.isArray(labels) ? labels.length : Math.max(2, Math.min(10, labels));
    const valueToLabel = new Map();
    const labelDatalist = createElement('datalist', { style: { '--label-count': labelCount } });
    const Slider2 = createElement(
      'div',
      { className: ['w-100 position-relative', sliderStyle.sliderSetting] },
      Input,
      Output,
      datalist,
      labelDatalist
    );
    Object.defineProperty(Slider2, 'value', {
      get() {
        return Number(Input.value);
      },
      set(newVal) {
        Input.value = newVal.toString();
        setOutput();
      },
    });
    Object.defineProperty(Slider2, 'disabled', {
      get() {
        return Input.disabled;
      },
      set(newVal) {
        Input.disabled = newVal;
      },
    });
    Object.defineProperty(Slider2, 'applyTranslations', {
      value: translations => {
        if (!translations) return;
        for (let currentStep = min; currentStep <= max; currentStep += (max - min) / (labelCount - 1)) {
          if (fixLabels) {
            const label = labels.shift();
            valueToLabel.set(currentStep, translations[label]?.() ?? label);
          }
          const title = valueToLabel.get(currentStep) ?? stringify$1(currentStep);
          labelDatalist.append(createElement('option', { value: currentStep, title, label: title }));
        }
        Output.textContent = valueToLabel.get(value) ?? stringify$1(value);
      },
    });
    Input.addEventListener('input', setOutput);
    Slider2.value = value;
    return Slider2;
  };
  const FieldSet = ({
    title,
    description = '',
    id = crypto.randomUUID(),
    collapsed = true,
    children = document.createDocumentFragment().children,
  }) => {
    const FieldSet2 = createElement('fieldset', null);
    let container;
    let heading;
    const waitForContainer = new SimpleReady();
    requirePromise(['core/templates']).then(([templates]) =>
      templates
        .renderForPromise('core_form/element-header', { header: title, id: PREFIX(id), collapseable: true, collapsed })
        .then(({ html }) => FieldSet2.append(...Array.from(htmlToElements(html))))
        .then(() => {
          container = FieldSet2.querySelector('.fcontainer');
          container?.append(
            createElement(
              Fragment,
              null,
              description && createElement('p', { className: 'p-12' }, htmlToElements(mdToHtml(description))),
              children
            )
          );
          heading = FieldSet2.querySelector('h3');
          waitForContainer.ready();
        })
    );
    Object.defineProperty(FieldSet2, 'appendToContainer', {
      value: (...args) => waitForContainer.awaitReady().then(() => container?.append(...args)),
    });
    Object.defineProperty(FieldSet2, 'heading', { value: waitForContainer.awaitReady().then(() => heading) });
    Object.defineProperty(FieldSet2, 'toggle', {
      value: () => FieldSet2.querySelector('[data-toggle="collapse"]')?.click(),
    });
    Object.defineProperty(FieldSet2, 'awaitReady', { value: () => waitForContainer.awaitReady() });
    return FieldSet2;
  };
  class BooleanSetting extends Setting {
    constructor(id, defaultValue) {
      super(id, defaultValue, Switch, {});
    }
  }
  class FeatureGroup {
    static register({ settings: settings2 = new Set(), features: features2 = new Set(), ...methods }) {
      return class FeatureGroup extends this {
        constructor(id) {
          super(id, settings2 ?? new Set(), methods);
        }
        loadFeatures(loadFn) {
          if (this.#features.size) throw Error('Features already loaded');
          if (!features2) return;
          const formGroups = new Set();
          for (const id of features2) {
            const feature = loadFn(id);
            if (feature) {
              feature.load();
              this.#features.add(feature);
              feature.formGroups.forEach(formGroup => formGroups.add(formGroup));
            }
          }
          this.#FieldSet.appendToContainer(...formGroups);
          if (this.hasNewSetting) {
            this.#FieldSet.heading.then(heading =>
              heading?.append(
                createElement(
                  'span',
                  {
                    className: [
                      'badge badge-success text-uppercase',
                      globalStyle.shining,
                      globalStyle.sparkling,
                      settingsStyle.newSettingBadge,
                    ],
                  },
                  LL$a.settings.newBadge()
                )
              )
            );
          }
        }
      };
    }
    #id;
    #settings;
    #onload;
    #onunload;
    #features = new Set();
    #FieldSet;
    #settingsLoaded = false;
    #loaded = false;
    constructor(id, settings2, methods) {
      this.#id = id;
      this.#settings = settings2;
      this.#onload = methods.onload;
      this.#onunload = methods.onunload;
      this.#FieldSet = FieldSet({
        id: `settings-fieldset-${this.id}`,
        title: this.title,
        description: this.description,
        collapsed: 'general' !== id,
      });
    }
    loadSettings() {
      if (this.#settingsLoaded) throw new Error('Settings for this FeatureGroup are already loaded!');
      this.#settingsLoaded = true;
      const formGroups = this.#settings.values().map(setting => {
        setting.feature = this;
        return setting.formGroup;
      });
      this.#FieldSet.appendToContainer(...formGroups);
    }
    get id() {
      return this.#id;
    }
    get FieldSet() {
      return this.#FieldSet;
    }
    get Translation() {
      return LL$a.features[this.id];
    }
    get title() {
      return this.Translation.name();
    }
    get description() {
      return 'description' in this.Translation ? this.Translation.description() : '';
    }
    get hasNewSetting() {
      return (
        this.#settings.values().some(setting => setting.isNewSetting) ||
        this.#features.values().some(feature => feature.hasNewSetting)
      );
    }
    get settingIDs() {
      return [
        ...this.#settings.values().map(setting => setting.id),
        ...this.#features.values().flatMap(feature => feature.settingIDs),
      ];
    }
    get settingIDMap() {
      return new Map([
        ...this.#settings.values().flatMap(setting => setting.idMap.entries()),
        ...this.#features.values().flatMap(feature => feature.settingIDMap.entries()),
      ]);
    }
    load() {
      if (this.#loaded) throw Error(`FeatureGroup ${this.id} already loaded.`);
      this.#loaded = true;
      this.#onload?.();
    }
    unload() {
      if (!this.#loaded) throw Error(`FeatureGroup ${this.id} already unloaded.`);
      this.#loaded = false;
      this.#onunload?.();
    }
    reload() {
      this.unload();
      this.load();
    }
    resetSettings() {
      this.#settings.forEach(setting => setting.reset());
      this.#features.forEach(feature => feature.resetSettings());
    }
    undoSettings() {
      this.#settings.forEach(setting => setting.undo());
      this.#features.forEach(feature => feature.undoSettings());
    }
    saveSettings() {
      this.#settings.forEach(setting => setting.save());
      this.#features.forEach(feature => feature.saveSettings());
    }
  }
  const modalStyle = {
    modalBackgroundImage: 'better-moodle_modal__modal-background-image',
    modalTrigger: 'better-moodle_modal__modal-trigger',
  };
  const TypeTo403Lib = {
    ALERT: 'core/local/modal/alert',
    CANCEL: 'core/modal_cancel',
    DEFAULT: 'core/modal',
    SAVE_CANCEL: 'core/modal_save_cancel',
  };
  class Modal extends CanBeReady {
    #config;
    #savedFooter;
    #modal;
    #modalEvents;
    #triggers = new Map();
    constructor(config) {
      super();
      this.#config = config;
      if (config.footer) {
        this.#savedFooter = config.footer;
        delete this.#config.footer;
      }
      this.#create();
      if (config.backgroundImage) this.setBackgroundImage();
    }
    async #onReady() {
      super.instanceReady();
      await this.#prependFooter();
      if (this.#config.bodyClass) {
        await this.getBody().then(([body]) => body.classList.add(...className(this.#config.bodyClass).split(' ')));
      }
    }
    async #prependFooter() {
      if (!this.#savedFooter || !this.instanceIsReady) return;
      this.#modal.getFooter().prepend(await this.#savedFooter);
    }
    async #create() {
      const { promise, resolve } = Promise.withResolvers();
      require2([TypeTo403Lib[this.#config.type], 'core/modal_events'], (modalClass, modalEvents) => {
        this.#modalEvents = modalEvents;
        modalClass.create(this.#config).then(resolve);
      });
      this.#modal = await promise;
      await this.#onReady();
    }
    show() {
      this.callWhenReady(() => this.#modal.show()).catch(console.error);
      return this;
    }
    hide() {
      this.callWhenReady(() => this.#modal.hide()).catch(console.error);
      return this;
    }
    onReady(callback) {
      this.callWhenReady(callback);
      return this;
    }
    on(Event2, callback) {
      this.callWhenReady(() => this.#modal.getRoot().on(this.#modalEvents[Event2], callback));
      return this;
    }
    onShown(callback) {
      return this.on('shown', callback);
    }
    onSave(callback) {
      return this.on('save', callback);
    }
    onCancel(callback) {
      return this.on('cancel', callback);
    }
    onHidden(callback) {
      return this.on('hidden', callback);
    }
    setTrigger(trigger) {
      trigger.classList.add(modalStyle.modalTrigger);
      const triggerFn = e => {
        e.preventDefault();
        this.show();
      };
      trigger.addEventListener('click', triggerFn);
      this.#triggers.set(trigger, triggerFn);
      return this;
    }
    unsetTrigger(trigger) {
      const triggerFn = this.#triggers.get(trigger);
      if (triggerFn) {
        trigger.classList.remove(modalStyle.modalTrigger);
        trigger.removeEventListener('click', triggerFn);
        this.#triggers.delete(trigger);
      }
      return this;
    }
    getTitle() {
      return this.callWhenReady(() => this.#modal.getTitle());
    }
    getBody() {
      const { promise, resolve, reject } = Promise.withResolvers();
      this.callWhenReady(async () => await this.#modal.getBodyPromise().then(resolve, reject));
      return promise;
    }
    getFooter() {
      return this.callWhenReady(() => this.#modal.getFooter());
    }
    getHeader() {
      return this.callWhenReady(() => this.#modal.header[0]);
    }
    setBackgroundImage(src = this.#config.backgroundImage) {
      if (!src) return;
      this.getHeader().then(header =>
        header.before(
          createElement('img', { 'className': modalStyle.modalBackgroundImage, src, 'aria-hidden': true, 'alt': '' })
        )
      );
    }
  }
  const renderCustomTemplate = (name, template, context) =>
    requirePromise(['core/localstorage', 'core/templates', 'core/config']).then(
      async ([storage, templates, config]) => {
        await mdlJSComplete('core/storage_validation');
        const templateName = `better-moodle/${name}`;
        storage.set(`core_template/${config.templaterev}:${config.theme}/${templateName}`, template);
        return templates.renderForPromise(templateName, context);
      }
    );
  const render = (templateName, context, themeName) =>
    requirePromise(['core/templates']).then(([templates]) =>
      templates.renderForPromise(templateName, context, themeName)
    );
  const style$7 = {
    dropdown: 'better-moodle_bookmarks__dropdown',
    form: 'better-moodle_bookmarks__form',
    editForm: 'better-moodle_bookmarks__edit-form',
  };
  const LL$9 = LLFG('bookmarks');
  const enabled$g = new BooleanSetting('enabled', false).addAlias('general.bookmarkManager');
  const oldValue = GM_getValue('better-moodle-bookmarks');
  if (oldValue) {
    GM_setValue('bookmarks.list', oldValue);
    GM_deleteValue('better-moodle-bookmarks');
  }
  const bookmarks = GM_getValue('bookmarks.list', []).map(bookmark => ({
    ...bookmark,
    url: bookmark.url.startsWith('https://') ? bookmark.url : `https://${bookmark.url}`,
  }));
  const saveBookmarks = () => {
    GM_setValue('bookmarks.list', bookmarks);
    require2(
      ['core/toast'],
      ({ add: add2 }) => void add2(LL$9.savedNotification(), { type: 'success', autohide: true, closeButton: true })
    );
  };
  GM_addValueChangeListener('bookmarks.list', (_, __, newBookmarks) => {
    if (!enabled$g.value) return;
    bookmarks.splice(0, bookmarks.length, ...newBookmarks);
    renderDropdown();
  });
  const navbarItemTemplate = createElement('i', { className: 'icon fa fa-bookmark-o fa-fw mr-0', role: 'img' });
  let navbarItem$1 = null;
  const EditRow = ({ title = '', url = '', controls = true, index = 0 }) => {
    const titleInput = createElement('input', {
      className: 'form-control',
      type: 'text',
      placeholder: '',
      value: title.trim(),
    });
    const urlInput = createElement('input', {
      className: 'form-control',
      type: 'url',
      placeholder: '',
      value: url
        .trim()
        .replace(/^https:\/\//, '')
        .trim(),
    });
    const urlInputGroup = createElement(
      'div',
      { className: 'input-group' },
      createElement(
        'div',
        { className: 'input-group-prepend' },
        createElement('span', { className: 'input-group-text' }, 'https://')
      ),
      urlInput
    );
    const controlsGroup =
      controls ?
        createElement(
          'div',
          { className: 'btn-group ml-auto', dataset: { index: index.toString() } },
          createElement(
            'button',
            { className: 'btn btn-outline-secondary', dataset: { action: 'up' } },
            createElement('i', { className: 'fa fa-arrow-up fa-fw' })
          ),
          createElement(
            'button',
            { className: 'btn btn-outline-secondary', dataset: { action: 'down' } },
            createElement('i', { className: 'fa fa-arrow-down fa-fw' })
          ),
          createElement(
            'button',
            { className: 'btn btn-outline-danger', dataset: { action: 'delete' } },
            createElement('i', { className: 'fa fa-trash fa-fw' })
          )
        )
      : null;
    const Row = createElement(Fragment, null, titleInput, urlInputGroup, controlsGroup);
    let _index = index;
    Object.defineProperty(Row, 'title', {
      get() {
        return titleInput.value.trim();
      },
    });
    Object.defineProperty(Row, 'url', {
      get() {
        const input = urlInput.value.trim();
        if (input.startsWith('https://')) return input;
        return `https://${input}`;
      },
    });
    Object.defineProperty(Row, 'index', {
      get() {
        return _index;
      },
      set(newVal) {
        _index = newVal;
        if (controlsGroup) controlsGroup.dataset.index = _index.toString();
      },
    });
    Object.defineProperty(Row, 'elements', { value: [titleInput, urlInputGroup, controlsGroup] });
    Object.defineProperty(Row, 'remove', { value: () => Row.elements.forEach(el => el?.remove()) });
    Object.defineProperty(Row, 'before', { value: (...elements) => Row.elements.at(0)?.before(...elements) });
    return Row;
  };
  const openAddModal = () => {
    const input = createElement(EditRow, { title: document.title, url: window.location.href, controls: false });
    new Modal({
      type: 'SAVE_CANCEL',
      title: LL$9.add(),
      body: createElement(
        'form',
        { className: ['mform', style$7.form, style$7.editForm] },
        createElement(
          'div',
          { className: 'fcontainer' },
          createElement('b', null, LL$9.modal.title()),
          createElement('b', null, LL$9.modal.url()),
          input
        )
      ),
      large: true,
      removeOnClose: true,
    })
      .onSave(() => {
        bookmarks.push({ title: input.title, url: input.url });
        saveBookmarks();
      })
      .show();
  };
  const openEditModal = () => {
    const inputs = new Map();
    bookmarks.forEach((bookmark, i) =>
      inputs.set(i, createElement(EditRow, { title: bookmark.title, url: bookmark.url, index: i }))
    );
    const container = createElement(
      'div',
      { className: 'fcontainer' },
      createElement('b', null, LL$9.modal.title()),
      createElement('b', null, LL$9.modal.url()),
      createElement('div', { className: 'd-none d-sm-block' }),
      ...Array.from(inputs.values())
    );
    container.addEventListener('click', e => {
      const target = e.target;
      if (!(target instanceof Element)) return;
      const btn = target.closest('button[data-action]');
      const indexStr = btn?.closest('[data-index]')?.dataset.index;
      const action = btn?.dataset.action;
      if (!indexStr || !action) return;
      const index = Number(indexStr);
      const row = inputs.get(index);
      if (!row) return;
      e.preventDefault();
      if ('delete' === action) {
        row.remove();
        inputs.delete(index);
        const inputArray = Array.from(inputs.values());
        inputs.clear();
        inputArray.forEach((row2, i) => {
          row2.index = i;
          inputs.set(i, row2);
        });
      } else if ('up' === action) {
        const prevRow = inputs.get(index - 1);
        if (prevRow) {
          [prevRow.index, row.index] = [row.index, prevRow.index];
          prevRow.before(...row.elements);
          inputs.set(index, prevRow);
          inputs.set(index - 1, row);
        }
      } else if ('down' === action) {
        const nextRow = inputs.get(index + 1);
        if (nextRow) {
          [nextRow.index, row.index] = [row.index, nextRow.index];
          row.before(...nextRow.elements);
          inputs.set(index, nextRow);
          inputs.set(index + 1, row);
        }
      }
    });
    const addBtn = createElement(
      'button',
      { className: 'btn btn-outline-success pull-right' },
      createElement('i', { className: 'fa fa-plus fa-fw' })
    );
    addBtn.addEventListener('click', e => {
      e.preventDefault();
      const newInput = createElement(EditRow, { title: document.title, url: window.location.href, index: inputs.size });
      inputs.set(inputs.size, newInput);
      container.append(newInput);
    });
    new Modal({
      type: 'SAVE_CANCEL',
      title: LL$9.edit(),
      body: createElement('form', { className: ['mform', style$7.form] }, container, addBtn),
      large: true,
      removeOnClose: true,
    })
      .onSave(() => {
        bookmarks.splice(
          0,
          bookmarks.length,
          ...Array.from(inputs.values())
            .toSorted((a, b) => a.index - b.index)
            .map(({ title, url }) => ({ title, url }))
        );
        saveBookmarks();
      })
      .show();
  };
  const preprocessBookmarkIcon = ([item]) => {
    item.id = style$7.dropdown;
    item.classList.add(globalStyle.navbarItem);
    item.style.setProperty('order', '900');
    item.style.setProperty('--empty-text', JSON.stringify(LL$9.empty()));
  };
  const renderDropdown = () =>
    render('core/custom_menu_item', {
      title: LL$9.bookmarks(),
      text: getHtml(navbarItemTemplate),
      haschildren: true,
      children: [
        ...bookmarks.map(bookmark => ({ ...bookmark, text: bookmark.title })),
        { divider: true },
        { url: '#addBookmark', title: LL$9.add(), text: LL$9.add() },
        { url: '#editBookmarks', title: LL$9.edit(), text: LL$9.edit() },
      ],
    })
      .then(template =>
        navbarItem$1 ?
          putTemplate(navbarItem$1, template, 'replaceWith', preprocessBookmarkIcon)
        : ready().then(() => putTemplate('#usernavigation', template, 'append', preprocessBookmarkIcon))
      )
      .then(([item]) => {
        navbarItem$1 = item;
        const currentPage = new URL(window.location.href);
        currentPage.hash = '';
        if (
          bookmarks.some(({ url }) => {
            const urlWithoutHash = new URL(url);
            urlWithoutHash.hash = '';
            return currentPage.href.includes(urlWithoutHash.href);
          })
        ) {
          navbarItem$1.querySelector('.fa-bookmark-o')?.classList.replace('fa-bookmark-o', 'fa-bookmark');
        }
        navbarItem$1.addEventListener('click', e => {
          const target = e.target;
          if (!(target instanceof HTMLElement)) return;
          if (target.closest('a[href*="#addBookmark"]')) {
            e.preventDefault();
            openAddModal();
          }
          if (target.closest('a[href*="#editBookmarks"]')) {
            e.preventDefault();
            openEditModal();
          }
        });
      })
      .catch(() => {});
  const reload$f = () => {
    if (enabled$g.value) {
      navbarItem$1 ??= createElement(
        NavbarItem,
        { order: 900 },
        createElement('div', { className: `${globalStyle.awaitsDropdown} nav-link` }, navbarItemTemplate)
      );
      if (!(navbarItem$1 instanceof HTMLLIElement)) navbarItem$1.put();
      renderDropdown();
    } else {
      navbarItem$1?.remove();
      navbarItem$1 = null;
    }
  };
  enabled$g.onInput(() => void reload$f());
  const __vite_glob_0_0 = FeatureGroup.register({
    settings: new Set([enabled$g]),
    onload: reload$f,
    onunload: reload$f,
  });
  const features$3 = new Set([
    'cardsPerRow',
    'navbarDropdown',
    'grades',
    'images',
    'quickRoleChange',
    'noDownload',
    'sectionCourseIndex',
    'hideSelfEnrolHint',
  ]);
  const __vite_glob_0_1 = FeatureGroup.register({ features: features$3 });
  importCSS(
    'html[data-darkreader-scheme=dark] .navbar.fixed-top .navbar-brand .logo,\nhtml[data-darkreader-scheme=dark] #logoimage {\n  filter: brightness(500%);\n}'
  );
  class SelectSetting extends Setting {
    constructor(id, defaultValue, options) {
      super(id, defaultValue, Select, { options });
      this.callWhenReady(() => this.formControl.applyTranslations(this.Translation));
    }
    get value() {
      if (this.formControl.optionsLoaded) return this.formControl.value;
      return this.savedValue;
    }
  }
  class SliderSetting extends Setting {
    constructor(id, defaultValue, params) {
      super(id, defaultValue, Slider, params);
      this.callWhenReady(() => this.formControl.applyTranslations(this.Translation.labels));
    }
    migrateStoredValue(oldValue2) {
      return this.migrator?.(oldValue2) ?? Number(oldValue2);
    }
  }
  const updateDarkReaderMode = () => {
    if ('off' === mode.value) {
      DarkReader.auto(false);
      DarkReader.disable();
      return;
    }
    const darkReaderSettings = {
      brightness: brightness.value,
      contrast: contrast.value,
      grayscale: grayscale.value,
      sepia: sepia.value,
    };
    const themeFix = {
      css: '.eye {\n  background-color: white;\n}\n\n.activity-item.hiddenactivity .description .course-description-item,\n.activity-item.hiddenactivity .activityiconcontainer,\n.activity-item.hiddenactivity .badge,\n.editing .activity-item:hover .activityiconcontainer,\n.editing .activity-item:hover .description .course-description-item,\n.editing .activity-item:hover .activityiconcontainer,\n.editing .activity-item:hover .badge,\n.path-mod .automatic-completion-conditions .badge {\n  mix-blend-mode: hard-light !important;\n}',
      invert: [],
      disableStyleSheetsProxy: false,
      ignoreImageAnalysis: [],
      ignoreInlineStyle: [],
    };
    if ('auto' === mode.value) DarkReader.auto(darkReaderSettings, themeFix);
    else {
      DarkReader.auto(false);
      DarkReader.enable(darkReaderSettings, themeFix);
    }
  };
  const debouncedUpdateDarkReaderMode = debounce(updateDarkReaderMode, 100);
  const mode = new SelectSetting('mode', 'off', ['off', 'on', 'auto'])
    .addAlias('darkmode.mode')
    .onChange(debouncedUpdateDarkReaderMode);
  const brightness = new SliderSetting('brightness', 100, { min: 0, max: 150, step: 1, labels: 7 })
    .addAlias('darkmode.brightness')
    .disabledIf(mode, '==', 'off')
    .onChange(debouncedUpdateDarkReaderMode);
  const contrast = new SliderSetting('contrast', 100, { min: 0, max: 150, step: 1, labels: 7 })
    .addAlias('darkmode.contrast')
    .disabledIf(mode, '==', 'off')
    .onChange(debouncedUpdateDarkReaderMode);
  const grayscale = new SliderSetting('grayscale', 0, { min: 0, max: 100, step: 1, labels: 6 })
    .addAlias('darkmode.grayscale')
    .disabledIf(mode, '==', 'off')
    .onChange(debouncedUpdateDarkReaderMode);
  const sepia = new SliderSetting('sepia', 0, { min: 0, max: 100, step: 1, labels: 6 })
    .addAlias('darkmode.sepia')
    .disabledIf(mode, '==', 'off')
    .onChange(debouncedUpdateDarkReaderMode);
  const settings$3 = new Set([mode, brightness, contrast, grayscale, sepia]);
  const __vite_glob_0_2 = FeatureGroup.register({
    settings: settings$3,
    onload: () =>
      void Promise.all(Array.from(settings$3.values()).map(setting => setting.awaitReady())).then(updateDarkReaderMode),
  });
  const features$2 = new Set(['layout']);
  const __vite_glob_0_3 = FeatureGroup.register({ features: features$2 });
  const updateNotification = new BooleanSetting('updateNotification', true).addAlias('general.updateNotification');
  const languageSetting = new SelectSetting('language', 'auto', [
    'auto',
    ...Array.from(languages.entries()).map(([locale, { name, flag }]) => ({ key: locale, title: `${flag} ${name}` })),
  ])
    .addAlias('general.language')
    .requireReload();
  const highlightNewSettings = new BooleanSetting('newSettings.highlight', true).addAlias(
    'general.highlightNewSettings'
  );
  const newSettingsTooltip$1 = new BooleanSetting('newSettings.tooltip', true)
    .addAlias('general.highlightNewSettings.navbar')
    .requireReload();
  const updateDisabledHiddenState = () =>
    void hideDisabledSettings
      .awaitReady()
      .then(() => document.body.classList.toggle(settingsStyle.hideDisabledSettings, hideDisabledSettings.value));
  const hideDisabledSettings = new BooleanSetting('hideDisabledSettings', true).onInput(updateDisabledHiddenState);
  const updateFunSettingsHiddenState = () =>
    void hideFunSettings
      .awaitReady()
      .then(() => document.body.classList.toggle(settingsStyle.hideFunSettings, hideFunSettings.value));
  const hideFunSettings = new BooleanSetting('hideFunSettings', true).onInput(updateFunSettingsHiddenState);
  const features$1 = new Set([
    'fullWidth',
    'externalLinks',
    'truncatedTexts',
    'leftSecondaryNav',
    'prideLogo',
    'googlyEyes',
  ]);
  const updateAllStates = () => {
    updateDisabledHiddenState();
    updateFunSettingsHiddenState();
  };
  const __vite_glob_0_4 = FeatureGroup.register({
    settings: new Set([
      updateNotification,
      languageSetting,
      highlightNewSettings,
      newSettingsTooltip$1,
      hideDisabledSettings,
      hideFunSettings,
    ]),
    features: features$1,
    onload: updateAllStates,
    onunload: updateAllStates,
  });
  const settings$2 = new Set();
  const mail = new BooleanSetting('mail', true).onInput(() => onload$8());
  const phone = new BooleanSetting('phone', true).onInput(() => onload$8());
  settings$2.add(mail).add(phone);
  let mailStyle;
  let phoneStyle;
  const onload$8 = () => {
    if (mail.value) {
      if (mailStyle) document.head.append(mailStyle);
      else {
        mailStyle = GM_addStyle(
          'body.dir-ltr a[href^="mailto:"]:not(:has(.fa-envelope))::before, body.dir-rtl a[href^="mailto:"]:not(:has(.fa-envelope))::after {\n  display: var(--fa-display, inline-block);\n  font-style: normal;\n  font-feature-settings: normal;\n  font-variant: normal;\n  line-height: 1;\n  text-rendering: auto;\n  font-family: var(--fa-style-family, "Font Awesome 6 Free");\n  font-weight: var(--fa-style, 900);\n  content: "\\f003" !important;\n  display: inline;\n}\nbody.dir-ltr a[href^="mailto:"]:not(:has(.fa-envelope))::before {\n  padding-right: 0.25rem;\n}\nbody.dir-rtl a[href^="mailto:"]:not(:has(.fa-envelope))::after {\n  padding-left: 0.25rem;\n}'
        );
      }
    } else mailStyle?.remove();
    if (phone.value) {
      if (phoneStyle) document.head.append(phoneStyle);
      else {
        phoneStyle = GM_addStyle(
          'body.dir-ltr a[href^="tel:"]:not(:has(.fa-phone))::before, body.dir-rtl a[href^="tel:"]:not(:has(.fa-phone))::after {\n  display: var(--fa-display, inline-block);\n  font-style: normal;\n  font-feature-settings: normal;\n  font-variant: normal;\n  line-height: 1;\n  text-rendering: auto;\n  font-family: var(--fa-style-family, "Font Awesome 6 Free");\n  font-weight: var(--fa-style, 900);\n  content: "\\f095" !important;\n  display: inline;\n}\nbody.dir-ltr a[href^="tel:"]:not(:has(.fa-phone))::before {\n  padding-right: 0.25rem;\n}\nbody.dir-rtl a[href^="tel:"]:not(:has(.fa-phone))::after {\n  padding-left: 0.25rem;\n}'
        );
      }
    } else phoneStyle?.remove();
  };
  const __vite_glob_0_5 = FeatureGroup.register({ settings: settings$2, onload: onload$8 });
  const features = new Set(['markdownSupport', 'sendHotkey']);
  const __vite_glob_0_6 = FeatureGroup.register({ features });
  const breakpoints = Object.fromEntries(
    JSON.parse('"xs: 0; sm: 576px; md: 768px; lg: 992px; xl: 1200px"')
      .split(';')
      .map(i => {
        const [key, val] = i.split(':');
        return [key.trim(), parseFloat(val)];
      })
  );
  const marqueeStyle = {
    marquee: 'better-moodle_marquee__marquee',
    marqueeMinWidthPlaceholder: 'better-moodle_marquee__marquee-min-width-placeholder',
  };
  const marquee = new (class Marquee {
    #parentSelector;
    #parentPosition;
    #parent = null;
    #getMaxWidth = null;
    #span = document.createElement('span');
    #cloneSpan = document.createElement('span');
    #content = createElement(
      'div',
      { className: [marqueeStyle.marquee, 'd-flex align-items-center'] },
      this.#span,
      this.#cloneSpan
    );
    recalculate = debounce(() => this.#recalculate());
    #observer = new ResizeObserver(this.recalculate);
    #observedElements = new Set();
    #minWidthPlaceholder = createElement('div', { className: marqueeStyle.marqueeMinWidthPlaceholder });
    #contentClones = new Map();
    constructor(parentSelector, position) {
      this.#parentSelector = parentSelector;
      this.#parentPosition = position;
      this.#observer.observe(this.#span);
    }
    async #put() {
      await ready();
      this.#parent = document.querySelector(this.#parentSelector);
      if (!this.#parent) return;
      this.#parent[this.#parentPosition](this.#minWidthPlaceholder, this.#content);
      this.recalculate();
      this.#observer.observe(this.#parent);
      this.#observedElements.forEach(el => this.#observer.observe(el));
      window.dispatchEvent(new Event('resize'));
    }
    #remove() {
      this.#parent = null;
      this.#content.remove();
      this.#minWidthPlaceholder.remove();
      this.#observer.disconnect();
    }
    setMaxWidthFunction(maxWidthFn) {
      this.#getMaxWidth = maxWidthFn;
      this.recalculate();
    }
    get #maxWidth() {
      if (!this.#parent) return 0;
      return this.#getMaxWidth?.() ?? parseFloat(getComputedStyle(this.#parent).width);
    }
    add(...els) {
      const clones = els.map(el => {
        this.remove(el);
        const clone = el.cloneNode(true);
        this.#span.append(el);
        this.#cloneSpan.append(clone);
        this.#contentClones.set(el, clone);
        return [el, clone];
      });
      if (!this.#parent) this.#put();
      this.recalculate();
      return clones;
    }
    remove(el) {
      el.remove();
      this.#contentClones.get(el)?.remove();
      this.#contentClones.delete(el);
      this.recalculate();
      if (0 === this.#contentClones.size) this.#remove();
    }
    observe(el) {
      if (!el) return;
      if (this.#parent) this.#observer.observe(el);
      this.#observedElements.add(el);
    }
    #recalculate() {
      const maxWidth2 = Math.floor(this.#maxWidth);
      const textWidth = Math.round(parseFloat(getComputedStyle(this.#span).width));
      this.#content.style.setProperty('--max-width', `${maxWidth2}px`);
      this.#content.style.setProperty('--text-width', textWidth.toString());
      if (this.#parent) {
        this.#content.style.setProperty('--parent-left', `${Math.round(this.#parent.getBoundingClientRect().left)}px`);
      }
      if (textWidth > maxWidth2) this.#span.dataset.rolling = '';
      else delete this.#span.dataset.rolling;
    }
    setSpeed(speed2) {
      const msPerPx = [0, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50][speed2];
      this.#content.style.setProperty('--text-speed', msPerPx.toString());
    }
  })('#usernavigation', 'prepend');
  const speed = new SliderSetting('speed', 5, { min: 0, max: 10, step: 1, labels: 3 }).onInput(() =>
    marquee.setSpeed(speed.value)
  );
  ready().then(() => {
    const userNav = document.getElementById('usernavigation');
    if (!userNav) return;
    marquee.setMaxWidthFunction(() =>
      window.innerWidth < breakpoints.md ?
        window.innerWidth
      : parseFloat(getComputedStyle(userNav).marginLeft) +
        (document.querySelector(`.${marqueeStyle.marqueeMinWidthPlaceholder}`)?.getBoundingClientRect().width ?? 0)
    );
    marquee.observe(document.querySelector('.primary-navigation'));
    marquee.observe(userNav.parentElement);
  });
  const __vite_glob_0_7 = FeatureGroup.register({
    settings: new Set([speed]),
    features: new Set(['eventAdvertisements', 'clock', 'christmasCountdown']),
  });
  const style$6 = { unseen: 'better-moodle_nina__unseen', spin: 'better-moodle_nina__spin' };
  const LL$8 = LLFG('nina');
  const arsToCountyLevel = ars => `${ars.substring(0, 5)}0000000`;
  const providerById = alertId => alertId.substring(0, 3).toLowerCase();
  const getProviderLabel = provider2 => LL$8.provider[provider2]();
  const getProviderCategory = provider2 => {
    switch (provider2) {
      case 'mow':
      case 'kat':
      case 'biw':
        return 'civilProtection';
      case 'pol':
        return 'police';
      case 'dwd':
        return 'weather';
      case 'lhp':
        return 'flood';
    }
  };
  const getProviderIcon = (provider2, canceling = false) => {
    const providerCategory = getProviderCategory(provider2);
    return `https://nina.api.proxy.bund.dev/assets/icons/${
      'civilProtection' === providerCategory ?
        !canceling ? 'report_mowas'
        : 'report_mowas_all_clear'
      : 'police' === providerCategory ?
        !canceling ? 'polizei_rund'
        : 'report_polizei_all_clear'
      : 'weather' === providerCategory ? 'report_unwetterwarnung'
      : 'flood' === providerCategory ? 'report_hochwasser'
      : ''
    }.svg`;
  };
  const getAlertInfoAttribute = (alert, attribute2) => {
    let hierarchy = 0;
    let relevantInfo = null;
    alert.info?.some(info => {
      if (!info[attribute2]) return false;
      const lang = (info.language ?? 'en-US').toLowerCase();
      if (hierarchy < 1 && null === relevantInfo) {
        relevantInfo = info;
        hierarchy++;
      }
      if (hierarchy < 2 && lang.substring(0, 2) === BETTER_MOODLE_LANG.substring(0, 2).toLowerCase()) {
        relevantInfo = info;
        hierarchy++;
      }
      if (hierarchy < 3 && lang === BETTER_MOODLE_LANG.toLowerCase()) {
        relevantInfo = info;
        hierarchy++;
        return true;
      }
      return false;
    });
    return relevantInfo?.[attribute2] ?? null;
  };
  const searchForAlertInfoParameter = (parameters, parameterName) =>
    parameters.find(param => param.valueName === parameterName)?.value ?? null;
  const getAlertInfoParameter = (alert, parameterName) => {
    let hierarchy = 0;
    let relevantValue = null;
    alert.info?.some(info => {
      const parameter = searchForAlertInfoParameter(info.parameter ?? [], parameterName);
      if (!parameter) return false;
      const lang = (info.language ?? 'en-US').toLowerCase();
      if (hierarchy < 1 && null === relevantValue) {
        relevantValue = parameter;
        hierarchy++;
      }
      if (hierarchy < 2 && lang.substring(0, 2) === BETTER_MOODLE_LANG.substring(0, 2).toLowerCase()) {
        relevantValue = parameter;
        hierarchy++;
      }
      if (hierarchy < 3 && lang === BETTER_MOODLE_LANG.toLowerCase()) {
        relevantValue = parameter;
        hierarchy++;
        return true;
      }
      return false;
    });
    return relevantValue;
  };
  const getAlertTitle = alert => getAlertInfoAttribute(alert, 'headline') ?? getAlertInfoAttribute(alert, 'event');
  const getAlertReferences = alert =>
    alert.references
      ?.split(' ')
      .map(ref => ref.split(','))
      .map(ref => ({ sender: ref[0], alertId: ref[1], sent: ref[2] })) ?? [];
  var URGENCY = (URGENCY2 => {
    URGENCY2.UNKNOWN = 'Unknown';
    URGENCY2.PAST = 'Past';
    URGENCY2.FUTURE = 'Future';
    URGENCY2.EXPECTED = 'Expected';
    URGENCY2.IMMEDIATE = 'Immediate';
    return URGENCY2;
  })(URGENCY || {});
  var MESSAGE_TYPE = (MESSAGE_TYPE2 => {
    MESSAGE_TYPE2.ACK = 'Ack';
    MESSAGE_TYPE2.ALERT = 'Alert';
    MESSAGE_TYPE2.CANCEL = 'Cancel';
    MESSAGE_TYPE2.ERROR = 'Error';
    MESSAGE_TYPE2.UPDATE = 'Update';
    return MESSAGE_TYPE2;
  })(MESSAGE_TYPE || {});
  const LL$7 = LLFG('nina');
  const getCategoryLabel = category => {
    const lowercaseCategory = category.toLowerCase();
    return LL$7.category[lowercaseCategory]();
  };
  const getSeverityLabel = (severity, provider2) => {
    const lowercaseSeverity = severity.toLowerCase();
    const providerCategory = getProviderCategory(provider2);
    return LL$7.severity[providerCategory][lowercaseSeverity]();
  };
  const getSeverityEmoji = severity =>
    ({ Unknown: '🤷', Minor: '⚪', Moderate: '🟠', Severe: '🔴', Extreme: '🟣' })[severity];
  const severityToNumber = severity => ['Unknown', 'Minor', 'Moderate', 'Severe', 'Extreme'].indexOf(severity) - 1;
  const LL$6 = LLFG('nina');
  const LOCK_NAME = 'better-moodle-nina-cache';
  const API_BASE = 'https://nina.api.proxy.bund.dev/api31';
  const civilWarningsSetting = new SliderSetting('civilWarnings', 2, {
    min: 0,
    max: 4,
    step: 1,
    labels: ['off', 'extreme', 'severe', 'moderate', 'minor'],
  }).addAlias('nina.civilProtectionWarnings');
  const policeWarningSetting = new SliderSetting('policeWarnings', 2, {
    min: 0,
    max: 4,
    step: 1,
    labels: ['off', 'extreme', 'severe', 'moderate', 'minor'],
  });
  const weatherWarningsSetting = new SliderSetting('weatherWarnings', 2, {
    min: 0,
    max: 4,
    step: 1,
    labels: ['off', 'extreme', 'severe', 'moderate', 'minor'],
  }).addAlias('nina.weatherWarnings');
  const floodWarningsSetting = new SliderSetting('floodWarnings', 0, {
    min: 0,
    max: 1,
    step: 1,
    labels: ['off', 'all'],
  }).addAlias('nina.floodWarnings', old => Number(old));
  const inAppNotifications = new BooleanSetting('inAppNotifications', true);
  const desktopNotifications = new BooleanSetting('desktopNotifications', false).addAlias('nina.notification');
  const notifyUpdates = new BooleanSetting('notifyUpdates', false);
  const notifyClearSignal = new BooleanSetting('notifyClearSignal', true);
  const getCachedActiveAlerts = () => GM_getValue('nina.cache') ?? {};
  const updateCachedActiveAlerts = alerts =>
    navigator.locks.request(LOCK_NAME, () => {
      const oldAlertCache = getCachedActiveAlerts();
      const newAlertCache = {};
      alerts.forEach(alert => {
        const alertId = alert.identifier;
        newAlertCache[alertId] = {
          notified: oldAlertCache[alertId]?.notified ?? false,
          seen: oldAlertCache[alertId]?.seen ?? false,
          referenceOnly: false,
        };
        getAlertReferences(alert).forEach(ref => {
          newAlertCache[ref.alertId] = {
            notified: oldAlertCache[ref.alertId]?.notified ?? newAlertCache[alert.identifier].notified,
            seen: oldAlertCache[ref.alertId]?.seen ?? newAlertCache[alert.identifier].seen,
            referenceOnly: newAlertCache[ref.alertId]?.referenceOnly ?? true,
          };
        });
      });
      GM_setValue('nina.cache', newAlertCache);
    });
  const getAlerts = () =>
    cachedRequest(`${API_BASE}/dashboard/${arsToCountyLevel('010030000000')}.json`, 3e4, 'json', void 0, {
      headers: { 'Cache-Control': 'no-cache' },
    });
  const getAlert = alertId => cachedRequest(`${API_BASE}/warnings/${alertId}.json`, 6e5, 'json');
  const shortenAlertDescription = (alert, len = 200) => {
    const description = createElement('p', {
      dangerouslySetInnerHTML: { __html: getAlertInfoAttribute(alert, 'description') ?? '' },
    }).innerText;
    if (description.length > len) return `${description.substring(0, len).trim()}...`;
    return description;
  };
  const showAlertDetailsModal = alertId => {
    const alertTitleElem = createElement('span', null);
    const alertBodyElem = createElement('div', { className: 'px-3' });
    const alertFooterElem = createElement('span', { className: 'd-flex align-items-center text-muted mr-auto' });
    const alertModal = new Modal({
      type: 'ALERT',
      large: true,
      scrollable: true,
      title: alertTitleElem,
      body: alertBodyElem,
      footer: alertFooterElem,
    });
    getAlert(alertId)
      .then(resp => resp.value)
      .then(alert => {
        const provider2 = providerById(alert.identifier);
        const isCancel = alert.msgType === MESSAGE_TYPE.CANCEL;
        const severity = getAlertInfoAttribute(alert, 'severity');
        alertTitleElem.append(
          createElement(
            Fragment,
            null,
            createElement(
              'span',
              {
                dataset: {
                  originalTitle: isCancel ? LL$6.msgType.cancel() : getSeverityLabel(severity, provider2),
                  toggle: 'tooltip',
                },
              },
              isCancel ? '✖️' : getSeverityEmoji(severity)
            ),
            ' ',
            createElement('span', null, getAlertTitle(alert))
          )
        );
        const sent = dateToString(new Date(alert.sent));
        alertBodyElem.append(
          createElement('span', { className: 'small text-muted' }, LL$6.modal.sentAt(), ': ', sent),
          createElement('br', null)
        );
        const onset = getAlertInfoAttribute(alert, 'onset') ?? '';
        const expires = getAlertInfoAttribute(alert, 'expires') ?? '';
        if (onset && expires) {
          alertBodyElem.append(
            createElement(
              'span',
              { className: 'small text-muted' },
              dateToString(new Date(onset)),
              ' - ',
              dateToString(new Date(expires))
            ),
            createElement('br', null)
          );
        }
        const description = getAlertInfoAttribute(alert, 'description');
        if (description) {
          alertBodyElem.append(
            createElement('h5', null, LL$6.modal.description()),
            createElement('p', { dangerouslySetInnerHTML: { __html: description } })
          );
        }
        const instruction = getAlertInfoAttribute(alert, 'instruction');
        if (instruction) {
          alertBodyElem.append(
            createElement('h5', null, LL$6.modal.instruction()),
            createElement('p', { dangerouslySetInnerHTML: { __html: instruction } })
          );
        }
        const categories = getAlertInfoAttribute(alert, 'category') ?? [];
        if (categories.length > 0) {
          alertBodyElem.append(
            createElement(
              'div',
              { className: 'small' },
              createElement('b', null, LL$6.modal.categories(), ':'),
              ' ',
              createElement(
                'span',
                null,
                categories.map((category, index) =>
                  createElement(
                    Fragment,
                    null,
                    createElement('span', { key: category }, getCategoryLabel(category)),
                    index < categories.length - 1 && ', '
                  )
                )
              )
            )
          );
        }
        const web = getAlertInfoAttribute(alert, 'web');
        if (web) {
          const linkifiedWeb = web.startsWith('http') ? web : `https://${web}`;
          alertFooterElem.append(
            createElement(
              'a',
              { href: linkifiedWeb, className: globalStyle.noExternalLinkIcon, target: '_blank' },
              createElement('i', { className: 'icon fa fa-globe fa-fw' })
            )
          );
        }
        const alertFooterTextElem = createElement('div', { className: 'ml-2 small' });
        const senderName = getAlertInfoAttribute(alert, 'senderName');
        const senderLongname = getAlertInfoParameter(alert, 'sender_langname');
        alertFooterTextElem.append(
          createElement(
            'span',
            null,
            LL$6.modal.providedBy(),
            ' ',
            `${(senderName ?? senderLongname) ? `${senderName ?? senderLongname} ${LL$6.modal.via()}` : ''} ${getProviderLabel(provider2)}`
          ),
          createElement('br', null)
        );
        alertFooterTextElem.append(
          createElement(
            'a',
            { href: `https://warnung.bund.de/meldungen/${alertId}/`, target: '_blank' },
            ' ',
            LL$6.modal.bbkLink()
          )
        );
        alertFooterElem.append(alertFooterTextElem);
        alertModal.show();
        navigator.locks.request(LOCK_NAME, () => {
          const alertCache = getCachedActiveAlerts();
          if (!alertCache[alert.identifier]) {
            alertCache[alert.identifier] = { seen: false, notified: false, referenceOnly: false };
          }
          alertCache[alert.identifier].seen = true;
          GM_setValue('nina.cache', alertCache);
        });
      });
  };
  const severityInPreferences = (sevNum, providerCategory) => {
    const providerSetting =
      'civilProtection' === providerCategory ? civilWarningsSetting
      : 'police' === providerCategory ? policeWarningSetting
      : 'weather' === providerCategory ? weatherWarningsSetting
      : floodWarningsSetting;
    if ('flood' === providerCategory) return providerSetting.value > 0;
    return providerSetting.value > severityToNumber('Extreme') - sevNum;
  };
  const sendAlertNotification = alert =>
    void navigator.locks.request(LOCK_NAME, () => {
      const alertId = alert.identifier;
      const alertCache = getCachedActiveAlerts();
      if (!alertCache[alertId]) alertCache[alertId] = { seen: false, notified: false, referenceOnly: false };
      if (alertCache[alertId].notified || alertCache[alertId].seen || alertCache[alertId].referenceOnly) return;
      const urgency = getAlertInfoAttribute(alert, 'urgency');
      const severity = severityToNumber(getAlertInfoAttribute(alert, 'severity'));
      const provider2 = providerById(alertId);
      const provCat = getProviderCategory(provider2);
      const isUpdate = alert.msgType === MESSAGE_TYPE.UPDATE;
      const isCancel = alert.msgType === MESSAGE_TYPE.CANCEL;
      const wasNotified = getAlertReferences(alert).some(ref => alertCache[ref.alertId].notified);
      if (
        !isEnabled() ||
        urgency === URGENCY.PAST ||
        !severityInPreferences(severity, provCat) ||
        (isUpdate && !notifyUpdates.value && wasNotified) ||
        (isCancel && !notifyClearSignal.value) ||
        (isCancel && !wasNotified)
      ) {
        return;
      }
      const title = getAlertTitle(alert);
      const shortDescription = shortenAlertDescription(alert, 75);
      if (inAppNotifications.value) {
        requirePromise(['core/toast']).then(
          ([{ add: add2 }]) =>
            void add2(shortDescription, {
              type: 'warning',
              autohide: true,
              closeButton: true,
              delay: 1e4,
              title,
              subtitle: getHtml(
                createElement(
                  'a',
                  {
                    href: `https://warnung.bund.de/meldungen/${alertId}/`,
                    dataset: { alert: alertId },
                    target: '_blank',
                  },
                  LL$6.modal.showMore()
                )
              ),
            })
        );
        alertCache[alertId].notified = true;
      }
      if (desktopNotifications.value) {
        GM_notification({
          title,
          text: shortDescription,
          image: getProviderIcon(provider2, isCancel),
          onclick: () => showAlertDetailsModal(alertId),
        });
        alertCache[alertId].notified = true;
      }
      GM_setValue('nina.cache', alertCache);
    });
  let disabledByOtherTab = false;
  const isEnabled = () =>
    (0 !== civilWarningsSetting.value || 0 !== weatherWarningsSetting.value || 0 !== floodWarningsSetting.value) &&
    !disabledByOtherTab;
  let alertsModalShown = false;
  let alertsModalContent = [];
  const alertsNavItem = createElement(
    NavbarItem,
    { order: 600 },
    createElement(
      'div',
      { className: 'nav-link icon-no-margin' },
      createElement('i', { className: 'icon fa fa-exclamation-triangle fa-fw text-warning' })
    )
  );
  const alertsModalReloadButton = createElement(
    'button',
    { type: 'button', className: 'btn mr-auto' },
    createElement('i', { className: 'icon fa fa-refresh fa-fw' }),
    LL$6.modal.reload()
  );
  const alertsModalBody = createElement('div', null);
  const alertsModal = new Modal({
    type: 'ALERT',
    large: true,
    scrollable: true,
    title: createElement(
      Fragment,
      null,
      createElement('i', { className: 'icon fa fa-exclamation-triangle fa-fw' }),
      LL$6.modal.activeWarnings()
    ),
    body: alertsModalBody,
    footer: alertsModalReloadButton,
  });
  alertsModal.setTrigger(alertsNavItem);
  alertsModal.onShown(() => {
    alertsModalShown = true;
  });
  alertsModal.onHidden(() => {
    alertsModalShown = false;
  });
  alertsModalReloadButton.addEventListener('click', () => {
    const icon = alertsModalReloadButton.querySelector('i');
    icon?.classList.add(style$6.spin);
    requestAlerts()
      .then(reloadAlertsModal)
      .then(() => {
        alertsModalReloadButton.addEventListener(
          'animationiteration',
          () => {
            icon?.classList.remove(style$6.spin);
          },
          { once: true }
        );
      });
  });
  document.addEventListener('click', e => {
    const target = e.target.closest('[data-alert]');
    if (target && target instanceof HTMLElement) {
      e.preventDefault();
      const alertId = target.dataset?.alert;
      if (alertId) showAlertDetailsModal(alertId);
    }
  });
  const reloadAlertsModal = () =>
    alertsModalBody.replaceChildren(
      ...alertsModalContent.flatMap(contentElem => [contentElem, createElement('hr', null)]).slice(0, -1)
    );
  let scheduledInterval = null;
  const requestAlerts = () =>
    getAlerts()
      .then(resp => resp.value)
      .then(alertSummaries => alertSummaries.map(s => s.id))
      .then(async alertIds => {
        const alerts = (await Promise.all(alertIds.map(getAlert)))
          .map(resp => resp.value)
          .filter(
            alert =>
              severityInPreferences(
                severityToNumber(getAlertInfoAttribute(alert, 'severity')),
                getProviderCategory(providerById(alert.identifier))
              ) &&
              (alert.msgType !== MESSAGE_TYPE.CANCEL || notifyClearSignal.value)
          );
        alerts.length > 0 ? alertsNavItem.put() : alertsNavItem.remove();
        await updateCachedActiveAlerts(alerts);
        const alertCache = getCachedActiveAlerts();
        alerts.sort((a, b) => {
          const seenA = alertCache[a.identifier].seen;
          const seenB = alertCache[b.identifier].seen;
          const severityA = getAlertInfoAttribute(a, 'severity');
          const severityB = getAlertInfoAttribute(b, 'severity');
          if (seenA !== seenB) return seenA ? 1 : -1;
          if (severityA !== severityB) return severityToNumber(severityA) - severityToNumber(severityB);
          return 0;
        });
        alerts.forEach(alert => {
          sendAlertNotification(alert);
        });
        alertsModalContent = alerts.map(alert => {
          const alertId = alert.identifier;
          const severity = getAlertInfoAttribute(alert, 'severity');
          const provider2 = providerById(alertId);
          const shortDescription = shortenAlertDescription(alert);
          const isCancel = alert.msgType === MESSAGE_TYPE.CANCEL;
          return createElement(
            'div',
            { className: `card p-3 ${!alertCache[alertId].seen ? style$6.unseen : ''}` },
            createElement(
              'h5',
              null,
              createElement(
                'span',
                {
                  dataset: {
                    originalTitle: isCancel ? LL$6.msgType.cancel() : getSeverityLabel(severity, provider2),
                    toggle: 'tooltip',
                  },
                },
                isCancel ? '✖️' : getSeverityEmoji(severity)
              ),
              ' ',
              getAlertTitle(alert)
            ),
            createElement(
              'span',
              { className: 'small text-muted' },
              LL$6.modal.sentAt(),
              ':',
              ' ',
              dateToString(new Date(alert.sent))
            ),
            createElement('br', null),
            createElement('p', null, shortDescription),
            createElement(
              'div',
              { className: 'small' },
              createElement(
                'a',
                {
                  href: `https://warnung.bund.de/meldungen/${alertId}/`,
                  dataset: { alert: alertId },
                  target: '_blank',
                },
                LL$6.modal.showMore()
              )
            )
          );
        });
        if (0 === alertsModalContent.length) {
          alertsModalContent = [createElement('p', null, LL$6.modal.noActiveWarnings())];
        }
        if (alertsModalShown) return;
        reloadAlertsModal();
      });
  const reload$e = () => {
    requestAlerts();
    scheduledInterval ??= setInterval(() => void requestAlerts(), 3e4);
    disabledByOtherTab = false;
  };
  const __vite_glob_0_8 = FeatureGroup.register({
    settings: new Set([
      civilWarningsSetting,
      policeWarningSetting,
      weatherWarningsSetting,
      floodWarningsSetting,
      inAppNotifications,
      desktopNotifications,
      notifyUpdates,
      notifyClearSignal,
    ]),
    onload: reload$e,
    onunload: reload$e,
  });
  class Block {
    #id;
    static #counters = new Map();
    #rendered = false;
    #hidden = false;
    #classes = new Set();
    #instanceId;
    #ariaRole = 'complementary';
    #ariaLabel = '';
    #title = '';
    #showTitle = true;
    #controls = null;
    #content = createElement(Fragment, null);
    #footer = createElement(Fragment, null);
    #annotation = createElement(Fragment, null);
    #card;
    #elements = [];
    #element;
    constructor(id, card = true) {
      this.#id = PREFIX(id);
      this.#instanceId = Block.#counters.get(id) ?? 0;
      this.#card = card;
      Block.#counters.set(id, this.#instanceId + 1);
    }
    #throwOnRendered() {
      if (this.#rendered) throw new Error(`Block #${this.#id} already rendered`);
    }
    addClasses(...classes) {
      this.#throwOnRendered();
      classes.forEach(c => this.#classes.add(c));
      return this;
    }
    setTitle(title) {
      this.#throwOnRendered();
      this.#title = title;
      return this;
    }
    setContent(content, showTitle = this.#showTitle) {
      this.#showTitle = showTitle;
      if (this.#element) {
        this.#content = content;
        this.#element.replaceChildren(this.#realContent);
      } else {
        this.#throwOnRendered();
        this.#content = content;
      }
      return this;
    }
    get #realContent() {
      return this.#card ?
          createElement(
            'div',
            { className: 'card-body p-3' },
            this.#showTitle ?
              createElement('h5', { className: 'card-title d-inline' }, this.#title)
            : createElement(Fragment, null),
            createElement('div', { className: 'card-text content mt-3' }, this.#content)
          )
        : this.#content;
    }
    get rendered() {
      return this.#rendered;
    }
    get element() {
      return this.#element;
    }
    #render() {
      this.#throwOnRendered();
      this.#rendered = true;
      return render('core/block', {
        showskiplink: true,
        title: this.#title,
        skipid: `${this.#id}-${this.#instanceId}`,
        id: `${this.#id}-${this.#instanceId}`,
        hidden: this.#hidden,
        class: Array.from(this.#classes).join(' '),
        hascontrols: null !== this.#controls,
        ariarole: this.#ariaRole,
        type: this.#id,
        blockinstanceid: this.#instanceId,
        arialabel: this.#ariaLabel,
        controls: this.#controls ? getHtml(this.#controls) : '',
        content: getHtml(this.#realContent),
        footer: getHtml(this.#footer),
        annotation: getHtml(this.#annotation),
      });
    }
    async create(element, action) {
      this.#throwOnRendered();
      const template = await this.#render();
      this.#elements = await putTemplate(element, template, action);
      this.#element = this.#elements.find(el => el.matches('section'));
      return this;
    }
    remove() {
      this.#elements.forEach(el => el.remove());
    }
    put(element, action) {
      element[action](...this.#elements);
    }
  }
  const style$5 = {
    todaySpan: 'better-moodle_semesterzeiten__today-span',
    tableToggle: 'better-moodle_semesterzeiten__table-toggle',
    progressOverlayBar: 'better-moodle_semesterzeiten__progress-overlay-bar',
  };
  const LL$5 = LLFG('semesterzeiten');
  const hiddenBars = new Set(GM_getValue('semesterzeiten.hiddenBars', []));
  GM_listValues().forEach(key => {
    if (key.startsWith('better-moodle-semesterzeiten.show.')) GM_deleteValue(key);
  });
  const blockSetting = new BooleanSetting('block', false).addAlias('general.semesterzeiten');
  const block = new Block('semesterzeiten', true).setTitle(LL$5.name());
  const hoverStyle = document.createElement('style');
  const updateHoverStyle = () => {
    if (!semesterzeiten) return;
    const allEventTypes = new Set(['semester']);
    semesterzeiten.forEach(({ events: events2 }) => events2.forEach(({ type }) => allEventTypes.add(type)));
    const tableSelectors = allEventTypes
      .values()
      .map(type => `#${block.element?.id}:has(.progress-bar:hover [data-type="${type}"]) tr[data-type="${type}"] td`)
      .toArray();
    const barSelectors = allEventTypes
      .values()
      .map(type => `#${block.element?.id}:has(tr[data-type="${type}"]:hover) .progress-bar [data-type="${type}"]`)
      .toArray();
    hoverStyle.textContent = `
${tableSelectors.join(',\n')} {
    filter: brightness(1.2);
    font-weight: bold;
}
${barSelectors.join(',\n')} {
    filter: brightness(1.5);
}`.trim();
  };
  let semesterzeiten;
  const getSemesterzeiten = () =>
    semesterzeiten ?
      Promise.resolve(semesterzeiten)
    : cachedRequest(icsUrl('semesterzeiten'), 864e5, 'json').then(({ value: zeiten }) => {
        semesterzeiten = zeiten;
        updateHoverStyle();
        return semesterzeiten;
      });
  const todaySpan = createElement('span', { className: style$5.todaySpan }, dateToString());
  const toggleTableBtn = createElement(
    'button',
    { className: ['btn btn-link btn-sm p-0', style$5.tableToggle] },
    createElement('i', { className: 'icon fa fa-info-circle mr-0' })
  );
  const progressBar = createElement('div', { className: 'progress w-100 position-relative' });
  const prevSemesterBtn = createElement(
    'li',
    { className: 'page-item' },
    createElement(
      'button',
      { className: 'page-link' },
      createElement(
        'span',
        { className: 'icon-no-margin' },
        createElement('i', { className: 'icon fa fa-chevron-left fa-fw' })
      )
    )
  );
  const nextSemesterBtn = createElement(
    'li',
    { className: 'page-item' },
    createElement(
      'button',
      { className: 'page-link' },
      createElement(
        'span',
        { className: 'icon-no-margin' },
        createElement('i', { className: 'icon fa fa-chevron-right fa-fw' })
      )
    )
  );
  prevSemesterBtn.addEventListener('click', () => loadContent$1(currentSemester - 1));
  nextSemesterBtn.addEventListener('click', () => loadContent$1(currentSemester + 1));
  const tableBody = createElement('tbody', null);
  const table$1 = createElement(
    'table',
    { className: 'table table-hover hidden' },
    createElement(
      'thead',
      null,
      createElement(
        'tr',
        null,
        createElement('th', null, LL$5.table.name()),
        createElement('th', null, LL$5.table.start()),
        createElement('th', null, LL$5.table.end()),
        createElement('th', null, LL$5.table.progress()),
        createElement('th', null, LL$5.table.show())
      )
    ),
    tableBody
  );
  toggleTableBtn.addEventListener('click', () => table$1.classList.toggle('hidden'));
  const getEventDates = event => {
    const start = new Date(event.start);
    if (event.startDateOnly) start.setTime(start.getTime() + 6e4 * start.getTimezoneOffset());
    const end = new Date(event.end);
    if (event.endDateOnly) end.setTime(end.getTime() + 6e4 * end.getTimezoneOffset());
    const duration = end.getTime() - start.getTime();
    const passed = Date.now() - start.getTime();
    return { start, end, duration, progress: Math.max(0, Math.min(passed / duration, 1)) };
  };
  let currentSemester = 0;
  const loadProgressBar = (semester, currentSemester2) => {
    const { start: semesterStart, end: semesterEnd, duration: semesterDuration } = getEventDates(semester);
    const stops = new Map();
    stops.set(semesterStart, { start: new Set([semester]), end: new Set() });
    stops.set(semesterEnd, { start: new Set(), end: new Set([semester]) });
    semester.events.forEach(event => {
      const { start, end } = getEventDates(event);
      if (!hiddenBars.has(event.type)) {
        const normalizedStart = start > semesterStart ? start : semesterStart;
        const normalizedEnd = end < semesterEnd ? end : semesterEnd;
        const startStop = stops.get(normalizedStart) ?? { start: new Set(), end: new Set() };
        const endStop = stops.get(normalizedEnd) ?? { start: new Set(), end: new Set() };
        startStop.start.add(event);
        endStop.end.add(event);
        stops.set(normalizedStart, startStop);
        stops.set(normalizedEnd, endStop);
      }
    });
    progressBar.replaceChildren();
    const currentEvents = new Set();
    const stopDates = Array.from(stops.keys()).toSorted((a, b) => a.getTime() - b.getTime());
    stopDates.forEach((date, index) => {
      if (index === stops.size - 1) return;
      const { start: starts, end: ends } = stops.get(date);
      starts.forEach(event => currentEvents.add(event));
      ends.forEach(event => currentEvents.delete(event));
      const startPercentage = (date.getTime() - semesterStart.getTime()) / semesterDuration;
      const width =
        100 * ((stopDates[index + 1].getTime() - semesterStart.getTime()) / semesterDuration - startPercentage);
      const title = createElement(Fragment, null);
      const bar = createElement('div', {
        className: 'progress-bar',
        style: { width: `${width}%` },
        dataset: { toggle: 'tooltip', placement: 'bottom', html: 'true' },
      });
      currentEvents.forEach(event => {
        const { start, end } = getEventDates(event);
        const color = 'color' in event ? event.color : 'primary';
        title.append(
          createElement(
            'p',
            null,
            createElement('b', { className: `text-${color}` }, event.name[BETTER_MOODLE_LANG]),
            createElement('br', null),
            event.type.startsWith('holiday-') ?
              dateToString(start)
            : createElement(Fragment, null, dateToString(start), ' - ', dateToString(end))
          )
        );
        bar.append(
          createElement('div', {
            dataset: { type: event.type },
            className: ['progress-bar w-100, h-100', `bg-${color}`],
          })
        );
      });
      bar.dataset.originalTitle = getHtml(title);
      progressBar.append(bar);
    });
    if (currentSemester2) {
      progressBar.append(
        createElement('div', {
          className: ['progress-bar bg-transparent progress-bar-striped', style$5.progressOverlayBar],
        })
      );
    }
  };
  const loadContent$1 = (semesterIndex = 0) => {
    currentSemester = semesterIndex;
    let contentLoaded = false;
    if (void 0 === semesterzeiten) {
      getLoadingSpinner().then(spinner => {
        spinner.classList.add('text-center');
        if (!contentLoaded) block.setContent(spinner, false);
      });
    }
    getSemesterzeiten()
      .then(zeiten => {
        currentSemester = Math.max(0, Math.min(zeiten.length - 1, currentSemester));
        return [zeiten[currentSemester], zeiten.length];
      })
      .then(([semester, semesterCount]) => {
        contentLoaded = true;
        const { start: semesterStart, end: semesterEnd, progress: semesterProgress } = getEventDates(semester);
        prevSemesterBtn.classList.toggle('disabled', 0 === currentSemester);
        nextSemesterBtn.classList.toggle('disabled', currentSemester === semesterCount - 1);
        tableBody.replaceChildren(
          createElement(
            'tr',
            { className: 'table-primary font-weight-bold', dataset: { type: 'semester' } },
            createElement('td', null, semester.name[BETTER_MOODLE_LANG]),
            createElement('td', null, dateToString(semesterStart)),
            createElement('td', null, dateToString(semesterEnd)),
            createElement('td', null, percent(semesterProgress)),
            createElement(
              'td',
              { className: 'p-0 px-md-3 align-middle' },
              createElement(
                'nav',
                null,
                createElement(
                  'ul',
                  { className: 'pagination mb-0 flex-nowrap justify-content-center justify-content-md-end' },
                  prevSemesterBtn,
                  nextSemesterBtn
                )
              )
            )
          )
        );
        const switches = new Map();
        semester.events.forEach(event => {
          const { start, end, progress } = getEventDates(event);
          const toggle = createElement(Switch, {
            id: domID(`semesterzeiten-toggle-${currentSemester}-${event.type}`),
            value: !hiddenBars.has(event.type),
          });
          if (!switches.has(event.type)) switches.set(event.type, new Set());
          switches.get(event.type)?.add(toggle);
          toggle.addEventListener('input', () => {
            if (toggle.value) hiddenBars.delete(event.type);
            else hiddenBars.add(event.type);
            switches.get(event.type)?.forEach(t => (t.value = toggle.value));
            GM_setValue('semesterzeiten.hiddenBars', Array.from(hiddenBars));
            loadProgressBar(semester, 0 === currentSemester);
          });
          if (event.type.startsWith('holiday-')) {
            tableBody.append(
              createElement(
                'tr',
                { className: `table-${event.color}`, dataset: { type: event.type } },
                createElement(
                  'td',
                  { colSpan: 4 },
                  LL$5.publicHoliday(),
                  ': ',
                  event.name[BETTER_MOODLE_LANG],
                  ' (',
                  dateToString(start, true, true),
                  ')'
                ),
                createElement('td', null, toggle)
              )
            );
          } else {
            tableBody.append(
              createElement(
                'tr',
                { className: `table-${event.color}`, dataset: { type: event.type } },
                createElement('td', null, event.name[BETTER_MOODLE_LANG]),
                createElement('td', null, dateToString(start)),
                createElement('td', null, dateToString(end)),
                createElement('td', null, percent(progress)),
                createElement('td', null, toggle)
              )
            );
          }
        });
        loadProgressBar(semester, 0 === currentSemester);
        if (0 === currentSemester) block.element?.style.setProperty('--progress-percent', semesterProgress.toString());
        block.setContent(
          createElement(
            Fragment,
            null,
            0 === currentSemester ?
              createElement('div', { className: 'position-relative' }, todaySpan)
            : createElement(Fragment, null),
            createElement('div', { className: 'd-flex align-items-center' }, toggleTableBtn, progressBar),
            createElement('div', { className: 'table-responsive' }, table$1)
          ),
          false
        );
      });
  };
  const reload$d = async () => {
    if (isDashboard && blockSetting.value) {
      await ready();
      const region = document.getElementById('block-region-content');
      if (!region) return;
      if (!block.rendered) await block.create(region, 'prepend');
      else block.put(region, 'prepend');
      document.head.append(hoverStyle);
      loadContent$1();
    } else {
      block?.remove();
      hoverStyle.remove();
    }
  };
  blockSetting.onInput(() => void reload$d());
  const __vite_glob_0_9 = FeatureGroup.register({
    settings: new Set([blockSetting]),
    onload: reload$d,
    onunload: reload$d,
  });
  const canteens$1 = new Map();
  const add = (key, name = '', id = 0, closingHour = 24) =>
    canteens$1.set(key, {
      key,
      title: name,
      closingHour,
      url: {
        de: `https://studentenwerk.sh/de/essen-uebersicht?mensa=${id}#mensaplan`,
        en: `https://studentenwerk.sh/en/food-overview?mensa=${id}#mensaplan`,
      },
      urlNextWeek: {
        de: `https://studentenwerk.sh/de/essen-uebersicht?mensa=${id}&nw=1#mensaplan`,
        en: `https://studentenwerk.sh/en/food-overview?mensa=${id}&nw=1#mensaplan`,
      },
    });
  add('uzl');
  add('mhl');
  add('bitsandbytes');
  add('uzl', 'Lübeck: Mensa & Cafeteria', 8, 15);
  add('mhl', 'Lübeck: Cafeteria Musikhochschule', 9, 14);
  add('bitsandbytes', 'Lübeck: Bits + Bytes', 17, 15);
  add('cau1', 'Kiel: Mensa I & Cafeteria & Café Lounge', 1, 16);
  add('cau2', 'Kiel: Mensa II & Cafeteria & Café Lounge', 2, 17);
  add('kesselhaus', 'Kiel: Mensa Kesselhaus (Veggie)', 4, 14);
  add('schwentine', 'Kiel: Schwentine Mensa & Cafeteria', 5, 15);
  add('americandiner', 'Kiel: American Diner', 6, 16);
  add('dockside', 'Kiel: Cafeteria "Dockside"', 16, 15);
  add('flensburg', 'Flensburg: Mensa', 7, 17);
  add('flensburgb', 'Flensburg: Cafeteria B-Gebäude', 14, 15);
  add('heide', 'Heide: Mensa & Cafeteria', 11, 14);
  add('wedel', 'Wedel: Cafeteria', 10, 16);
  add('osterroenfeld', 'Osterrönfeld: Mensa', 15, 13);
  const prices = {
    'de': ['Studierende', 'Hochschulangehörige', 'Externe'],
    'en-gb': ['Students', 'University members', 'Guests'],
  };
  const todayTreshhold = new Date(Date.now() - 864e5);
  const getDishes = dayEl => {
    const dishes = new Set();
    dayEl.querySelectorAll('.mensa_menu_detail').forEach(dishEl => {
      const name = [{ text: '' }];
      dishEl.querySelector('.menu_name')?.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) name.push({ text: node.textContent?.trim() ?? '' });
        else if (node instanceof HTMLBRElement) name.push({ text: node });
        else if (node instanceof HTMLElement && node.classList.contains('mensa_zusatz')) {
          name.at(-1).info = node.textContent?.trim() ?? '';
        }
      });
      const dish = {
        name,
        location: dishEl.querySelector('[class*="mensatyp_"]')?.textContent ?? '',
        allergenes: dishEl.dataset.allergene?.split('|').filter(Boolean) ?? [],
        additives: dishEl.dataset.zusatzstoffe?.split('|').filter(Boolean) ?? [],
        types: dishEl.dataset.arten?.split('|').filter(Boolean) ?? [],
        prices: Array.from(dishEl.querySelectorAll('.menu_preis span')).map(p =>
          parseFloat(p.textContent?.replace(/,/g, '.') ?? '-1')
        ),
        co2: {
          stars: Number(dishEl.querySelector('.co2star')?.dataset.anz ?? '0'),
          emission: Number(dishEl.querySelector('.co2box_text')?.textContent?.match(/\d+(?=\s+Gramm?)/)?.[0] ?? '0'),
        },
      };
      dishes.add(dish);
    });
    return dishes;
  };
  const style$4 = { foodIcon: 'better-moodle_speiseplan__food-icon', table: 'better-moodle_speiseplan__table' };
  const LL$4 = LLFG('speiseplan');
  const enabled$f = new BooleanSetting('enabled', true).addAlias('general.speiseplan');
  const language = new SelectSetting('language', 'auto', [
    'auto',
    ...languages.entries().map(([locale, { name, flag }]) => ({ key: locale, title: `${flag} ${name}` })),
  ]).addAlias('speiseplan.language');
  const getLang = () => ('auto' === language.value ? BETTER_MOODLE_LANG : language.value);
  const sLL = () => LLMap.get(getLang()).features.speiseplan;
  const canteens = Object.values([canteens$1])[0];
  const canteen = new SelectSetting('canteen', Array.from(canteens.keys())[0], Array.from(canteens.values()));
  const parse = Object.values([
    url =>
      getDocument(url, 6e5).then(({ lastUpdate, value: doc }) => {
        const dishes = new Map();
        doc.querySelectorAll('.mensatag .tag_headline[data-day]').forEach(dayEl => {
          const day = new Date(dayEl.dataset.day ?? '');
          if (isNaN(day.getTime()) || day < todayTreshhold) return;
          const dayDishes = getDishes(dayEl);
          if (dayDishes.size > 0) dishes.set(day, dayDishes);
        });
        const allergenes = new Map(
          Array.from(doc.querySelectorAll('.filterbutton[data-typ="1"]')).map(el => [
            el.dataset.wert ?? '',
            el.querySelector('span:not(.abk)')?.textContent?.trim() ?? '',
          ])
        );
        const additives = new Map(
          Array.from(doc.querySelectorAll('.filterbutton[data-typ="2"]')).map(el => [
            el.dataset.wert ?? '',
            el.querySelector('span:not(.abk)')?.textContent?.trim() ?? '',
          ])
        );
        const types = new Map(
          Array.from(doc.querySelectorAll('.filterbutton[data-typ="3"]')).map(el => {
            const icon = el.querySelector('img')?.src;
            const iconPath = icon ? new URL(icon).pathname : void 0;
            let name = el.textContent?.trim() ?? '';
            if ('1' === el.dataset.ex && icon) {
              name = doc.querySelector(`:not(.filterbutton) > img[src*="${iconPath}"]`)?.title ?? name;
            }
            return [el.dataset.wert ?? '', { name, icon: iconPath ? new URL(iconPath, url) : void 0 }];
          })
        );
        types.set('SHT', {
          name: 'Schleswig-Holstein Teller',
          icon: new URL('https://studentenwerk.sh/upload/img/sh_teller1.png?h=80&t=2'),
        });
        return { timestamp: lastUpdate, dishes, prices: prices[BETTER_MOODLE_LANG], allergenes, additives, types };
      }),
  ])[0];
  const foodIcons = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
  const randomFoodIcon = () => foodIcons[Math.floor(Math.random() * foodIcons.length)];
  const desktopLink = createElement(
    'a',
    {
      className: ['nav-link', globalStyle.noExternalLinkIcon, style$4.foodIcon],
      href: '#speiseplan',
      title: LL$4.name(),
    },
    randomFoodIcon()
  );
  const desktopBtn = createElement('li', { className: 'nav-item' }, desktopLink, ' ');
  const mobileBtn = createElement(
    'a',
    { className: ['list-group-item list-group-item-action', globalStyle.noExternalLinkIcon], href: '#speiseplan' },
    createElement('span', { className: style$4.foodIcon }, randomFoodIcon()),
    ' ',
    LL$4.name()
  );
  const footerLinkWrapper = createElement('a', { href: '#speiseplan', target: '_blank' }, 'Source');
  const footerTimeSpan = createElement('span', { className: 'mr-auto' });
  const currentCanteen = () => canteens.get(canteen.value);
  const getCanteenUrls = () => {
    const lang = getLang();
    const {
      url: { [lang]: url },
      urlNextWeek: { [lang]: urlNextWeek },
    } = currentCanteen();
    return { url, urlNextWeek };
  };
  const Day = ({ speiseplan, day, dishes, expanded, co2InfoLink, lang }) => {
    const Dish = ({ dish }) =>
      createElement(
        'tr',
        null,
        createElement(
          'td',
          { className: 'dish', dataset: { location: dish.location } },
          ...dish.name.map(item =>
            createElement(
              Fragment,
              null,
              item.text,
              item.info ?
                createElement(Fragment, null, ' ', createElement('span', { className: 'text-muted' }, item.info), ' ')
              : ''
            )
          ),
          dish.allergenes.length ?
            createElement(
              Fragment,
              null,
              createElement('br', null),
              createElement(
                'span',
                { className: 'text-muted small' },
                '(',
                dish.allergenes.map(a => `${a}: ${speiseplan.allergenes.get(a)}`).join(', '),
                ')'
              )
            )
          : '',
          dish.additives.length ?
            createElement(
              Fragment,
              null,
              createElement('br', null),
              createElement(
                'span',
                { className: 'text-muted small' },
                '(',
                dish.additives.map(a => `${a}: ${speiseplan.additives.get(a)}`).join(', '),
                ')'
              )
            )
          : ''
        ),
        createElement(
          'td',
          { className: 'co2-score', dataset: { stars: dish.co2 ? dish.co2.stars.toString() : '0' } },
          dish.co2 && dish.co2.emission ? unit(dish.co2.emission, 'gram', 'long', lang) : ''
        ),
        createElement(
          'td',
          { className: 'dish-types' },
          ...dish.types.map(t => {
            const dishType = speiseplan.types.get(t);
            if (!dishType?.icon) return t;
            return createElement('img', { src: dishType.icon.toString(), title: dishType.name, alt: dishType.name });
          })
        ),
        createElement('td', null, dish.prices.map(p => currency(p, 'EUR', 'symbol', lang)).join(' / '))
      );
    return createElement(
      FieldSet,
      { title: dateToString(day, false, true, getLang()), collapsed: !expanded },
      createElement(
        'table',
        { className: ['table', style$4.table] },
        createElement(
          'thead',
          null,
          createElement(
            'tr',
            null,
            createElement('th', null, sLL().table.dish()),
            createElement(
              'th',
              null,
              createElement('span', { className: 'd-flex' }, sLL().table.co2score(), ' ', co2InfoLink)
            ),
            createElement('th', null, sLL().table.types()),
            createElement(
              'th',
              null,
              sLL().table.price(),
              ' ',
              createElement('i', {
                className: 'icon fa fa-info-circle text-info fa-fw',
                dataset: { toggle: 'tooltip', placement: 'auto' },
                title: speiseplan.prices.join(' / '),
              })
            )
          )
        ),
        createElement('tbody', null, ...Array.from(dishes.values().map(dish => createElement(Dish, { dish }))))
      )
    );
  };
  const getCurrentSpeiseplan = () => {
    const lang = getLang();
    const { url, urlNextWeek } = getCanteenUrls();
    desktopLink.href = mobileBtn.href = url;
    const co2InfoLink = {
      'de': 'https://studentenwerk.sh/de/co2-angaben',
      'en-gb': 'https://studentenwerk.sh/en/co2-data',
    }[lang];
    const co2InfoLinkAnchor = createElement(
      'a',
      { className: globalStyle.noExternalLinkIcon, href: co2InfoLink, target: '_blank' },
      createElement('i', {
        className: 'icon fa fa-info-circle text-info fa-fw',
        dataset: { toggle: 'tooltip', placement: 'auto', html: 'true' },
        title: co2InfoLink,
      })
    );
    footerLinkWrapper.href = url;
    const expandedDay = Number(new Date().getHours() >= currentCanteen().closingHour);
    return Promise.all([parse(url), parse(urlNextWeek)])
      .then(([thisWeek, nextWeek]) => {
        footerTimeSpan.textContent = timeToString(new Date(thisWeek.timestamp));
        const speiseplan = thisWeek;
        speiseplan.dishes = new Map([...thisWeek.dishes, ...nextWeek.dishes]);
        speiseplan.allergenes = new Map([...thisWeek.allergenes, ...nextWeek.allergenes]);
        speiseplan.additives = new Map([...thisWeek.additives, ...nextWeek.additives]);
        speiseplan.types = new Map([...thisWeek.types, ...nextWeek.types]);
        return speiseplan;
      })
      .then(speiseplan =>
        speiseplan.dishes
          .entries()
          .map(([day, dishes], index) =>
            createElement(Day, {
              speiseplan,
              day,
              dishes,
              expanded: index === expandedDay,
              co2InfoLink: co2InfoLinkAnchor.cloneNode(true),
              lang,
            })
          )
      );
  };
  const openSpeiseplan = () => {
    footerLinkWrapper.textContent = sLL().source();
    const modal = new Modal({
      type: 'ALERT',
      large: true,
      scrollable: true,
      title: createElement(
        Fragment,
        null,
        createElement('span', { className: style$4.foodIcon }, randomFoodIcon()),
        ' ',
        sLL().name()
      ),
      body: getCurrentSpeiseplan()
        .then(fieldsets => createElement(Fragment, null, ...Array.from(fieldsets)))
        .catch(error => createElement(Fragment, null, htmlToElements(mdToHtml(sLL().errorWhileFetching({ error }))))),
      bodyClass: 'mform',
      removeOnClose: true,
      buttons: { cancel: `🍴 ${sLL().close()}` },
    }).show();
    modal.getFooter().then(([footer]) => footer.prepend(footerLinkWrapper, ' ⋅ ', footerTimeSpan));
    const updateSpeiseplan = () =>
      Promise.all([modal.getBody(), getLoadingSpinner()]).then(([[body], spinner]) => {
        body.replaceChildren(spinner);
        footerLinkWrapper.textContent = sLL().source();
        getCurrentSpeiseplan()
          .then(fieldsets => body.replaceChildren(...fieldsets))
          .catch(error => body.replaceChildren(...htmlToElements(mdToHtml(sLL().errorWhileFetching({ error })))));
      });
    const canteenSelection = canteen.formControl.cloneNode(true);
    canteenSelection.classList.add('flex-grow-1', 'custom-select-sm');
    canteenSelection.value = canteen.formControl.value;
    canteenSelection.addEventListener('change', () => {
      canteen.formControl.value = canteenSelection.value;
      canteen.formControl.dispatchEvent(new Event('change'));
      canteen.save();
      updateSpeiseplan();
    });
    const languageSelection = language.formControl.cloneNode(true);
    languageSelection.classList.add('flex-grow-1', 'custom-select-sm');
    languageSelection.value = language.formControl.value;
    languageSelection.addEventListener('change', () => {
      language.formControl.value = languageSelection.value;
      language.formControl.dispatchEvent(new Event('change'));
      language.save();
      updateSpeiseplan();
    });
    modal
      .getTitle()
      .then(title =>
        title.after(
          createElement(
            'div',
            { className: 'mx-auto px-2 d-flex flex-wrap', style: { columnGap: '5px' } },
            canteenSelection,
            languageSelection
          )
        )
      );
  };
  desktopBtn.addEventListener('click', e => {
    e.preventDefault();
    openSpeiseplan();
  });
  mobileBtn.addEventListener('click', e => {
    e.preventDefault();
    openSpeiseplan();
  });
  const reload$c = async () => {
    if (!enabled$f.value) {
      desktopBtn.remove();
      mobileBtn.remove();
      return;
    }
    await ready();
    desktopLink.href = mobileBtn.href = getCanteenUrls().url;
    document.querySelector('.dropdownmoremenu')?.before(desktopBtn);
    document.querySelector('#theme_boost-drawers-primary .list-group')?.append(mobileBtn);
  };
  enabled$f.onInput(() => void reload$c());
  const __vite_glob_0_10 = FeatureGroup.register({
    settings: new Set([enabled$f, language, canteen]),
    onload: reload$c,
    onunload: reload$c,
  });
  const openMeteo = (lat, lon) => {
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,weather_code,cloud_cover,surface_pressure,wind_speed_10m,wind_direction_10m&minutely_15=visibility&timeformat=unixtime&timezone=auto&forecast_days=1`;
    return cachedRequest(url, 3e5, 'json', data => {
      const timestamp = new Date(1e3 * data.current.time);
      const minutelyIndex = 4 * timestamp.getHours() + Math.ceil((timestamp.getMinutes() + 1) / 15);
      return {
        condition: codeToCondition('openMeteo', data.current.weather_code),
        temperature: { actual: data.current.temperature_2m, feel: data.current.apparent_temperature },
        wind: { direction: data.current.wind_direction_10m, speed: data.current.wind_speed_10m },
        visibility: data.minutely_15.visibility[minutelyIndex] / 1e3,
        humidity: data.current.relative_humidity_2m / 100,
        pressure: data.current.surface_pressure,
        cloudCover: data.current.cloud_cover / 100,
        precipitation: data.current.precipitation,
        meta: { providerURL: 'https://open-meteo.com', requestURL: url, time: timestamp.toISOString() },
      };
    });
  };
  const openWeatherMap = (lat, lon, apiKey) => {
    const url = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&appid=${apiKey}`;
    return cachedRequest(url, 3e5, 'json', weather => ({
      condition: codeToCondition('openWeatherMap', weather.weather[0].id),
      temperature: { actual: weather.main.temp, feel: weather.main.feels_like },
      wind: { direction: weather.wind.deg, speed: weather.wind.speed },
      visibility: weather.visibility / 1e3,
      humidity: weather.main.humidity / 100,
      pressure: weather.main.pressure,
      cloudCover: weather.clouds.all / 100,
      precipitation: weather.rain?.['1h'] ?? 0,
      meta: {
        providerURL: 'https://openweathermap.org',
        requestURL: url,
        time: new Date(1e3 * weather.dt).toISOString(),
      },
    }));
  };
  const units$1 = {
    metric: {
      temperature: 'celsius',
      angle: 'degree',
      speed: 'kilometer-per-hour',
      distanceKm: 'kilometer',
      distanceMm: 'millimeter',
      pressure: 'hPa',
    },
    scientific: {
      temperature: 'K',
      angle: 'radian',
      speed: 'meter-per-second',
      distanceKm: 'meter',
      distanceMm: 'meter',
      pressure: 'Pa',
    },
    imperial: {
      temperature: 'fahrenheit',
      angle: 'degree',
      speed: 'miles-per-hour',
      distanceKm: 'miles',
      distanceMm: 'inch',
      pressure: 'inHg',
    },
  };
  const convert = {
    scientific: {
      temperature: celsius => celsius + 273.15,
      angle: degree => (degree * Math.PI) / 180,
      speed: kmh => (1e3 * kmh) / 3600,
      distanceKm: km => 1e3 * km,
      distanceMm: mm => mm / 1e3,
      pressure: hPa => 100 * hPa,
    },
    imperial: {
      temperature: celsius => (9 * celsius) / 5 + 32,
      angle: degree => degree,
      speed: kmh => kmh / 1.609344,
      distanceKm: km => km / 1.609344,
      distanceMm: mm => mm / 25.4,
      pressure: hPa => 0.02952998751 * hPa,
    },
  };
  const validUnits = Intl.supportedValuesOf('unit');
  const validUnitRegex = new RegExp(`^(${validUnits.join('|')})(-per-(${validUnits.join('|')}))?$`);
  const stringify = (metric, method, system) => {
    const converted = 'metric' === system ? metric : convert[system][method](metric);
    const unitStr = units$1[system][method];
    if (validUnitRegex.test(unitStr)) return unit(converted, unitStr);
    else {
      const stringified = numToString(converted);
      if ('de' === BETTER_MOODLE_LANG) return `${stringified} ${unitStr}`;
      return `${stringified}${unitStr}`;
    }
  };
  class TextSetting extends Setting {
    constructor(id, defaultValue) {
      super(id, defaultValue, TextInput, {});
    }
  }
  const visualCrossing = (city, apiKey) => {
    const url = `https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/${city}?unitGroup=metric&lang=id&iconSet=icons2&include=current&key=${apiKey}&contentType=json`;
    return cachedRequest(url, 3e5, 'json', ({ currentConditions: weather }) => ({
      condition: codeToCondition('visualCrossing', weather.icon),
      temperature: { actual: weather.temp, feel: weather.feelslike },
      wind: { direction: weather.winddir, speed: weather.windspeed },
      visibility: weather.visibility,
      humidity: weather.humidity / 100,
      pressure: weather.pressure,
      cloudCover: weather.cloudcover / 100,
      precipitation: weather.precip,
      meta: {
        providerURL: 'https://visualcrossing.com',
        requestURL: url,
        time: new Date(1e3 * weather.datetimeEpoch).toISOString(),
      },
    }));
  };
  const wttrIn = city => {
    const url = `https://wttr.in/${city}?format=j1&lang`;
    return cachedRequest(url, 3e5, 'json', ({ current_condition: [weather] }) => ({
      condition: codeToCondition('wttrIn', Number(weather.weatherCode)),
      temperature: { actual: Number(weather.temp_C), feel: Number(weather.FeelsLikeC) },
      wind: { direction: Number(weather.winddirDegree), speed: Number(weather.windspeedKmph) },
      visibility: Number(weather.visibility),
      humidity: Number(weather.humidity) / 100,
      pressure: Number(weather.pressure),
      cloudCover: Number(weather.cloudcover) / 100,
      precipitation: Number(weather.precipMM),
      meta: {
        providerURL: `https://wttr.in/${city}`,
        requestURL: url,
        time: new Date(`${weather.localObsDateTime.slice(0, 10)} ${weather.observation_time} +00:00`).toISOString(),
      },
    }));
  };
  const LL$3 = LLFG('weather');
  const CITY = { display: 'Lübeck', name: 'luebeck', lat: 53.8655, lon: 10.6866 };
  const providersWithAPIKey = ['visualCrossing', 'openWeatherMap'];
  const enabled$e = new BooleanSetting('enabled', false).addAlias('weatherDisplay.show');
  const tempInNav = new BooleanSetting('tempInNav', true)
    .addAlias('weatherDisplay.showTempInNavbar')
    .disabledIf(enabled$e, '!=', true);
  const feelLikeTempInNav = new BooleanSetting('feelLikeTempInNav', true)
    .addAlias('weatherDisplay.toggleFeelsLike')
    .disabledIf(enabled$e, '!=', true)
    .disabledIf(tempInNav, '!=', true);
  const units = new SelectSetting('units', 'metric', ['metric', 'scientific', 'imperial'])
    .addAlias('weatherDisplay.units')
    .disabledIf(enabled$e, '!=', true);
  const providerOptions = ['wttrIn', 'openMeteo'].map(p => ({ key: p, title: LL$3.providers[p]() }));
  providersWithAPIKey.forEach(p =>
    providerOptions.push({ key: p, title: `${LL$3.providers[p]()} (${LL$3.apiKeyRequired()})` })
  );
  const provider = new SelectSetting('provider', 'wttrIn', providerOptions)
    .addAlias('weatherDisplay.provider')
    .disabledIf(enabled$e, '!=', true);
  const apiKeys = new Map();
  providersWithAPIKey.forEach(providerKey => {
    const setting = new TextSetting(`api.${providerKey}`, '')
      .addAlias(`weatherDisplay.${providerKey}APIKey`)
      .disabledIf(enabled$e, '!=', true)
      .disabledIf(provider, '!=', providerKey);
    apiKeys.set(providerKey, setting);
  });
  const currentUnit = () => units.value;
  const navbarText = createElement('div', { className: 'nav-link' }, '🌈');
  const tooltipContent = createElement('div', null);
  const tooltip = createElement('div', null, createElement('b', null, CITY.display), tooltipContent);
  const windDegreesToDirection = degrees =>
    ({ 'de': ['N', 'NO', 'O', 'SO', 'S', 'SW', 'W', 'NW'], 'en-gb': ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'] })[
      BETTER_MOODLE_LANG
    ][Math.round(degrees / 45) % 8];
  const setTooltipContent = content => {
    tooltipContent.innerHTML = '';
    tooltipContent.append(content);
    navbarItem.dataset.originalTitle = getHtml(tooltip);
  };
  let navbarItem;
  let detailsModal;
  const detailsModalTBody = createElement('tbody', null);
  const detailsModalBody = createElement(
    'table',
    { className: 'table table-striped table-hover m-0' },
    detailsModalTBody
  );
  const detailsModalFooter = createElement('span', { className: 'mr-auto' });
  const showInvalidAPIKey = provider2 => {
    navbarText.textContent = '🔒';
    setTooltipContent(
      createElement(
        Fragment,
        null,
        createElement('strong', null, LL$3.apiKeyRequired()),
        createElement('br', null),
        LL$3.apiKeyWarning({ provider: provider2 })
      )
    );
  };
  const showError = error => {
    navbarText.textContent = '❌';
    setTooltipContent(
      createElement(
        Fragment,
        null,
        LL$3.fetchError(),
        createElement('hr', null),
        createElement('pre', { className: 'text-wrap word-break text-white text-left' }, error.toString())
      )
    );
  };
  let updateTimeout;
  const updateWeatherChannelName = PREFIX('weather-update-weather');
  const updateWeatherChannel = new BroadcastChannel(updateWeatherChannelName);
  updateWeatherChannel.addEventListener('message', () => void updateWeather());
  const updateWeather = async () => {
    if (!navbarItem) return;
    setTooltipContent('⏳️');
    let response = null;
    if ('wttrIn' === provider.value) response = await wttrIn(CITY.name).catch(showError);
    else if ('openMeteo' === provider.value) response = await openMeteo(CITY.lat, CITY.lon).catch(showError);
    else if ('visualCrossing' === provider.value) {
      const apiKey = apiKeys.get('visualCrossing')?.value ?? '';
      if (!apiKey) showInvalidAPIKey(LL$3.providers.visualCrossing());
      else response = await visualCrossing(CITY.name, apiKey).catch(showError);
    } else if ('openWeatherMap' === provider.value) {
      const apiKey = apiKeys.get('openWeatherMap')?.value ?? '';
      if (!apiKey) showInvalidAPIKey(LL$3.providers.openWeatherMap());
      else response = await openWeatherMap(CITY.lat, CITY.lon, apiKey).catch(showError);
    } else return;
    const { value: weather, cached } = response ?? { value: void 0, cached: true };
    if (updateTimeout) clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() => void updateWeather(), 3e5);
    if (!weather) {
      detailsModal?.unsetTrigger(navbarItem);
      detailsModal?.hide();
      return;
    }
    if (!cached) updateWeatherChannel.postMessage('');
    const weatherEmoji = getWeatherEmoji(weather.condition);
    navbarText.textContent = weatherEmoji;
    if (0 === weather.condition) {
      setTooltipContent(`${weatherEmoji} ${LL$3.conditions[0]()}`);
      return;
    }
    if (tempInNav.value) {
      if (feelLikeTempInNav.value) {
        navbarText.textContent += ` ${stringify(weather.temperature.feel, 'temperature', currentUnit())}`;
      } else navbarText.textContent += ` ${stringify(weather.temperature.actual, 'temperature', currentUnit())}`;
    }
    const date = new Date(weather.meta.time);
    const weatherSummary = `${weatherEmoji} ${LL$3.conditions[weather.condition]()}`;
    setTooltipContent(
      createElement(
        Fragment,
        null,
        createElement('strong', null, weatherSummary),
        createElement('br', null),
        '🌡️: ',
        stringify(weather.temperature.actual, 'temperature', currentUnit()),
        ' (',
        stringify(weather.temperature.feel, 'temperature', currentUnit()),
        ')',
        createElement('br', null),
        '🪁: ',
        stringify(weather.wind.speed, 'speed', currentUnit()),
        ' (',
        windDegreesToDirection(weather.wind.direction),
        ')',
        createElement('br', null),
        '💦: ',
        stringify(weather.precipitation, 'distanceMm', currentUnit()),
        createElement('br', null),
        createElement('br', null),
        createElement('small', null, LL$3.providers[provider.value](), ' ⋅ ', timeToString(date, false))
      )
    );
    const modalTitle = `${weatherEmoji} ${LL$3.modal.title({ city: CITY.display })}`;
    detailsModal ??= new Modal({
      type: 'ALERT',
      title: modalTitle,
      body: detailsModalBody,
      bodyClass: ['table-responsive', 'p-0'],
      footer: detailsModalFooter,
      removeOnClose: false,
    }).setTrigger(navbarItem);
    detailsModal.getTitle().then(([title]) => (title.textContent = modalTitle));
    detailsModalTBody.replaceChildren(
      createElement(
        'tr',
        null,
        createElement('th', null, LL$3.modal.condition()),
        createElement('td', null, weatherSummary)
      ),
      createElement(
        'tr',
        null,
        createElement('th', null, LL$3.modal.temperature(), ' (', LL$3.modal.temperatureFeelsLike(), ')'),
        createElement(
          'td',
          null,
          stringify(weather.temperature.actual, 'temperature', currentUnit()),
          ' ',
          '(',
          stringify(weather.temperature.feel, 'temperature', currentUnit()),
          ')'
        )
      ),
      createElement(
        'tr',
        null,
        createElement('th', null, LL$3.modal.wind(), ' (', LL$3.modal.windDirection(), ')'),
        createElement(
          'td',
          null,
          stringify(weather.wind.speed, 'speed', currentUnit()),
          ' (',
          windDegreesToDirection(weather.wind.direction),
          ')'
        )
      ),
      createElement(
        'tr',
        null,
        createElement('th', null, LL$3.modal.visibility()),
        createElement('td', null, stringify(weather.visibility, 'distanceKm', currentUnit()))
      ),
      createElement(
        'tr',
        null,
        createElement('th', null, LL$3.modal.humidity()),
        createElement('td', null, percent(weather.humidity))
      ),
      createElement(
        'tr',
        null,
        createElement('th', null, LL$3.modal.pressure()),
        createElement('td', null, stringify(weather.pressure, 'pressure', currentUnit()))
      ),
      createElement(
        'tr',
        null,
        createElement('th', null, LL$3.modal.cloudCover()),
        createElement('td', null, percent(weather.cloudCover))
      ),
      createElement(
        'tr',
        null,
        createElement('th', null, LL$3.modal.precipitation()),
        createElement('td', null, stringify(weather.precipitation, 'distanceMm', currentUnit()))
      )
    );
    detailsModalFooter.replaceChildren(
      createElement(
        Fragment,
        null,
        LL$3.modal.source(),
        ': ',
        createElement('a', { href: weather.meta.providerURL, target: '_blank' }, LL$3.providers[provider.value]()),
        ' ⋅ ',
        timeToString(date, false),
        ' ⋅ ',
        createElement('a', { href: weather.meta.requestURL, target: '_blank' }, LL$3.modal.raw())
      )
    );
  };
  const reload$b = () => {
    if (!enabled$e.value) {
      navbarItem?.remove();
      return;
    }
    navbarItem ??= createElement(
      NavbarItem,
      { order: 800, dataset: { toggle: 'tooltip', placement: 'bottom', html: 'true' } },
      navbarText
    );
    navbarItem.put();
    updateWeather();
  };
  const settings$1 = new Set([enabled$e, tempInNav, feelLikeTempInNav, units, provider, ...apiKeys.values()]);
  settings$1.forEach(setting => setting.onChange(reload$b));
  const __vite_glob_0_11 = FeatureGroup.register({ settings: settings$1, onload: reload$b, onunload: reload$b });
  importCSS(
    '@media (min-width: 840px) {\n  .block-myoverview .card-grid[data-region=card-deck] > .col {\n    --width: calc(100% / var(--boxes-per-row, 4));\n    min-width: var(--width) !important;\n    width: var(--width) !important;\n    max-width: var(--width) !important;\n  }\n}'
  );
  class Feature {
    static register({ settings: settings2, ...methods }) {
      return class Feature extends this {
        constructor(id, group) {
          super(id, group, settings2 ?? new Set(), methods);
        }
      };
    }
    #id;
    #group;
    #settings;
    #onload;
    #onunload;
    #FormGroups = [];
    #loaded = false;
    constructor(id, group, settings2, methods) {
      this.#id = id;
      this.#group = group;
      this.#settings = settings2;
      this.#onload = methods.onload;
      this.#onunload = methods.onunload;
      this.#settings.forEach(setting => {
        setting.feature = this;
        this.#FormGroups.push(setting.formGroup);
      });
    }
    get id() {
      return `${this.#group.id}.${this.#id}`;
    }
    get Translation() {
      return 'features' in this.#group.Translation ? this.#group.Translation.features[this.#id] : void 0;
    }
    get formGroups() {
      return this.#FormGroups;
    }
    get hasNewSetting() {
      return this.#settings.values().some(setting => setting.isNewSetting);
    }
    get settingIDs() {
      return this.#settings.values().map(setting => setting.id);
    }
    get settingIDMap() {
      return new Map(this.#settings.values().flatMap(setting => setting.idMap.entries()));
    }
    load() {
      if (this.#loaded) throw Error(`Feature ${this.id} already loaded.`);
      this.#loaded = true;
      this.#onload?.();
    }
    unload() {
      if (!this.#loaded) throw Error(`Feature ${this.id} already unloaded.`);
      this.#loaded = false;
      this.#onunload?.();
    }
    reload() {
      this.unload();
      this.load();
    }
    resetSettings() {
      this.#settings.forEach(setting => setting.reset());
    }
    undoSettings() {
      this.#settings.forEach(setting => setting.undo());
    }
    saveSettings() {
      this.#settings.forEach(setting => setting.save());
    }
  }
  const setAmount = () =>
    document
      .querySelector('[data-region="courses-view"]')
      ?.style.setProperty('--boxes-per-row', amount.value.toString());
  const amount = new SliderSetting('amount', 4, { min: 1, max: 10, step: 1, labels: 10 })
    .addAlias('myCourses.boxesPerRow')
    .onInput(setAmount);
  const __vite_glob_1_0 = Feature.register({ settings: new Set([amount]), onload: () => setAmount() });
  const enabled$d = new BooleanSetting('enabled', true).addAlias('courses.grades');
  const newTab = new BooleanSetting('newTab', false)
    .addAlias('courses.gradesNewTab')
    .disabledIf(enabled$d, '==', false);
  let gradesLink;
  newTab.onInput(() => {
    if (newTab.value) {
      if (gradesLink) gradesLink.target = '_blank';
    } else gradesLink?.removeAttribute('target');
  });
  const reload$a = async () => {
    await ready();
    const header = document.querySelector('#theme_boost-drawers-courseindex .drawerheader');
    if (enabled$d.value && header) {
      requirePromise(['core/config']).then(([config]) => {
        const courseId = config.courseId;
        if (!courseId || 1 === courseId) return;
        gradesLink ??= createElement(
          'a',
          { className: 'w-100 text-center', href: `/grade/report/user/index.php?id=${courseId}` },
          createElement('i', { className: 'icon fa fa-calculator fa-fw' }),
          ' ',
          LLF('courses', 'grades').grades()
        );
        if (newTab.value) gradesLink.target = '_blank';
        const headercontent = header.querySelector('.drawerheadercontent');
        if (headercontent) headercontent.before(gradesLink);
        else header.append(gradesLink);
      });
    } else gradesLink?.remove();
  };
  enabled$d.onInput(() => void reload$a());
  const __vite_glob_1_1 = Feature.register({
    settings: new Set([enabled$d, newTab]),
    onload: reload$a,
    onunload: reload$a,
  });
  const hide = new BooleanSetting('hide', false).addAlias('courses.hideSelfEnrolHint');
  let hideStyle;
  const reload$9 = () => {
    if (hide.value) {
      if (hideStyle) document.head.append(hideStyle);
      else hideStyle = GM_addStyle('.course-hint-selfenrol.alert.alert-info {\n  display: none !important;\n}');
    } else hideStyle?.remove();
  };
  hide.onInput(reload$9);
  const __vite_glob_1_2 = Feature.register({ settings: new Set([hide]), onload: reload$9, onunload: reload$9 });
  const zoomStyle = {
    zoomEnabled: 'better-moodle_courses-images-zoom__zoom-enabled',
    overlay: 'better-moodle_courses-images-zoom__overlay',
  };
  const maxWidth = new BooleanSetting('maxWidth', true).addAlias('courses.imgMaxWidth');
  const zoom = new BooleanSetting('zoom', true).addAlias('courses.imageZoom');
  let maxWidthStyleEl;
  const zoomOverlay = createElement('div', { id: zoomStyle.overlay });
  let zoomCopiedImage;
  let zoomEventListenerAdded = false;
  let zoomResizeListenerAdded = false;
  zoomOverlay.addEventListener('click', () => {
    zoomOverlay.remove();
    zoomCopiedImage?.remove();
  });
  const zoomImage = e => {
    const target = e.target;
    if (!(target instanceof HTMLImageElement)) return;
    if ('zoom-in' !== getComputedStyle(target).cursor) return;
    e.preventDefault();
    zoomCopiedImage = target.cloneNode(true);
    zoomCopiedImage.style.removeProperty('margin');
    zoomCopiedImage.style.removeProperty('width');
    zoomCopiedImage.style.removeProperty('height');
    zoomCopiedImage.style.setProperty('display', 'block');
    zoomCopiedImage.removeAttribute('width');
    zoomCopiedImage.removeAttribute('height');
    zoomCopiedImage.addEventListener('load', adjustZoomedImageSize);
    zoomOverlay.append(zoomCopiedImage);
    document.body.append(zoomOverlay);
  };
  const adjustZoomedImageSize = () => {
    if (!zoom.value || !zoomCopiedImage) return;
    const { naturalWidth: width, naturalHeight: height } = zoomCopiedImage;
    if (!width || !height) {
      zoomCopiedImage.style.setProperty('max-width', '90%');
      zoomCopiedImage.style.setProperty('max-height', '90%');
      zoomCopiedImage.style.setProperty('transform', 'scale(1)');
      return;
    }
    const maxWidth2 = 0.9 * window.innerWidth;
    const maxHeight = 0.9 * window.innerHeight;
    const scale = Math.min(maxWidth2 / width, maxHeight / height);
    zoomCopiedImage.style.setProperty('transform', `scale(${scale})`);
  };
  const onload$6 = async () => {
    await ready();
    if (maxWidth.value) {
      maxWidthStyleEl ??= GM_addStyle('#region-main img:not(.activityicon):not(.icon) {\n  max-width: 100%;\n}');
      document.head.append(maxWidthStyleEl);
    } else maxWidthStyleEl?.remove();
    document.body.classList.toggle(zoomStyle.zoomEnabled, zoom.value);
    const mainRegion = document.querySelector('#region-main');
    if (zoom.value) {
      if (!zoomEventListenerAdded) {
        mainRegion?.addEventListener('click', zoomImage);
        zoomEventListenerAdded = true;
      } else {
        mainRegion?.removeEventListener('click', zoomImage);
        zoomEventListenerAdded = false;
      }
      if (!zoomResizeListenerAdded) {
        window.addEventListener('resize', adjustZoomedImageSize);
        zoomResizeListenerAdded = true;
      } else {
        window.removeEventListener('resize', adjustZoomedImageSize);
        zoomResizeListenerAdded = false;
      }
    }
  };
  maxWidth.onInput(() => void onload$6());
  zoom.onInput(() => void onload$6());
  const __vite_glob_1_3 = Feature.register({
    settings: new Set([maxWidth, zoom]),
    onload: onload$6,
    onunload: () => {
      maxWidthStyleEl?.remove();
      document.body.classList.remove(zoomStyle.zoomEnabled);
      document.querySelector('#region-main')?.removeEventListener('click', zoomImage);
      window.removeEventListener('resize', adjustZoomedImageSize);
      zoomEventListenerAdded = false;
      zoomResizeListenerAdded = false;
    },
  });
  const style$3 = { desktop: 'better-moodle_courses-navbarDropdown__desktop' };
  const availableFilters = [];
  let activeFilter = null;
  const getFilterFromEl = (el, customfieldname, setActive = false) => {
    const active = setActive || 'true' === el.ariaCurrent;
    const filter2 = {
      classification: el.dataset.pref ?? '',
      customfieldname,
      customfieldvalue: el.dataset.customfieldvalue ?? '',
      name: el.textContent?.trim() ?? '',
    };
    if (active) activeFilter = filter2;
    return filter2;
  };
  const getAvailableCourseFilters = async () => {
    if (availableFilters.length) return availableFilters;
    if (!(await isLoggedIn())) return [];
    const result0 = await Promise.all([
      requirePromise(['block_myoverview/selectors']),
      getDocument('/my/courses.php').then(({ value }) => value),
    ]);
    const [[selectors], doc] = result0;
    const customfieldname = doc.querySelector(selectors.courseView.region)?.dataset.customfieldname ?? '';
    const filters = Array.from(doc.querySelectorAll('#groupingdropdown + .dropdown-menu [data-filter="grouping"]')).map(
      el => getFilterFromEl(el, customfieldname)
    );
    availableFilters.splice(0, availableFilters.length, ...filters);
    return availableFilters;
  };
  const getActiveFilter = () => activeFilter;
  const activeFilterChangedHooks = new Set();
  const onActiveFilterChanged = callback => activeFilterChangedHooks.add(callback);
  const updateActiveFilterChannelName = PREFIX('myCourses-update-active-filter');
  if (isDashboard) {
    new BroadcastChannel(updateActiveFilterChannelName).addEventListener('message', ({ data }) => {
      activeFilter = data;
      activeFilterChangedHooks.forEach(hook => hook(data));
    });
  }
  if ('/my/courses.php' === window.location.pathname) {
    requirePromise(['jquery', 'block_myoverview/selectors', 'core/custom_interaction_events']).then(
      ([jquery, selectors, events2]) =>
        jquery('.block-myoverview')
          ?.find(selectors.FILTERS)
          ?.on(events2.events.activate, selectors.FILTER_OPTION, ({ target }) => {
            if (!target || !(target instanceof HTMLElement)) return;
            const filter2 = getFilterFromEl(
              target,
              document.querySelector(selectors.courseView.region)?.dataset.customfieldname ?? '',
              true
            );
            const channel = new BroadcastChannel(updateActiveFilterChannelName);
            channel.postMessage(filter2);
            channel.close();
          })
    );
  }
  const enabled$c = new BooleanSetting('enabled', true).addAlias('myCourses.navbarDropdown').requireReload();
  const filter = new SelectSetting(
    'filter',
    '_sync',
    (() =>
      getAvailableCourseFilters().then(filters =>
        filters.map(filter2 => ({ key: JSON.stringify(filter2), title: filter2.name })).toSpliced(0, 0, '_sync')
      ))()
  )
    .addAlias('myCourses.navbarDropdownFilter')
    .disabledIf(enabled$c, '==', false);
  const favouriteCoursesAtTop$1 = new BooleanSetting('favouriteCoursesAtTop', true)
    .addAlias('myCourses.navbarDropdownFavouritesAtTop')
    .disabledIf(enabled$c, '!=', true);
  let desktopNavItem;
  let mobileDropdown;
  const loadContent = ({
    desktopElement = desktopNavItem,
    mobileElement = mobileDropdown,
    myCoursesIsActive,
    myCoursesUrl,
    myCoursesText,
  }) => {
    if (!desktopElement || !mobileElement) return;
    let contentLoaded = false;
    getLoadingSpinner().then(spinner => {
      spinner.classList.add('text-center');
      if (!contentLoaded) desktopElement.querySelector('.dropdown-menu')?.replaceChildren(spinner);
    });
    Promise.all([
      '_sync' === filter.value ?
        getAvailableCourseFilters().then(getActiveFilter)
      : Promise.resolve(JSON.parse(filter.value)),
      requirePromise(['core/templates', 'block_myoverview/repository']),
    ])
      .then(([filter2, [templates, myCourses]]) => {
        if (!filter2) throw new Error("Couldn't find a filter to use for fetching courses.");
        return myCourses
          .getEnrolledCoursesByTimeline({
            classification: filter2.classification,
            customfieldname: filter2.customfieldname,
            customfieldvalue: filter2.customfieldvalue,
            limit: 0,
            offset: 0,
            sort: 'shortname',
          })
          .then(({ courses }) => ({ courses, templates }));
      })
      .then(({ courses, templates }) => {
        if (favouriteCoursesAtTop$1.value) courses.sort((a, b) => Number(b.isfavourite) - Number(a.isfavourite));
        const courseItems = courses.map(course => ({
          isactive: false,
          url: course.viewurl,
          title: `${course.shortname}
${course.fullname}`,
          text: getHtml(
            createElement(
              Fragment,
              null,
              course.isfavourite ?
                createElement('i', { className: 'icon fa fa-star fa-fw' })
              : createElement(Fragment, null),
              course.shortname ? createElement('strong', null, course.shortname) : createElement(Fragment, null),
              ' ',
              createElement('small', null, course.fullname)
            )
          ),
        }));
        const children = [{ isactive: false, url: myCoursesUrl, text: `[${myCoursesText}]` }, ...courseItems];
        const desktop = templates.renderForPromise('core/moremenu_children', {
          moremenuid: PREFIX('my_courses-navbar_dropdown-desktop'),
          classes: style$3.desktop,
          text: myCoursesText,
          isactive: myCoursesIsActive,
          haschildren: true,
          children,
        });
        const mobile = renderCustomTemplate(
          'myCourses/navbarDropdown/mobile',
          '{{#includeTrigger}}<a id="drop-down-{{sort}}" href="#" class="list-group-item list-group-item-action icons-collapse-expand collapsed d-flex" data-toggle="collapse" data-target="#drop-down-menu-{{sort}}" aria-expanded="false" aria-controls="drop-down-menu-{{sort}}">  {{{text}}}  <span class="ml-auto expanded-icon icon-no-margin mx-2">  {{#pix}} t/expanded, core {{/pix}}  <span class="sr-only">  {{#str}} collapse, core {{/str}}  </span>  </span>  <span class="ml-auto collapsed-icon icon-no-margin mx-2">  {{#pix}} t/collapsed, core {{/pix}}  <span class="sr-only">  {{#str}} expand, core {{/str}}  </span>  </span></a>{{/includeTrigger}}<div class="collapse {{#isopen}}show {{/isopen}}list-group-item p-0 border-0" role="menu" id="drop-down-menu-{{sort}}" aria-labelledby="drop-down-{{sort}}">  {{#children}}  {{^divider}}  <a href="{{{url}}}" class="ps-5 {{^isactive}}bg-light{{/isactive}}{{#isactive}}active{{/isactive}} list-group-item list-group-item-action">{{{text}}}</a>  {{/divider}}  {{/children}}</div>',
          {
            includeTrigger: mobileElement instanceof HTMLAnchorElement,
            sort: PREFIX('my_courses-navbar_dropdown-mobile'),
            text: myCoursesText,
            children,
          }
        );
        return Promise.all([desktop, mobile]);
      })
      .then(([desktopTemplate, mobileTemplate2]) => {
        contentLoaded = true;
        const desktopEls = putTemplate(desktopElement, desktopTemplate, 'replaceWith');
        const mobileEls = putTemplate(mobileElement, mobileTemplate2, 'replaceWith');
        return Promise.all([desktopEls, mobileEls]);
      })
      .then(([[navItem], mobile]) => {
        desktopNavItem = navItem;
        const mobileDropdownEl = 2 === mobile.length ? mobile[1] : mobile[0];
        mobileDropdown = mobileDropdownEl;
        if (!myCoursesIsActive) {
          navItem.querySelector('.dropdown-toggle')?.addEventListener('click', e => {
            if (navItem.classList.contains('show')) {
              e.preventDefault();
              window.location.replace(myCoursesUrl);
            }
          });
        }
      });
  };
  const __vite_glob_1_4 = Feature.register({
    settings: new Set([enabled$c, filter, favouriteCoursesAtTop$1]),
    onload: async () => {
      if (!enabled$c.value) return;
      await ready();
      const myCoursesElement = document.querySelector('.primary-navigation .nav-item[data-key="mycourses"]');
      const myCoursesLink = myCoursesElement?.querySelector(':scope > a.nav-link');
      if (!myCoursesElement || !myCoursesLink) return;
      const myCoursesIsActive = myCoursesLink.classList.contains('active');
      const myCoursesUrl = myCoursesLink.href;
      const myCoursesText = myCoursesLink.textContent?.trim() ?? '';
      const mobileMyCoursesLink = document.querySelector(
        `#theme_boost-drawers-primary .list-group-item[href="${myCoursesLink.href}"]`
      );
      if (!mobileMyCoursesLink) return;
      myCoursesLink.classList.add(globalStyle.awaitsDropdown);
      loadContent({
        desktopElement: myCoursesElement,
        mobileElement: mobileMyCoursesLink,
        myCoursesIsActive,
        myCoursesUrl,
        myCoursesText,
      });
      favouriteCoursesAtTop$1.onChange(() => loadContent({ myCoursesIsActive, myCoursesUrl, myCoursesText }));
      filter.onChange(() => loadContent({ myCoursesIsActive, myCoursesUrl, myCoursesText }));
      onActiveFilterChanged(() => {
        if ('_sync' === filter.value) loadContent({ myCoursesIsActive, myCoursesUrl, myCoursesText });
      });
    },
  });
  const enabled$b = new BooleanSetting('enabled', true).addAlias('general.noDownload');
  const removeForceDownload = anchor => {
    try {
      const url = new URL(anchor.href, window.location.origin);
      if (url.searchParams.has('forcedownload')) {
        url.searchParams.delete('forcedownload');
        anchor.href = url.href;
      }
    } catch {}
  };
  const removeListener = event => {
    const target = event.target;
    if (!(target instanceof Element)) return;
    const anchor = target?.closest('a[href*="forcedownload"]');
    if (!anchor) return;
    removeForceDownload(anchor);
  };
  const reload$8 = () => {
    if (enabled$b.value) {
      ready().then(() => document.querySelectorAll('a[href*="forcedownload"]').forEach(removeForceDownload));
      document.addEventListener('mousedown', removeListener);
    } else document.removeEventListener('mousedown', removeListener);
  };
  enabled$b.onInput(() => void reload$8());
  const __vite_glob_1_5 = Feature.register({ settings: new Set([enabled$b]), onload: reload$8, onunload: reload$8 });
  const enabled$a = new BooleanSetting('enabled', true).addAlias('general.quickRoleChange');
  let menuItem;
  let menuItemLink;
  let submenu;
  const getAvailableRoles = () =>
    getDocument(menuItemLink)
      .then(({ value: doc }) => doc.querySelectorAll('form[action*="switchrole.php"]'))
      .then(forms =>
        Array.from(forms).map(form => ({
          title: form.textContent?.trim() ?? '',
          text: form.textContent?.trim() ?? '',
          url: '#',
          attributes: [{ key: 'data-role', value: new FormData(form).get('switchrole') ?? -1 }],
          link: true,
        }))
      );
  const switchRole = e => {
    const target = e.target;
    if (!(target instanceof HTMLAnchorElement)) return;
    const role = target.dataset.role;
    if (!role || '-1' === role) return;
    e.preventDefault();
    requirePromise(['core/config'])
      .then(([{ courseId, sesskey }]) => {
        const formData = new FormData();
        formData.set('id', courseId?.toString() ?? '');
        formData.set('switchrole', role);
        formData.set('returnurl', window.location.href);
        formData.set('sesskey', sesskey);
        return fetch('/course/switchrole.php', { method: 'post', body: formData });
      })
      .then(res => window.location.replace(res.url));
  };
  const preventDefault = e => e.preventDefault();
  const reload$7 = async () => {
    if (enabled$a.value) {
      await ready();
      menuItem = document.querySelector('.dropdown-item[href*="switchrole.php"][href*="switchrole=-1"]');
      const carouselInner = document.querySelector('#usermenu-carousel .carousel-inner');
      if (!menuItem || !carouselInner) return;
      if (submenu) carouselInner.append(submenu);
      menuItemLink = menuItem.href;
      const [menu] = await (submenu ?
        Promise.resolve([submenu])
      : getAvailableRoles()
          .then(roleItems =>
            renderCustomTemplate(
              'user-menu-carousel-submenu',
              '<div id="carousel-item-{{id}}" role="menu" class="carousel-item submenu" tabindex="-1" aria-label="{{title}}">  <div class="d-flex flex-column h-100">  <div class="header">  <button type="button" class="btn btn-icon carousel-navigation-link text-decoration-none text-body" data-carousel-target-id="carousel-item-main" aria-label="{{#str}}usermenugoback{{/str}}">  <span class="dir-rtl-hide">{{#pix}}i/arrow-left{{/pix}}</span>  <span class="dir-ltr-hide">{{#pix}}i/arrow-right{{/pix}}</span>  </button>  <span class="ps-2" id="carousel-item-title-{{id}}">{{title}}</span>  </div>  <div class="dropdown-divider"></div>  <div class="items h-100 overflow-auto" role="menu" aria-labelledby="carousel-item-title-{{id}}">  {{>core/user_action_menu_submenu_items}}  </div>  </div></div>',
              {
                id: PREFIX('courses-quick_role_change-submenu'),
                title: menuItem?.textContent?.trim() ?? '',
                items: roleItems,
              }
            )
          )
          .then(template => putTemplate(carouselInner, template, 'append')));
      submenu = menu;
      submenu.addEventListener('click', switchRole);
      menuItem.href = '#';
      menuItem.classList.add('carousel-navigation-link');
      menuItem.dataset.carouselTargetId = submenu.id;
      menuItem.addEventListener('click', preventDefault);
    } else {
      if (menuItem) {
        menuItem.href = menuItemLink;
        menuItem.classList.remove('carousel-navigation-link');
        delete menuItem.dataset.carouselTargetId;
        menuItem.removeEventListener('click', preventDefault);
      }
      submenu?.removeEventListener('click', switchRole);
      submenu?.remove();
    }
  };
  enabled$a.onInput(() => void reload$7());
  const __vite_glob_1_6 = Feature.register({ settings: new Set([enabled$a]), onload: reload$7, onunload: reload$7 });
  const enabled$9 = new BooleanSetting('enabled', true);
  const reload$6 = async () => {
    if ('/course/view.php' !== window.location.pathname) return;
    await mdlJSComplete('core_courseformat/placeholder:loadcourseindex');
    const linkSelector = '.courseindex-section .courseindex-section-title .courseindex-link';
    if (enabled$9.value) {
      document.querySelectorAll(linkSelector).forEach(link => {
        const sectionNumber = link.closest('.courseindex-section[data-number]')?.dataset.number;
        if (!sectionNumber) return;
        link.dataset.originalLink = link.href;
        link.href = `#section-${sectionNumber}`;
      });
    } else {
      document.querySelectorAll(linkSelector).forEach(link => {
        link.href = link.dataset.originalLink ?? '';
      });
    }
  };
  enabled$9.onInput(() => void reload$6());
  const __vite_glob_1_7 = Feature.register({ settings: new Set([enabled$9]), onload: reload$6, onunload: reload$6 });
  const getString = (key, component, param, lang) =>
    requirePromise(['core/str']).then(([{ getString: getString2 }]) => getString2(key, component, param, lang));
  const style$2 = { coursesSidebarFilterMenu: 'better-moodle_dashboard-layout__courses_sidebar-filter-menu' };
  var Side = (Side2 => {
    Side2.Left = 'left';
    Side2.Right = 'right';
    return Side2;
  })(Side || {});
  class Drawer {
    #id;
    #rendered = false;
    #side = 'left';
    #classes = new Set();
    #icon = '';
    #toggleTitle = '';
    #content = createElement(Fragment, null);
    #heading = createElement(Fragment, null);
    #instance = null;
    constructor(id) {
      this.#id = PREFIX(`drawer__${id}`);
    }
    #throwOnRendered() {
      if (this.#rendered) throw new Error(`Drawer #${this.#id} already rendered`);
    }
    setAlias(alias) {
      const undefinedValue = crypto.randomUUID();
      const oldKey = `better-moodle-${alias}-sidebar-open`;
      const oldValue2 = GM_getValue(oldKey, undefinedValue);
      if (oldValue2 !== undefinedValue) {
        GM_deleteValue(oldKey);
        GM_setValue(this.#storageKey, oldValue2);
      }
      return this;
    }
    setSide(side) {
      this.#throwOnRendered();
      this.#side = side;
      return this;
    }
    addClasses(...classes) {
      this.#throwOnRendered();
      classes.forEach(c => this.#classes.add(c));
      return this;
    }
    setIcon(icon) {
      this.#throwOnRendered();
      this.#icon = icon;
      return this;
    }
    setToggleTitle(title) {
      this.#throwOnRendered();
      this.#toggleTitle = title;
      return this;
    }
    setHeading(heading) {
      if (this.#instance) this.#instance.drawerNode.querySelector('.drawerheadercontent')?.replaceChildren(heading);
      else {
        this.#throwOnRendered();
        this.#heading = heading;
      }
      return this;
    }
    setContent(content) {
      if (this.#instance) this.#instance.drawerNode.querySelector('.drawercontent')?.replaceChildren(content);
      else {
        this.#throwOnRendered();
        this.#content = content;
      }
      return this;
    }
    get #oppositeSide() {
      return 'left' === this.#side ? 'right' : 'left';
    }
    get #storageKey() {
      return `drawer.${this.#id}`;
    }
    #render() {
      this.#throwOnRendered();
      this.#rendered = true;
      return renderCustomTemplate(
        'drawer',
        '{{<theme_boost/drawer}}  {{$drawerclasses}}{{{classes}}}{{/drawerclasses}}  {{$id}}{{{id}}}{{/id}}  {{$drawerstate}}{{{state}}}{{/drawerstate}}  {{$tooltipplacement}}{{{tooltip}}}{{/tooltipplacement}}  {{$drawercontent}}{{{content}}}{{/drawercontent}}  {{$drawerheadercontent}}{{{heading}}}{{/drawerheadercontent}}{{/theme_boost/drawer}}',
        {
          classes: `drawer drawer-${this.#side} ${Array.from(this.#classes).join(' ')}`,
          id: this.#id,
          tooltip: this.#oppositeSide,
          state: `show-drawer-${this.#side}`,
          content: getHtml(this.#content),
          drawerheading: getHtml(this.#heading),
        }
      );
    }
    async create() {
      this.#throwOnRendered();
      const template = await this.#render();
      const [[element], [Drawer2, Drawers]] = await Promise.all([
        putTemplate('#page', template, 'before'),
        requirePromise(['theme_boost/drawer', 'theme_boost/drawers']),
      ]);
      element.querySelector('.drawerheadercontent')?.classList.add('w-100', 'd-flex');
      document
        .querySelector('#page .drawer-toggles')
        ?.append(
          createElement(
            'div',
            { className: `drawer-toggler drawer-${this.#side}-toggle ml-auto d-print-none` },
            createElement(
              'button',
              {
                className: 'btn icon-no-margin',
                dataset: {
                  toggler: 'drawers',
                  action: 'toggle',
                  target: this.#id,
                  toggle: 'tooltip',
                  placement: this.#oppositeSide,
                },
                title: this.#toggleTitle,
              },
              createElement('span', { className: 'sr-only' }, this.#toggleTitle),
              createElement('span', null, createElement('i', { className: `icon fa fa-fw fa-${this.#icon}` }))
            )
          )
        );
      Drawer2.init();
      this.#instance = Drawers.getDrawerInstanceForNode(element);
      if (GM_getValue(this.#storageKey, false)) this.#instance.openDrawer();
      const doPubsub = isOpen =>
        void requirePromise(['core/pubsub']).then(([pubsub]) => {
          pubsub.publish('nav-drawer-toggle-start', isOpen);
          setTimeout(() => pubsub.publish('nav-drawer-toggle-end', isOpen), 100);
        });
      this.#instance.drawerNode.addEventListener(Drawers.eventTypes.drawerShown, () => {
        GM_setValue(this.#storageKey, this.#instance?.isOpen);
        this.#instance?.drawerNode.querySelector('.drawerheadercontent')?.classList.remove('hidden');
        doPubsub(true);
      });
      this.#instance.drawerNode.addEventListener(Drawers.eventTypes.drawerHidden, () => {
        GM_setValue(this.#storageKey, this.#instance?.isOpen);
        doPubsub(false);
      });
      this.#instance.drawerNode.addEventListener(Drawers.eventTypes.drawerHide, () =>
        this.#instance?.drawerNode.querySelector('.drawerheadercontent')?.classList.add('hidden')
      );
      return this;
    }
  }
  requirePromise(['theme_boost/drawers']).then(([Drawers]) => {
    const preventOrig = Drawers.prototype.preventOverlap;
    Drawers.prototype.preventOverlap = function (...args) {
      if (!this.boundingRect) return preventOrig.call(this, ...args);
      const origRect = this.boundingRect;
      this.boundingRect.x += 20;
      this.boundingRect.y += 20;
      this.boundingRect.width -= 40;
      this.boundingRect.height -= 40;
      const result = preventOrig.call(this, ...args);
      this.boundingRect = origRect;
      return result;
    };
  });
  const LL$2 = LLF('dashboard', 'layout');
  const coursesSidebarEnabled = new BooleanSetting('coursesSidebar', true).requireReload();
  const favouriteCoursesAtTop = new BooleanSetting('favouriteCoursesAtTop', true)
    .addAlias('dashboard.courseListFavouritesAtTop')
    .disabledIf(coursesSidebarEnabled, '!=', true);
  const timelineSidebarEnabled = new BooleanSetting('timelineSidebar', true).requireReload();
  const oldActiveCourseFilter = GM_getValue('better-moodle-settings.dashboard.courseListFilter', '_sync');
  GM_deleteValue('better-moodle-settings.dashboard.courseListFilter');
  let courseFilter = GM_getValue(
    'dashboard.layout.courseFilter',
    '_sync' === oldActiveCourseFilter ? '_sync' : JSON.parse(oldActiveCourseFilter)
  );
  GM_setValue('dashboard.layout.courseFilter', courseFilter);
  const getCourseBlocks = () =>
    Promise.all([
      '_sync' === courseFilter ? getAvailableCourseFilters().then(getActiveFilter) : Promise.resolve(courseFilter),
      requirePromise(['block_myoverview/repository']),
    ])
      .then(([filter2, [myCourses]]) => {
        if (!filter2) throw new Error("Couldn't find a filter to use for fetching courses.");
        return myCourses.getEnrolledCoursesByTimeline({
          classification: filter2.classification,
          customfieldname: filter2.customfieldname,
          customfieldvalue: filter2.customfieldvalue,
          limit: 0,
          offset: 0,
          sort: 'shortname',
        });
      })
      .then(({ courses }) => {
        if (!courses.length) return [];
        if (favouriteCoursesAtTop.value) courses.sort((a, b) => Number(b.isfavourite) - Number(a.isfavourite));
        return courses.map(course =>
          createElement(
            'div',
            {
              className: 'card block mb-3',
              dataset: { searchText: `${course.shortname} ${course.fullname}`.toLowerCase() },
            },
            createElement(
              'div',
              { className: 'card-body p-3' },
              createElement(
                'a',
                { href: course.viewurl },
                course.isfavourite ?
                  createElement('i', { className: 'icon fa fa-star fa-fw' })
                : createElement(Fragment, null),
                course.shortname ?
                  createElement(
                    Fragment,
                    null,
                    createElement('strong', null, course.shortname),
                    createElement('br', null)
                  )
                : createElement(Fragment, null),
                createElement('small', null, course.fullname)
              )
            )
          )
        );
      });
  const initCourseSidebar = () => {
    const searchStyle = createElement('style', null);
    const toggleSearchBtn = createElement(
      'button',
      { className: 'btn icon-no-margin' },
      createElement('i', { className: 'icon fa fa-search fa-fw' })
    );
    const searchInput = createElement('input', { className: 'form-control', type: 'search' });
    getString('search', 'core').then(search => (searchInput.placeholder = search));
    const searchBar = createElement(
      'div',
      { className: 'input-group hidden', id: domID('dashboard-course-sidebar-search') },
      createElement(
        'div',
        { className: 'input-group-prepend' },
        createElement(
          'span',
          { className: 'input-group-text' },
          createElement('i', { className: 'icon fa fa-search fa-fw m-0' })
        )
      ),
      searchInput
    );
    const updateSearch = debounce(() => {
      const search = searchInput.value.trim().toLowerCase();
      if (0 === search.length) searchStyle.textContent = '';
      else {
        searchStyle.textContent = `#${searchBar.id} ~ .card[data-search-text]:not([data-search-text*="${CSS.escape(search)}"i]) {display: none !important;}`;
      }
    });
    toggleSearchBtn.addEventListener('click', () => {
      searchBar.classList.toggle('hidden');
      if (!searchBar.classList.contains('hidden')) searchInput.focus();
      else {
        searchInput.value = '';
        updateSearch();
      }
    });
    searchInput.addEventListener('input', updateSearch);
    const courseFilterDropdownBtnId = `${style$2.coursesSidebarFilterMenu}-toggle`;
    const filterSelection = createElement('div', {
      'id': style$2.coursesSidebarFilterMenu,
      'className': 'list-group w-100 mb-6 hidden',
      'aria-labelledby': courseFilterDropdownBtnId,
    });
    const syncFilterButton = createElement(
      'button',
      { type: 'button', className: 'list-group-item list-group-item-action' },
      '[',
      LL$2.myCourses.sync(),
      ']'
    );
    const filterButtons = new Map();
    filterButtons.set(syncFilterButton, '_sync');
    getAvailableCourseFilters()
      .then(filters =>
        filterSelection.replaceChildren(
          syncFilterButton,
          ...filters.map(filter2 => {
            const btn = createElement(
              'button',
              { type: 'button', className: 'list-group-item list-group-item-action' },
              filter2.name
            );
            filterButtons.set(btn, filter2);
            return btn;
          })
        )
      )
      .then(() => {
        if ('_sync' === courseFilter) {
          syncFilterButton.classList.add('active');
          return;
        }
        for (const [element, filter2] of filterButtons) {
          if (
            'string' !== typeof filter2 &&
            filter2.classification === courseFilter?.classification &&
            filter2.customfieldvalue === courseFilter?.customfieldvalue
          ) {
            element.classList.add('active');
            return;
          }
        }
      });
    const toggleFilterBtn = createElement(
      'button',
      {
        'id': courseFilterDropdownBtnId,
        'className': 'btn icon-no-margin dropdown-toggle',
        'aria-controls': style$2.coursesSidebarFilterMenu,
      },
      createElement('i', { className: 'icon fa fa-filter fa-fw' })
    );
    const heading = createElement(
      Fragment,
      null,
      createElement(
        'a',
        { className: 'w-100 d-flex align-items-center justify-content-center', href: '/my/courses.php' },
        LL$2.myCourses.title()
      ),
      toggleSearchBtn,
      toggleFilterBtn
    );
    const updateDrawerContent = drawer => {
      let contentLoaded = false;
      getLoadingSpinner().then(spinner => {
        spinner.classList.add('text-center');
        if (!contentLoaded) drawer.setContent(spinner);
      });
      getCourseBlocks().then(blocks => {
        contentLoaded = true;
        if (!blocks.length) {
          drawer.setContent(
            createElement(
              Fragment,
              null,
              filterSelection,
              createElement('span', { className: 'text-muted text-center' }, LL$2.myCourses.empty())
            )
          );
        } else drawer.setContent(createElement(Fragment, null, searchStyle, searchBar, filterSelection, ...blocks));
      });
    };
    new Drawer('dashboard-courses')
      .setAlias('dashboard-left')
      .setSide(Side.Left)
      .setIcon('graduation-cap')
      .create()
      .then(drawer => {
        drawer.setHeading(heading);
        updateDrawerContent(drawer);
        favouriteCoursesAtTop.onChange(() => void updateDrawerContent(drawer));
        onActiveFilterChanged(() => {
          if ('_sync' === courseFilter) updateDrawerContent(drawer);
        });
        toggleFilterBtn.addEventListener('click', event => {
          event.preventDefault();
          filterSelection.classList.toggle('hidden');
          filterSelection.querySelector('.list-group-item.active')?.focus();
        });
        document.addEventListener('click', event => {
          if (filterSelection.classList.contains('hidden')) return;
          const target = event.target;
          if (!(target instanceof Element)) return;
          if (target.closest(`#${filterSelection.id}`) || target.closest(`#${toggleFilterBtn.id}`)) return;
          filterSelection.classList.add('hidden');
        });
        filterSelection.addEventListener('click', event => {
          const target = event.target;
          if (!(target instanceof Element)) return;
          const item = target.closest('.list-group-item');
          if (!item) return;
          courseFilter = filterButtons.get(item) ?? '_sync';
          filterSelection.querySelector('.active')?.classList.remove('active');
          item.classList.add('active');
          GM_setValue('dashboard.layout.courseFilter', courseFilter);
          filterSelection.classList.add('hidden');
          updateDrawerContent(drawer);
        });
      });
  };
  const settings = new Set([coursesSidebarEnabled, favouriteCoursesAtTop, timelineSidebarEnabled]);
  const __vite_glob_1_8 = Feature.register({
    settings,
    onload: async () => {
      if (!isDashboard || !(await isLoggedIn())) return;
      if (coursesSidebarEnabled.value) initCourseSidebar();
      if (timelineSidebarEnabled.value && true) {
        const selector = ['timeline', 'calendar_upcoming']
          .map(block2 => `section[data-block="${block2}"]`)
          .flatMap(block2 => [`a.sr-only:has(+ ${block2})`, block2, `${block2} + span`])
          .join(',');
        new Drawer('dashboard-timeline')
          .setAlias('dashboard-right')
          .setSide(Side.Right)
          .setIcon('calendar')
          .create()
          .then(drawer =>
            drawer.setContent(createElement(Fragment, null, ...Array.from(document.querySelectorAll(selector))))
          );
      }
    },
  });
  const enabled$8 = new BooleanSetting('enabled', true).addAlias('general.externalLinks');
  const modifiedElements$1 = new Map();
  const openInNewTabListener = event => {
    const target = event.target;
    if (!(target instanceof HTMLAnchorElement) || target.target) return;
    const { origin, protocol } = new URL(target.href, window.location.origin);
    if (['javascript:', 'vbscript:'].includes(protocol)) return;
    if (origin && origin !== window.location.origin && '_blank' !== target.target) {
      modifiedElements$1.set(target, target.target);
      target.target = '_blank';
    }
  };
  const reload$5 = () => {
    if (enabled$8.value) document.addEventListener('click', openInNewTabListener);
    else {
      document.removeEventListener('click', openInNewTabListener);
      modifiedElements$1.forEach((origTarget, anchor) => (anchor.target = origTarget));
      modifiedElements$1.clear();
    }
  };
  enabled$8.onInput(reload$5);
  const __vite_glob_1_9 = Feature.register({ settings: new Set([enabled$8]), onload: reload$5, onunload: reload$5 });
  const enabled$7 = new BooleanSetting('enabled', true).addAlias('general.fullwidth');
  const setFullWidth = async state => {
    await ready();
    document.body.classList.toggle('limitedwidth', !state);
    document.getElementById('page-header')?.classList.toggle('header-maxwidth', !state);
    window.dispatchEvent(new Event('resize'));
  };
  const onload$3 = () => void setFullWidth(enabled$7.value);
  enabled$7.onInput(onload$3);
  const __vite_glob_1_10 = Feature.register({
    settings: new Set([enabled$7]),
    onload: onload$3,
    onunload: () => void setFullWidth(false),
  });
  const styles = {
    eyes: 'better-moodle_general-googlyEyes__eyes',
    eye: 'better-moodle_general-googlyEyes__eye',
    pupil: 'better-moodle_general-googlyEyes__pupil',
  };
  const enabled$6 = new BooleanSetting('enabled', false).addTag('fun').addAlias('general.googlyEyes');
  const pupils = new Map();
  const Pupil = () => {
    const pupil = createElement('span', { className: styles.pupil });
    pupils.set(pupil, pupil.getBoundingClientRect());
    return pupil;
  };
  const Eye = () => createElement('span', { className: styles.eye }, createElement(Pupil, null));
  const eyes = createElement('div', { id: styles.eyes }, createElement(Eye, null), createElement(Eye, null));
  const updatePupilPositions = () => pupils.forEach((_, pupil) => pupils.set(pupil, pupil.getBoundingClientRect()));
  const updatePupilPositionsDebounced = debounce(updatePupilPositions, 100);
  const updatePupilTranslations = event => {
    const { clientX: mouseLeft, clientY: mouseTop } = event;
    pupils.forEach((rect, pupil) => {
      const { top, left } = rect;
      const translateX = mouseLeft < left ? mouseLeft / left - 1 : (mouseLeft - left) / (innerWidth - left);
      const translateY = mouseTop < top ? mouseTop / top - 1 : (mouseTop - top) / (innerHeight - top);
      const ease = translation =>
        translation < 0 ? -1 * ease(-1 * translation) : 100 - 100 * Math.pow(1 - translation, 2);
      pupil.style.setProperty('transform', `translateX(${ease(translateX)}%) translateY(${ease(translateY)}%)`);
    });
    updatePupilPositionsDebounced();
  };
  let oldElement;
  const addEyes = () =>
    ready().then(() => {
      oldElement = document.querySelector('.btn-footer-popover > .icon');
      oldElement?.replaceWith(eyes);
      document.addEventListener('mousemove', updatePupilTranslations);
      updatePupilPositions();
    });
  const removeEyes = () =>
    ready().then(() => {
      if (oldElement) eyes.replaceWith(oldElement);
      document.removeEventListener('mousemove', updatePupilTranslations);
    });
  const isTouchDevice = window.matchMedia('(hover: none)').matches;
  const updateEyesStatus = () => {
    if (isTouchDevice) return;
    if (enabled$6.value) addEyes();
    else removeEyes();
  };
  enabled$6.onInput(updateEyesStatus);
  const __vite_glob_1_11 = Feature.register({
    settings: new Set([enabled$6]),
    onload: updateEyesStatus,
    onunload: updateEyesStatus,
  });
  const leftStyle = { pulled: 'better-moodle_general-leftSecondaryNav__pulled' };
  const enabled$5 = new BooleanSetting('enabled', false);
  const setPullLeft = async state => {
    await ready();
    document.body.classList.toggle(leftStyle.pulled, state);
  };
  const onload$2 = () => void setPullLeft(enabled$5.value);
  enabled$5.onInput(onload$2);
  const __vite_glob_1_12 = Feature.register({
    settings: new Set([enabled$5]),
    onload: onload$2,
    onunload: () => void setPullLeft(false),
  });
  const style$1 = {
    prideLogo: 'better-moodle_general-prideLogo__pride-logo',
    rotation180Deg: 'better-moodle_general-prideLogo__rotation-180deg',
    flagRainbow: 'better-moodle_general-prideLogo__flag-rainbow',
    flagAgender: 'better-moodle_general-prideLogo__flag-agender',
    flagAro: 'better-moodle_general-prideLogo__flag-aro',
    flagAce: 'better-moodle_general-prideLogo__flag-ace',
    flagAroace: 'better-moodle_general-prideLogo__flag-aroace',
    flagBi: 'better-moodle_general-prideLogo__flag-bi',
    flagGenderfluid: 'better-moodle_general-prideLogo__flag-genderfluid',
    flagLesbian: 'better-moodle_general-prideLogo__flag-lesbian',
    flagEnby: 'better-moodle_general-prideLogo__flag-enby',
    flagPan: 'better-moodle_general-prideLogo__flag-pan',
    flagGay: 'better-moodle_general-prideLogo__flag-gay',
    flagTrans: 'better-moodle_general-prideLogo__flag-trans',
    flagIntersex: 'better-moodle_general-prideLogo__flag-intersex',
    rotation135Deg: 'better-moodle_general-prideLogo__rotation-135deg',
  };
  const flags = Object.keys(style$1)
    .filter(className2 => className2.startsWith('flag'))
    .map(flag => flag.replace(/^flag/, ''));
  const rotations = Object.keys(style$1)
    .filter(className2 => className2.startsWith('rotation'))
    .map(flag => flag.replace(/^rotation/, ''));
  const flagSetting = new SelectSetting('flag', flags[0], ['off', ...flags]).addAlias('general.prideLogo', oldValue2 =>
    oldValue2.toString().replace(/^[a-z]/, $0 => $0.toUpperCase())
  );
  const rotationSetting = new SelectSetting('rotation', rotations[0], rotations)
    .addAlias('general.prideLogoRotated', rotated => rotations[Number(rotated)])
    .disabledIf(flagSetting, '==', 'off');
  const logoSelector = '.navbar.fixed-top .navbar-brand img, #logoimage';
  const cleanClasses = (logo = document.querySelector(logoSelector)) =>
    logo?.classList.remove(...Object.values(style$1));
  const onload$1 = async () => {
    await ready();
    const logo = document.querySelector(logoSelector);
    cleanClasses(logo);
    if ('off' === flagSetting.value || !logo) {
      logo?.style.removeProperty('mask');
      return;
    }
    const logoPath = new URL(logo.src).href;
    document.documentElement.style.setProperty('--pride-logo-mask-image', `url(${logoPath})`);
    logo.classList.add(
      style$1.prideLogo,
      style$1[`flag${flagSetting.value}`],
      style$1[`rotation${rotationSetting.value}`]
    );
  };
  flagSetting.onInput(() => void onload$1());
  rotationSetting.onInput(() => void onload$1());
  const __vite_glob_1_13 = Feature.register({
    settings: new Set([flagSetting, rotationSetting]),
    onload: onload$1,
    onunload: cleanClasses,
  });
  const enabled$4 = new BooleanSetting('enabled', true).addAlias('general.truncatedTexts');
  const modifiedElements = new Set();
  const setTitleListener = event => {
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;
    if (target.title || !target.classList.contains('text-truncate')) return;
    target.title = target.textContent?.trim() ?? '';
    modifiedElements.add(target);
  };
  const reload$4 = () => {
    if (enabled$4.value) document.addEventListener('mouseover', setTitleListener);
    else {
      document.removeEventListener('mouseover', setTitleListener);
      modifiedElements.forEach(element => element.removeAttribute('title'));
      modifiedElements.clear();
    }
  };
  enabled$4.onInput(reload$4);
  const __vite_glob_1_14 = Feature.register({ settings: new Set([enabled$4]), onload: reload$4, onunload: reload$4 });
  const enabled$3 = new BooleanSetting('markdownSupport', true).addAlias('messages.markdown');
  const mathJaxReady = () =>
    new Promise(resolve => {
      const interval = setInterval(() => {
        if (unsafeWindow.MathJax) {
          clearInterval(interval);
          resolve(unsafeWindow.MathJax);
        }
      }, 10);
    });
  const parseMarkdown = async inputElem => {
    const MathJax = await mathJaxReady();
    const dummy = document.createElement('span');
    const raw = inputElem.value;
    dummy.innerHTML = raw.replace(/(?<!\\)\$(.*?)(?<!\\)\$/g, '\\($1\\)');
    MathJax.Hub.Queue(['Typeset', MathJax.Hub, dummy]);
    const mathJaxed = dummy.innerHTML;
    const markdowned = mdToHtml(
      `
${mathJaxed}`,
      1
    );
    dummy.innerHTML = markdowned;
    const spacecaped = dummy.innerHTML.replaceAll('> <', '>&#32;<');
    dummy.innerHTML = spacecaped;
    return dummy.innerText.length > 0 ? spacecaped : '';
  };
  const inputFieldRegion = domID('send-message-txt');
  const SELECTORS = {
    messageApp: '.message-app',
    inputField: '[data-region="send-message-txt"]',
    sendBtn: '[data-action="send-message"]',
    emojiPickerBtn: '[data-action="toggle-emoji-picker"]',
    emojiPickerContainer: '[data-region="emoji-picker-container"]',
    emojiAutoCompleteContainer: '[data-region="emoji-auto-complete-container"]',
    emojiAutoComplete: '[data-region="emoji-auto-complete"]',
    emojiPicker: '[data-region="emoji-picker"]',
  };
  const messageApps$1 = new Map();
  const dummyFieldTemplate = createElement('textarea', { className: 'd-none' });
  const emojiPickerBtnClickEventGenerator = messageApp => () => {
    const container = messageApp.querySelector(SELECTORS.emojiPickerContainer);
    if (!container) return;
    container.classList.toggle('hidden');
  };
  const getEmojiCallback = (containerElement, messageApp, replaceWord = false) => {
    const { inputField, dummyField } = messageApps$1.get(messageApp) ?? {};
    return emoji => {
      if (!inputField || !dummyField) return;
      containerElement.classList.add('hidden');
      inputField.focus();
      const cursorPos = inputField.selectionStart;
      if (!cursorPos) return;
      const currentText = inputField.value;
      const textBefore = currentText.substring(0, cursorPos).replace(replaceWord ? /\S*$/ : '', '');
      const textAfter = currentText.substring(cursorPos).replace(replaceWord ? /^\S*/ : '', '');
      inputField.value = textBefore + emoji + textAfter;
      inputField.setSelectionRange(textBefore.length + emoji.length, textBefore.length + emoji.length);
      if (dummyField) parseMarkdown(inputField).then(md => (dummyField.value = md));
    };
  };
  const putEmojiAutoComplete = async messageApp => {
    await ready();
    const container = messageApp.querySelector(SELECTORS.emojiAutoCompleteContainer);
    const inputField = messageApps$1.get(messageApp)?.inputField;
    if (!container || !inputField) return;
    container.classList.add('hidden');
    container.querySelector(SELECTORS.emojiAutoComplete)?.remove();
    render('core/emoji/auto_complete', {})
      .then(template =>
        Promise.all([requirePromise(['core/emoji/auto_complete']), putTemplate(container, template, 'append')])
      )
      .then(([[initialiseEmojiAutoComplete], [emojiAutoComplete]]) =>
        initialiseEmojiAutoComplete(
          container,
          inputField,
          show => container.classList.toggle('hidden', !show),
          getEmojiCallback(emojiAutoComplete, messageApp, true)
        )
      );
  };
  const putEmojiPicker = async messageApp => {
    await ready();
    const container = messageApp.querySelector(SELECTORS.emojiPickerContainer);
    if (!container) return;
    container.classList.add('hidden');
    container.querySelector(SELECTORS.emojiPicker)?.remove();
    render('core/emoji/picker', {})
      .then(template =>
        Promise.all([requirePromise(['core/emoji/picker']), putTemplate(container, template, 'append')])
      )
      .then(([[initialiseEmojiPicker], [emojiPicker]]) =>
        initialiseEmojiPicker(emojiPicker, getEmojiCallback(container, messageApp))
      );
  };
  const enable = async () => {
    if (!enabled$3.value) return;
    await ready();
    document.querySelectorAll(SELECTORS.messageApp).forEach(messageApp => {
      if (messageApps$1.get(messageApp)?.inputField) return;
      const dummyField = dummyFieldTemplate.cloneNode(true);
      const inputField = messageApp.querySelector(SELECTORS.inputField);
      const sendBtn = messageApp.querySelector(SELECTORS.sendBtn);
      if (!inputField || !sendBtn) return;
      dummyField.dataset.region = inputField.dataset.region;
      inputField.dataset.region = inputFieldRegion;
      inputField.after(dummyField);
      dummyField.addEventListener('focus', () => inputField?.focus());
      const inputEvent = () => {
        if (!dummyField || !inputField) return;
        parseMarkdown(inputField).then(md => (dummyField.value = md));
      };
      inputField.addEventListener('input', inputEvent);
      inputEvent(new Event('input'));
      const keyRelayEvent = e => {
        if (!(e instanceof KeyboardEvent)) return;
        const beforeValue = dummyField?.value;
        if (
          !dummyField?.dispatchEvent(
            new KeyboardEvent('keydown', {
              altKey: e.altKey,
              code: e.code,
              ctrlKey: e.ctrlKey,
              key: e.key,
              keyCode: e.keyCode,
              location: e.location,
              metaKey: e.metaKey,
              shiftKey: e.shiftKey,
              bubbles: true,
              cancelable: true,
            })
          )
        ) {
          e.preventDefault();
        }
        if (inputField && beforeValue !== dummyField?.value && '' === dummyField?.value) inputField.value = '';
      };
      inputField.addEventListener('keydown', keyRelayEvent);
      const sendEvent = () => {
        if (!inputField) return;
        inputField.value = '';
      };
      sendBtn.addEventListener('click', sendEvent);
      const emojiPickerBtn = messageApp.querySelector(SELECTORS.emojiPickerBtn);
      emojiPickerBtn?.addEventListener('click', emojiPickerBtnClickEventGenerator(messageApp));
      emojiPickerBtn?.setAttribute('data-action', domID('toggle-emoji-picker'));
      messageApps$1.set(messageApp, { dummyField, inputField, sendBtn, inputEvent, sendEvent, keyRelayEvent });
      putEmojiAutoComplete(messageApp);
      putEmojiPicker(messageApp);
    });
  };
  const disable = () => {
    if (enabled$3.value) return;
    document.querySelectorAll(SELECTORS.messageApp).forEach(messageApp => {
      const app = messageApps$1.get(messageApp);
      if (!app) return;
      let { inputField, dummyField, sendBtn, inputEvent, sendEvent, keyRelayEvent } = app;
      if (!inputField || !dummyField) return;
      if (sendEvent) {
        sendBtn?.removeEventListener('click', sendEvent);
        sendEvent = void 0;
      }
      if (inputEvent) {
        inputField.removeEventListener('input', inputEvent);
        inputEvent = void 0;
      }
      if (keyRelayEvent) {
        inputField.removeEventListener('keydown', keyRelayEvent);
        keyRelayEvent = void 0;
      }
      inputField.dataset.region = dummyField.dataset.region;
      dummyField.dataset.region = '';
      dummyField.remove();
      inputField = void 0;
      dummyField = void 0;
      sendBtn = void 0;
      const originalInputField = messageApp.querySelector(SELECTORS.inputField);
      messageApps$1.set(messageApp, {
        inputField: originalInputField ?? void 0,
        dummyField,
        sendBtn,
        inputEvent,
        sendEvent,
        keyRelayEvent,
      });
      if (originalInputField) {
        putEmojiAutoComplete(messageApp);
        putEmojiPicker(messageApp);
      }
    });
  };
  const reload$3 = async () => {
    if (enabled$3.value) await enable();
    else disable();
  };
  enabled$3.onInput(() => void reload$3());
  const __vite_glob_1_15 = Feature.register({
    settings: new Set([enabled$3]),
    onload: () => {
      reload$3();
    },
    onunload: () => {
      disable();
    },
  });
  const hotkey = new SelectSetting('sendHotkey', '', ['', 'shiftEnter', 'ctrlEnter']).addAlias('messages.sendHotkey');
  const messageApps = new Map();
  const listener = e => {
    if ('Enter' !== e.key) return;
    const input = e.target;
    if (!(input instanceof HTMLTextAreaElement) || 'send-message-txt' !== input.dataset.region) return;
    const messageApp = messageApps.get(input)?.messageApp ?? input.closest('.message-app');
    if (!messageApp) return;
    if (messageApp.querySelector('.emoji-auto-complete-container:not(.hidden)')) return;
    const submitBtn = messageApps.get(input)?.submitBtn ?? messageApp.querySelector('[data-action="send-message"]');
    if (!submitBtn) return;
    messageApps.set(input, { messageApp, submitBtn });
    switch (hotkey.value) {
      case 'shiftEnter':
        if (e.shiftKey) {
          submitBtn.click();
          e.preventDefault();
        }
        return;
      case 'ctrlEnter':
        if (e.ctrlKey) {
          submitBtn.click();
          e.preventDefault();
        }
    }
  };
  const reload$2 = () => {
    if ('' === hotkey.value) document.removeEventListener('keydown', listener);
    else document.addEventListener('keydown', listener);
  };
  const __vite_glob_1_16 = Feature.register({ settings: new Set([hotkey]), onload: reload$2, onunload: reload$2 });
  const LL$1 = LLF('navbarMarquee', 'christmasCountdown');
  const enabled$2 = new BooleanSetting('enabled', true).addAlias('general.christmasCountdown').addTag('fun');
  const countdownSpan = createElement('span', null, '🎄');
  let countdownSpanClone;
  let timeout;
  const updateCountdown = () => {
    if (!countdownSpanClone) return;
    const now = new Date();
    if (24 === now.getDate() && 11 === now.getMonth()) {
      countdownSpan.innerHTML = countdownSpanClone.innerHTML = LL$1.christmas();
      return;
    }
    const christmas = new Date(now);
    christmas.setDate(24);
    christmas.setMonth(11);
    if (now > christmas) christmas.setFullYear(christmas.getFullYear() + 1);
    const tillThen = christmas.getTime() - now.getTime();
    const daysTillThen = Math.floor(tillThen / 864e5);
    countdownSpan.innerHTML = countdownSpanClone.innerHTML = mdToHtml(
      LL$1.remaining({ days: daysTillThen }),
      void 0,
      void 0,
      false
    );
    marquee.recalculate();
  };
  const reload$1 = () => {
    if (enabled$2.value) {
      [[, countdownSpanClone]] = marquee.add(countdownSpan);
      updateCountdown();
      const midnight = new Date();
      midnight.setHours(0, 0, 0, 0);
      midnight.setTime(midnight.getTime() + 864e5);
      timeout = setTimeout(updateCountdown, midnight.getTime() - Date.now());
    } else {
      marquee.remove(countdownSpan);
      if (timeout) clearTimeout(timeout);
    }
  };
  enabled$2.onInput(reload$1);
  const __vite_glob_1_17 = Feature.register({ settings: new Set([enabled$2]), onload: reload$1, onunload: reload$1 });
  const enabled$1 = new BooleanSetting('enabled', false).addAlias('clock.clock');
  const seconds = new BooleanSetting('seconds', true).addAlias('clock.clock.seconds').disabledIf(enabled$1, '!=', true);
  const oldFuzzyKey = 'better-moodle-settings.clock.fuzzyClock';
  const oldFuzzyEnabled = GM_getValue(oldFuzzyKey, false);
  GM_deleteValue(oldFuzzyKey);
  const fuzzy = new SliderSetting('fuzzy', 0, {
    min: 0,
    max: 5,
    step: 1,
    labels: ['off', '5min', '15min', 'food', 'day', 'week'],
  }).addAlias('clock.fuzzyClock.fuzziness', old => (oldFuzzyEnabled ? Math.round(Number(old) / 10) : 0));
  const clockSpan = createElement('span', null, '00:00:00');
  let clockSpanClone;
  const fuzzySpan = createElement('span', null, '🕛️🕒🕕🕘');
  let fuzzySpanClone;
  let cancelAnimation = null;
  const fuzzyTranslations = LLF('navbarMarquee', 'clock').fuzzy;
  const fuzzyTime = now => {
    const fuzzyness = fuzzy.value;
    if (0 === fuzzyness) return '';
    else if (1 === fuzzyness || 2 === fuzzyness) {
      const translations = fuzzyTranslations.minutes;
      const sectorSize = { 1: 5, 2: 15 }[fuzzyness];
      const minutes = (now.getTime() % 36e5) / 6e4;
      return translations[Math.floor((minutes + sectorSize / 2) / sectorSize) * sectorSize]({
        hour: now.getHours() % 12 || 12,
      });
    } else if (3 === fuzzyness || 4 === fuzzyness) {
      const translationKey = { 3: 'food', 4: 'day' }[fuzzyness];
      const translations = fuzzyTranslations[translationKey];
      const hour = now.getHours();
      return translations[Math.floor(hour / (24 / Object.keys(translations).length)).toString()]();
    } else if (5 === fuzzyness) {
      const dayOfWeek = now.getDay();
      const weekSection =
        1 === dayOfWeek ? 0
        : dayOfWeek >= 2 && dayOfWeek <= 3 ? 1
        : dayOfWeek <= 5 ? 2
        : 3;
      return fuzzyTranslations.week[weekSection]();
    }
    return '';
  };
  const onload = () => {
    if (enabled$1.value) [[, clockSpanClone]] = marquee.add(clockSpan);
    else marquee.remove(clockSpan);
    if (0 !== fuzzy.value) [[, fuzzySpanClone]] = marquee.add(fuzzySpan);
    else marquee.remove(fuzzySpan);
    if (null === cancelAnimation && (enabled$1.value || 0 !== fuzzy.value)) {
      cancelAnimation = animate(
        1e3,
        () => {
          const now = new Date();
          if (enabled$1.value && clockSpanClone) {
            clockSpan.textContent = clockSpanClone.textContent = timeToString(now, seconds.value);
          }
          if (0 !== fuzzy.value && fuzzySpanClone) {
            fuzzySpan.textContent = fuzzySpanClone.textContent = fuzzyTime(now);
            fuzzySpan.title = fuzzySpanClone.title = timeToString(now, true);
          }
        },
        true
      );
    } else if (!enabled$1.value && 0 === fuzzy.value) {
      cancelAnimation?.();
      cancelAnimation = null;
    }
  };
  enabled$1.onInput(onload);
  fuzzy.onInput(onload);
  const __vite_glob_1_18 = Feature.register({
    settings: new Set([enabled$1, seconds, fuzzy]),
    onload,
    onunload: () => {
      marquee.remove(clockSpan);
      marquee.remove(fuzzySpan);
      cancelAnimation?.();
      cancelAnimation = null;
    },
  });
  const style = { eventAdvertisement: 'better-moodle_navbarMarquee-eventAdvertisements__event-advertisement' };
  const LL = LLF('navbarMarquee', 'eventAdvertisements');
  const enabled = new BooleanSetting('enabled', true).addAlias('general.eventAdvertisements');
  const noticeTime = new SliderSetting('noticeTime', 14, { min: 1, max: 33, step: 1, labels: 5 }).disabledIf(
    enabled,
    '!=',
    true
  );
  const spans = new Map();
  let events;
  const getEvents = () =>
    events ?
      Promise.resolve(events)
    : cachedRequest(icsUrl('events'), 3e5, 'json').then(({ value }) => (events = value));
  const removeAll = () => {
    spans.keys().forEach(span => marquee.remove(span));
    spans.clear();
  };
  const createEventSpan = event => {
    const span = createElement(
      'span',
      { className: style.eventAdvertisement },
      datetimeToString(new Date(event.start), true, false),
      `: ${event.name[BETTER_MOODLE_LANG]}`
    );
    spans.set(span, event);
    span.addEventListener('click', e => {
      e.preventDefault();
      const table = createElement(
        'table',
        { className: 'table table-striped table-hover m-0' },
        createElement(
          'tbody',
          null,
          createElement(
            'tr',
            null,
            createElement('th', null, LL.start(), ':'),
            createElement('td', null, datetimeToString(new Date(event.start)))
          ),
          createElement(
            'tr',
            null,
            createElement('th', null, LL.end(), ':'),
            createElement('td', null, datetimeToString(new Date(event.end)))
          ),
          event.rruleString ?
            createElement(
              'tr',
              null,
              createElement('th', null, LL.rrule(), ':'),
              createElement('td', null, event.rruleString[BETTER_MOODLE_LANG])
            )
          : null,
          event.location ?
            createElement(
              'tr',
              null,
              createElement('th', null, LL.location(), ':'),
              createElement('td', null, event.location)
            )
          : null,
          createElement('tr', null, createElement('td', { colSpan: 2 }, event.desc))
        )
      );
      new Modal({
        type: 'ALERT',
        scrollable: true,
        title: event.name[BETTER_MOODLE_LANG],
        body: table,
        bodyClass: ['table-responsive', 'p-0'],
        footer:
          event.url ? createElement('a', { className: 'w-100', href: event.url, target: '_blank' }, event.url) : void 0,
        removeOnClose: true,
      }).show();
    });
    return span;
  };
  const reload = async () => {
    if (enabled.value) {
      const noticeTimeMs = 864e5 * noticeTime.value;
      const events2 = await getEvents();
      removeAll();
      events2.forEach(event => {
        if (new Date(event.start).getTime() <= Date.now() + noticeTimeMs) marquee.add(createEventSpan(event));
      });
    } else removeAll();
  };
  enabled.onInput(() => void reload());
  noticeTime.onInput(() => void reload());
  const __vite_glob_1_19 = Feature.register({
    settings: new Set([enabled, noticeTime]),
    onload: reload,
    onunload: reload,
  });
  importCSS(
    '[data-block=evaluationzensus_dashboard] .content > div:first-child {\n  grid-template-columns: repeat(auto-fill, minmax(49%, 1fr)) !important;\n}\n[data-block=evaluationzensus_dashboard] .content > div:first-child div {\n  align-content: center;\n}\n[data-block=evaluationzensus_dashboard] .content > div:first-child strong::after {\n  content: "Bis zum 31.08.";\n  display: block;\n  font-size: small;\n  text-transform: none;\n}'
  );
  const featureGroupImports = Object.fromEntries(
    Object.entries(
      Object.assign({
        '/src/features/bookmarks/index.tsx': __vite_glob_0_0,
        '/src/features/courses/index.ts': __vite_glob_0_1,
        '/src/features/darkmode/index.ts': __vite_glob_0_2,
        '/src/features/dashboard/index.ts': __vite_glob_0_3,
        '/src/features/general/index.ts': __vite_glob_0_4,
        '/src/features/linkIcons/index.ts': __vite_glob_0_5,
        '/src/features/messages/index.ts': __vite_glob_0_6,
        '/src/features/navbarMarquee/index.ts': __vite_glob_0_7,
        '/src/features/nina/index.tsx': __vite_glob_0_8,
        '/src/features/semesterzeiten/index.tsx': __vite_glob_0_9,
        '/src/features/speiseplan/index.tsx': __vite_glob_0_10,
        '/src/features/weather/index.tsx': __vite_glob_0_11,
      })
    ).map(([key, value]) => [key.replace(/\.tsx?$/, ''), value])
  );
  const featureImports = Object.fromEntries(
    Object.entries(
      Object.assign({
        '/src/features/courses/cardsPerRow.ts': __vite_glob_1_0,
        '/src/features/courses/grades.tsx': __vite_glob_1_1,
        '/src/features/courses/hideSelfEnrolHint.ts': __vite_glob_1_2,
        '/src/features/courses/images.tsx': __vite_glob_1_3,
        '/src/features/courses/navbarDropdown.tsx': __vite_glob_1_4,
        '/src/features/courses/noDownload.ts': __vite_glob_1_5,
        '/src/features/courses/quickRoleChange.ts': __vite_glob_1_6,
        '/src/features/courses/sectionCourseIndex.ts': __vite_glob_1_7,
        '/src/features/dashboard/layout.tsx': __vite_glob_1_8,
        '/src/features/general/externalLinks.ts': __vite_glob_1_9,
        '/src/features/general/fullWidth.ts': __vite_glob_1_10,
        '/src/features/general/googlyEyes.tsx': __vite_glob_1_11,
        '/src/features/general/leftSecondaryNav.ts': __vite_glob_1_12,
        '/src/features/general/prideLogo.ts': __vite_glob_1_13,
        '/src/features/general/truncatedTexts.ts': __vite_glob_1_14,
        '/src/features/messages/markdownSupport.tsx': __vite_glob_1_15,
        '/src/features/messages/sendHotkey.ts': __vite_glob_1_16,
        '/src/features/navbarMarquee/christmasCountdown.tsx': __vite_glob_1_17,
        '/src/features/navbarMarquee/clock.tsx': __vite_glob_1_18,
        '/src/features/navbarMarquee/eventAdvertisements.tsx': __vite_glob_1_19,
      })
    ).map(([key, value]) => [key.replace(/\.tsx?$/, ''), value])
  );
  const initFeature = (group, featureId) => {
    const Feature2 = featureImports[`/src/features/${group.id}/${featureId}`];
    if (!Feature2) return;
    return new Feature2(featureId, group);
  };
  const featureGroups$1 = new Map();
  Object.entries(featureGroupImports).forEach(([id, FeatureGroup2]) => {
    const groupId = id.split('/')[3];
    if (!isFeatureGroup(groupId)) return;
    const featureGroup = new FeatureGroup2(groupId);
    featureGroup.loadSettings();
    featureGroup.load();
    featureGroup.loadFeatures(id2 => initFeature(featureGroup, id2));
    featureGroups$1.set(groupId, featureGroup);
  });
  const onImportsDoneResolvers = new Set();
  const createImportDoneResolver = () => {
    const { promise, resolve } = Promise.withResolvers();
    onImportsDoneResolvers.add(resolve);
    return promise;
  };
  let importsAreDone = false;
  Promise.all(featureGroups$1.values().map(group => group.FieldSet.awaitReady()))
    .then(() => (importsAreDone = true))
    .then(() => onImportsDoneResolvers.forEach(resolver => resolver(featureGroups$1)));
  const lt = (version, other) => {
    const [firstMajor, firstMinor, firstPatch] = version.split('.').map(p => parseInt(p));
    const [otherMajor, otherMinor, otherPatch] = other.split('.').map(p => parseInt(p));
    return (
      otherMajor > firstMajor ||
      (otherMajor === firstMajor && otherMinor > firstMinor) ||
      (otherMajor === firstMajor && otherMinor === firstMinor && otherPatch > firstPatch)
    );
  };
  const seenSettings = GM_getValue('seenSettings', []);
  const settingsBtnTitle = `Better-Moodle: ${LL$a.settings.modal.title()}`;
  const SettingsBtnIcon = createElement('i', { className: 'fa fa-gears fa-fw', role: 'img', title: settingsBtnTitle });
  const SettingsBtn = createElement(
    NavbarItem,
    { order: 999 },
    createElement(
      'div',
      {
        'id': settingsStyle.openSettingsBtn,
        'role': 'button',
        'className': 'nav-link position-relative icon-no-margin loading',
        'title': settingsBtnTitle,
        'aria-label': settingsBtnTitle,
      },
      SettingsBtnIcon
    )
  );
  const UpdateAvailableBadge = createElement('div', { className: 'count-container' });
  SettingsBtn.put();
  const ChangelogBtn = createElement(
    GithubLink,
    {
      path: '/blob/main/CHANGELOG.md',
      icon: false,
      className: 'btn btn-outline-primary',
      title: LL$a.settings.changelog(),
    },
    createElement('i', { className: 'fa fa-history fa-fw' }),
    createElement('span', null, LL$a.settings.changelog())
  );
  const getChangelogHtml = () =>
    cachedRequest(rawGithubPath('CHANGELOG.md'), 3e5, 'text', md =>
      mdToHtml(
        md
          .replace(/^#\s.*/g, '')
          .trim()
          .replace(/(?<=\n)(?=^##\s)/gm, '---\n\n'),
        3,
        'changelog'
      )
    ).then(({ value }) => value);
  ChangelogBtn.addEventListener('click', e => {
    e.preventDefault();
    new Modal({
      type: 'ALERT',
      large: true,
      title: createElement(
        Fragment,
        null,
        createElement(GithubLink, { path: '/blob/main/CHANGELOG.md' }),
        ' Better-Moodle: ',
        LL$a.settings.changelog()
      ),
      body: getChangelogHtml(),
      removeOnClose: true,
    }).show();
  });
  const supportPath = `/blob/main/support/${BETTER_MOODLE_LANG}.md`;
  const getSupportHtml = () =>
    cachedRequest(rawGithubPath(`support/${BETTER_MOODLE_LANG}.md`), 864e5, 'text', md => mdToHtml(md, 3)).then(
      ({ value }) => value
    );
  const SupportBtn = createElement(
    'button',
    { className: 'btn btn-link btn-sm' },
    createElement('i', { className: 'fa fa-question-circle fa-fw' }),
    LL$a.support.title()
  );
  SupportBtn.addEventListener('click', e => {
    e.preventDefault();
    new Modal({
      type: 'ALERT',
      large: true,
      title: createElement(Fragment, null, createElement(GithubLink, { path: supportPath }), ' ', LL$a.support.title()),
      body: getSupportHtml(),
      buttons: { cancel: LL$a.support.close() },
      removeOnClose: true,
    }).show();
  });
  const latestVersionEl = createElement('code', { id: PREFIX('settings_latest-version') });
  const SupportWrapper = createElement(
    'div',
    {
      id: settingsStyle.supportWrapper,
      className: 'position-absolute z-index-1 d-flex flex-row small card border-light mb-3',
    },
    SupportBtn,
    createElement(
      'div',
      { className: 'd-flex flex-row flex-lg-column align-items-center' },
      createElement(
        'span',
        null,
        LL$a.settings.modal.installedVersion(),
        ':',
        ' ',
        createElement('code', null, GM_info.script.version)
      ),
      createElement('span', null, LL$a.settings.modal.latestVersion(), ': ', latestVersionEl)
    )
  );
  const UpdateBtn = createElement('button', { className: 'btn btn-primary btn-sm' }, LL$a.update.btn());
  UpdateBtn.addEventListener('click', e => {
    e.preventDefault();
    new Modal({
      type: 'SAVE_CANCEL',
      title: LL$a.update.title(),
      body: getChangelogHtml().then(changelogHtml => {
        const body = createElement(Fragment, null);
        body.append(
          ...Array.from(htmlToElements(mdToHtml(LL$a.update.body()))),
          ...Array.from(htmlToElements(changelogHtml))
        );
        const currentId = mdID(`* ${GM_info.script.version}`, 'changelog');
        body.querySelectorAll(`[id^="${currentId}"], [id^="${currentId}"] ~ *`).forEach(el => el.remove());
        return body;
      }),
      buttons: { save: LL$a.update.reload(), cancel: LL$a.update.close() },
      removeOnClose: true,
    })
      .onSave(() => window.location.reload())
      .on('bodyRendered', () => {
        if (GM_info.script.downloadURL) open(GM_info.script.downloadURL, '_self');
      })
      .show();
  });
  let updateCheckRetryTimeout;
  const checkForUpdates = () =>
    getLoadingSpinner()
      .then(spinner => document.getElementById(latestVersionEl.id)?.replaceChildren(spinner))
      .then(() => request('https://api.github.com/repos/jxn-30/better-moodle/releases/latest'))
      .then(res => res.json())
      .then(({ tag_name: latestVersion }) => {
        if (!latestVersion) {
          throw new Error(
            `It is unlikely that ${JSON.stringify(latestVersion)} is the latest version. Aborting update check, please try again in a minute.`
          );
        }
        latestVersionEl.replaceChildren(latestVersion);
        return lt(GM_info.script.version, latestVersion);
      })
      .then(updateAvailable => {
        updateCheckRetryTimeout = null;
        if (!updateAvailable) {
          UpdateAvailableBadge.remove();
          return;
        }
        document.getElementById(settingsStyle.supportWrapper)?.append(UpdateBtn);
        if (updateNotification.value) {
          document.getElementById(settingsStyle.openSettingsBtn)?.append(UpdateAvailableBadge);
        } else UpdateAvailableBadge.remove();
      })
      .catch(() => {
        updateCheckRetryTimeout ??= setTimeout(() => void checkForUpdates(), 6e4);
      });
  checkForUpdates();
  updateNotification.onChange(() => void checkForUpdates());
  const ExportBtn = createElement(
    'button',
    { className: 'btn btn-outline-primary', title: LL$a.settings.modal.export() },
    createElement('i', { className: 'fa fa-download fa-fw' }),
    createElement('span', null, LL$a.settings.modal.export())
  );
  ExportBtn.addEventListener('click', e => {
    e.preventDefault();
    const unwantedKeys = new Set(['_network_cache']);
    const storage = Object.fromEntries(
      GM_listValues()
        .filter(key => !unwantedKeys.has(key))
        .toSorted()
        .map(key => [key, GM_getValue(key)])
    );
    const blob = new Blob([JSON.stringify(storage)], { type: 'application/json' });
    const link = document.createElement('a');
    link.download = 'better-moodle-settings.json';
    link.href = URL.createObjectURL(blob);
    link.click();
  });
  const ImportBtn = createElement(
    'button',
    { className: 'btn btn-outline-primary', title: LL$a.settings.modal.import() },
    createElement('i', { className: 'fa fa-upload fa-fw' }),
    createElement('span', null, LL$a.settings.modal.import())
  );
  ImportBtn.addEventListener('click', e => {
    e.preventDefault();
    const importInput = document.createElement('input');
    importInput.type = 'file';
    importInput.accept = '.json';
    importInput.addEventListener('change', () => {
      const file = importInput.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.addEventListener('load', () => {
        const result = reader.result ?? '{}';
        const config = JSON.parse(
          result instanceof ArrayBuffer ? new TextDecoder('utf-8').decode(new Uint8Array(result)) : result
        );
        Object.entries(config)
          .toSorted(([a], [b]) => a.localeCompare(b))
          .forEach(([key, value]) => GM_setValue(key, value));
        window.location.reload();
      });
      reader.readAsText(file);
    });
    importInput.click();
  });
  const SearchInput = createElement('input', {
    className: 'form-control-sm form-control',
    type: 'search',
    placeholder: LL$a.settings.modal.search(),
  });
  const SearchStyle = createElement('style', null);
  const SearchWrapper = createElement(
    'div',
    { className: 'form-group ml-auto mr-auto' },
    SearchInput,
    createElement('i', { class: 'fa-solid fa-search' }),
    SearchStyle
  );
  SearchInput.addEventListener(
    'input',
    debounce(() => {
      const search = SearchInput.value.trim();
      if (!search) SearchStyle.textContent = '';
      else {
        SearchStyle.textContent = `
#${settingsStyle.settingsForm} .icons-collapse-expand {
    display: none;
}

#${settingsStyle.settingsForm} .fcontainer.collapseable {
    display: block;
}

#${settingsStyle.settingsForm} .fitem:not([data-search*="${CSS.escape(search)}" i]),
#${settingsStyle.settingsForm} fieldset:not(:has(.fitem[data-search*="${CSS.escape(search)}" i])) {
    display: none;
}
  `;
      }
    }, 100)
  );
  document.addEventListener('keydown', e => {
    if ('k' === e.key && e.ctrlKey) {
      e.preventDefault();
      SearchInput.focus();
    }
  });
  const newBadges = new Set();
  const featureGroups = await (() =>
    importsAreDone ? Promise.resolve(featureGroups$1) : createImportDoneResolver())();
  const settingsModal = new Modal({
    type: 'SAVE_CANCEL',
    large: true,
    scrollable: true,
    backgroundImage: rawGithubPath('img/moothel.png'),
    title: createElement(
      Fragment,
      null,
      createElement(GithubLink, { path: '/tree/main' }),
      ' ',
      'Better-Moodle: ',
      LL$a.settings.modal.title()
    ),
    body: createElement(
      Fragment,
      null,
      SupportWrapper,
      createElement(
        'form',
        { id: settingsStyle.settingsForm, className: 'mform' },
        [
          'general',
          'darkmode',
          'dashboard',
          'courses',
          'messages',
          'navbarMarquee',
          'linkIcons',
          'speiseplan',
          'semesterzeiten',
          'bookmarks',
          'weather',
          'nina',
        ]
          .map(group => featureGroups.get(group)?.FieldSet)
          .filter(fieldset => void 0 !== fieldset)
      )
    ),
    footer: createElement(
      'div',
      { className: 'btn-group mr-auto', id: settingsStyle.settingsFooterBtns },
      ChangelogBtn,
      ExportBtn,
      ImportBtn
    ),
  })
    .onShown(() => void checkForUpdates())
    .onCancel(() => featureGroups.forEach(group => group.undoSettings()))
    .onSave(event => {
      featureGroups.forEach(group => group.saveSettings());
      requirePromise(['core/toast']).then(
        ([{ add: add2 }]) => void add2(LL$a.settings.saved(), { type: 'success', autohide: true, closeButton: true })
      );
      if (TempStorage$1.settingsRequireReload) {
        event.preventDefault();
        window.location.reload();
      }
    })
    .onReady(() => document.getElementById(settingsStyle.openSettingsBtn)?.classList.remove('loading'))
    .setTrigger(SettingsBtn);
  settingsModal
    .getTitle()
    .then(title =>
      title.after(
        SearchWrapper,
        createElement('a', { href: '/user/preferences.php', target: '_blank' }, LL$a.settings.modal.moodleSettings())
      )
    );
  const markVisibleNewSettingsAsSeen = body => {
    const { top: bodyTop, bottom: bodyBottom } = body.getBoundingClientRect();
    newBadges.forEach(badge => {
      if (!badge.closest('.fcontainer.show')) return;
      const { top: badgeTop, bottom: badgeBottom } = badge.getBoundingClientRect();
      if (badgeTop < bodyTop || badgeBottom > bodyBottom) return;
      newBadges.delete(badge);
      const setting = badge.dataset.setting;
      if (setting) seenSettings.push(setting);
      GM_setValue('seenSettings', seenSettings);
    });
    if (!newBadges.size) {
      newSettingsTooltip?.dispose();
      newSettingsTooltip = null;
    }
  };
  settingsModal.getBody().then(([body]) => {
    body.querySelectorAll(`.fcontainer .${settingsStyle.newSettingBadge}`).forEach(badge => newBadges.add(badge));
    const debounced = debounce(() => markVisibleNewSettingsAsSeen(body), 1e3);
    body.addEventListener('scrollend', debounced);
    settingsModal.onShown(() => markVisibleNewSettingsAsSeen(body));
    const updateNewBadgesVisibility = () =>
      body.classList.toggle(settingsStyle.hideNewSettingBadges, !highlightNewSettings.value);
    updateNewBadgesVisibility();
    highlightNewSettings.onInput(() => updateNewBadgesVisibility());
  });
  const allSettingIDs = featureGroups.values().reduce((acc, group) => acc.union(new Set(group.settingIDs)), new Set());
  const settingIDMap = new Map([...featureGroups.values().flatMap(group => group.settingIDMap)]);
  GM_setValue(
    'seenSettings',
    Array.from(new Set(seenSettings.map(id => settingIDMap.get(id)?.id)).intersection(allSettingIDs))
  );
  let newSettingsTooltip;
  if (
    isNewInstallation ||
    0 === seenSettings.length ||
    (newSettingsTooltip$1.value && featureGroups.values().some(group => group.hasNewSetting))
  ) {
    requirePromise(['theme_boost/bootstrap/tooltip'])
      .then(([Tooltip]) => {
        SettingsBtnIcon.title = LL$a.settings.newBadge();
        return new Tooltip(SettingsBtnIcon, {
          trigger: 'manual',
          title: LL$a.settings.newBadge(),
          template: createElement(
            'div',
            { className: 'tooltip', role: 'tooltip' },
            createElement('div', { className: 'arrow' }),
            createElement('div', {
              className: [
                'tooltip-inner badge bg-success text-uppercase',
                globalStyle.shining,
                globalStyle.sparkling,
                settingsStyle.newSettingBadge,
              ],
            })
          ).outerHTML,
        });
      })
      .then(tooltip2 => {
        tooltip2.getTipElement().addEventListener('click', () => SettingsBtn.click());
        tooltip2.show();
        tooltip2.update();
        newSettingsTooltip = tooltip2;
      });
    let listenersAttached = false;
    settingsModal.onShown(() => {
      if (!newSettingsTooltip || listenersAttached) return;
      listenersAttached = true;
      const hide2 = () => {
        newSettingsTooltip?.hide();
      };
      const show = () => {
        newSettingsTooltip?.show();
        newSettingsTooltip?.update();
      };
      hide2();
      if (isNewInstallation || 0 === seenSettings.length) GM_setValue('seenSettings', Array.from(allSettingIDs));
      SettingsBtn.addEventListener('mouseenter', show);
      SettingsBtn.addEventListener('mouseleave', hide2);
      SettingsBtn.addEventListener('focusin', show);
      SettingsBtn.addEventListener('focusout', hide2);
      newSettingsTooltip.getTipElement().addEventListener('mouseenter', show);
      newSettingsTooltip.getTipElement().addEventListener('mouseleave', hide2);
    });
  }
  var define_MIN_SUPPORTED_BROWSERS_default = {
    'firefox (android)': 142,
    'chrome': 137,
    'edge': 137,
    'firefox': 139,
    'opera': 118,
  };
  if (
    !new RegExp(
      'Edge?\\/(13[7-9]|1[4-9]\\d|[2-9]\\d{2}|\\d{4,})\\.\\d+(\\.\\d+|)|Firefox\\/(139|1[4-9]\\d|[2-9]\\d{2}|\\d{4,})\\.\\d+(\\.\\d+|)|Chrom(ium|e)\\/(13[7-9]|1[4-9]\\d|[2-9]\\d{2}|\\d{4,})\\.\\d+(\\.\\d+|)|Chrome.+OPR\\/(1{2}[89]|1[2-9]\\d|[2-9]\\d{2}|\\d{4,})\\.\\d+\\.\\d+|Android.+Firefox\\/(14[2-9]|1[5-9]\\d|[2-9]\\d{2}|\\d{4,})\\.\\d+(\\.\\d+|)',
      ''
    ).test(navigator.userAgent)
  ) {
    requirePromise(['core/config']).then(([config]) => {
      const storageKey = PREFIX('unsupported_browser-informed');
      const stored = localStorage.getItem(storageKey);
      const uaString = `u!${navigator.userAgent}`;
      const sessionString = `s!${config.sesskey}`;
      if (stored === uaString || stored === sessionString) return;
      new Modal({
        type: 'SAVE_CANCEL',
        large: false,
        title: LL$a.browserCheck.title(),
        body: createElement(
          'div',
          { className: 'table-responsive' },
          htmlToElements(mdToHtml(LL$a.browserCheck.body())),
          createElement(
            'table',
            { className: 'table table-striped table-hover table-sm' },
            createElement(
              'thead',
              null,
              createElement(
                'tr',
                null,
                createElement('th', null, LL$a.browserCheck.browser()),
                createElement('th', null, LL$a.browserCheck.minVersion())
              )
            ),
            createElement(
              'tbody',
              null,
              Object.entries(define_MIN_SUPPORTED_BROWSERS_default).map(([browser, version]) =>
                createElement(
                  'tr',
                  { className: 'text-capitalize' },
                  createElement('td', null, browser),
                  createElement('td', null, version)
                )
              )
            )
          )
        ),
        buttons: { cancel: LL$a.browserCheck.dismiss.version(), save: LL$a.browserCheck.dismiss.session() },
        removeOnClose: true,
      })
        .show()
        .onCancel(() => localStorage.setItem(storageKey, uaString))
        .onSave(() => localStorage.setItem(storageKey, sessionString));
    });
  }
})();
